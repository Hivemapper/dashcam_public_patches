diff --git a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
index 6e99da17e3c5..1964e985ea4a 100644
--- a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
+++ b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
@@ -596,3 +596,24 @@ __overrides__ {
                           <&spi0>, "dmas:8=", <&dma40>;
        };
 };
+
+&spi0 {
+       status = "okay";
+
+       invn_icm_spi: iim42600@0 {
+               compatible = "invensense,iim42600";
+               reg = <0>;
+               interrupt-parent = <8>;
+               interrupts = <56 IRQ_TYPE_LEVEL_LOW>;
+               spi-max-frequency = <24000000>;
+               axis_map_x = <1>;
+               axis_map_y = <0>;
+               axis_map_z = <2>;
+               negate_x = <1>;
+               negate_y = <0>;
+               negate_z = <0>;
+               inven,secondary_type = "none";
+               inven,aux_type = "none";
+               inven,read_only_slave_type = "none";
+       };
+};
diff --git a/arch/arm/configs/bcm2711_defconfig b/arch/arm/configs/bcm2711_defconfig
index 446d62e8fa2b..5a1ce560d0f3 100644
--- a/arch/arm/configs/bcm2711_defconfig
+++ b/arch/arm/configs/bcm2711_defconfig
@@ -1373,8 +1373,10 @@ CONFIG_BCM2835_MBOX=y
 # CONFIG_IOMMU_SUPPORT is not set
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_EXTCON_ARIZONA=m
-CONFIG_IIO=m
+CONFIG_IIO=y
 CONFIG_IIO_BUFFER_CB=m
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
 CONFIG_MCP320X=m
 CONFIG_MCP3422=m
 CONFIG_TI_ADS1015=m
@@ -1384,6 +1384,9 @@ CONFIG_SPS30=m
 CONFIG_DHT11=m
 CONFIG_HDC100X=m
 CONFIG_HTU21=m
+CONFIG_INV_ICM42600=y
+CONFIG_INV_ICM42600_I2C=m
+CONFIG_INV_ICM42600_SPI=y
 CONFIG_INV_MPU6050_I2C=m
 CONFIG_APDS9960=m
 CONFIG_BH1750=m
diff --git a/drivers/iio/imu/Kconfig b/drivers/iio/imu/Kconfig
index 001ca2c3ff95..11a09c81ae27 100644
--- a/drivers/iio/imu/Kconfig
+++ b/drivers/iio/imu/Kconfig
@@ -92,6 +92,7 @@ config KMX61
 	  be called kmx61.
 
 source "drivers/iio/imu/inv_icm42600/Kconfig"
+source "drivers/iio/imu/inv_mpu/Kconfig"
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
 source "drivers/iio/imu/st_lsm6dsx/Kconfig"
 source "drivers/iio/imu/st_lsm9ds0/Kconfig"
diff --git a/drivers/iio/imu/Makefile b/drivers/iio/imu/Makefile
index c82748096c77..c760664455ac 100644
--- a/drivers/iio/imu/Makefile
+++ b/drivers/iio/imu/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_FXOS8700_I2C) += fxos8700_i2c.o
 obj-$(CONFIG_FXOS8700_SPI) += fxos8700_spi.o
 
 obj-y += inv_icm42600/
+obj-y += inv_mpu/
 obj-y += inv_mpu6050/
 
 obj-$(CONFIG_KMX61) += kmx61.o
diff --git a/drivers/iio/imu/inv_mpu/Kconfig b/drivers/iio/imu/inv_mpu/Kconfig
new file mode 100644
index 000000000000..488391331760
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/Kconfig
@@ -0,0 +1,70 @@
+#
+# inv-mpu-iio driver for Invensense MPU devices
+#
+
+config INV_MPU_IIO
+	tristate
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+
+choice
+	prompt "Chip name"
+	depends on INV_MPU_IIO
+
+config INV_MPU_IIO_ICM20648
+	bool "ICM20648/ICM20948"
+	select CRC32
+	help
+	  Select this if you are using a ICM20648/ICM20948 chip.
+
+config INV_MPU_IIO_ICM20608D
+	bool "ICM20608D/ICM206x9/ICM20789"
+	select CRC32
+	help
+	  Select this if you are using a ICM20608D/ICM206x9/ICM20789 chip.
+
+config INV_MPU_IIO_ICM20602
+	bool "ICM20602"
+	help
+	  Select this if you are using a ICM20602 chip.
+
+config INV_MPU_IIO_ICM20690
+	bool "ICM20690"
+	help
+	  Select this if you are using a ICM20690 chip.
+
+config INV_MPU_IIO_IAM20680
+	bool "IAM20680"
+	help
+	  Select this if you are using a IAM20680 chip.
+
+config INV_MPU_IIO_ICM42600
+	bool "ICM42600"
+	help
+	  Select this if you are using a ICM426xx/ICM40607/ICM40609D/IIM42600 chip.
+
+config INV_MPU_IIO_ICM43600
+	bool "ICM43600"
+	help
+	  Select this if you are using a ICM43600 chip.
+
+endchoice
+
+config INV_MPU_IIO_I2C
+	tristate "Invensense ICM20xxx devices (I2C)"
+	depends on I2C && !INV_MPU6050_IIO
+	select INV_MPU_IIO
+	help
+	  This driver supports Invensense ICM20xxx devices over I2C.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu-iio-i2c.
+
+config INV_MPU_IIO_SPI
+	tristate "Invensense ICM20xxx devices (SPI)"
+	depends on SPI_MASTER && !INV_MPU6050_IIO
+	select INV_MPU_IIO
+	help
+	  This driver supports Invensense ICM20xxx devices over SPI.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu-iio-spi.
+
diff --git a/drivers/iio/imu/inv_mpu/Makefile b/drivers/iio/imu/inv_mpu/Makefile
new file mode 100644
index 000000000000..524d75150de4
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/Makefile
@@ -0,0 +1,74 @@
+#
+# Makefile for Invensense inv-mpu-iio device.
+#
+
+obj-$(CONFIG_INV_MPU_IIO) += inv-mpu-iio.o
+
+inv-mpu-iio-objs += inv_mpu_common.o
+inv-mpu-iio-objs += inv_mpu_ring.o
+inv-mpu-iio-objs += inv_mpu_timestamp.o
+inv-mpu-iio-objs += inv_mpu_dts.o
+
+# chip support
+ifeq ($(CONFIG_INV_MPU_IIO_ICM20648), y)
+inv-mpu-iio-objs += icm20648/inv_mpu_init.o
+inv-mpu-iio-objs += icm20648/inv_mpu_core.o
+inv-mpu-iio-objs += icm20648/inv_mpu_parsing.o
+inv-mpu-iio-objs += icm20648/inv_mpu_setup.o
+inv-mpu-iio-objs += icm20648/inv_mpu_dmp_fifo.o
+inv-mpu-iio-objs += icm20648/inv_slave_compass.o
+inv-mpu-iio-objs += icm20648/inv_slave_pressure.o
+inv-mpu-iio-objs += icm20648/inv_slave_als.o
+inv-mpu-iio-objs += icm20648/inv_mpu_load_dmp.o
+inv-mpu-iio-objs += icm20648/inv_mpu_selftest.o
+inv-mpu-iio-objs += dmp_support/inv_mpu_misc.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20690), y)
+inv-mpu-iio-objs += icm20690/inv_mpu_init_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_core_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_parsing_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_setup_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_selftest_20690.o
+inv-mpu-iio-objs += icm20690/inv_slave_compass.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20602), y)
+inv-mpu-iio-objs += icm20602/inv_mpu_init_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_core_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_parsing_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_setup_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_selftest_20602.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20608D), y)
+inv-mpu-iio-objs += icm20608d/inv_mpu_init_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_core_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_parsing_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_setup_20608D.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_dmp_fifo.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_load_dmp.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_selftest_20608.o
+inv-mpu-iio-objs += dmp_support/inv_mpu_misc.o
+else ifeq ($(CONFIG_INV_MPU_IIO_IAM20680), y)
+inv-mpu-iio-objs += iam20680/inv_mpu_init_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_core_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_parsing_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_setup_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_selftest_20680.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM42600), y)
+inv-mpu-iio-objs += icm42600/inv_mpu_init_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_core_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_parsing_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_setup_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_misc_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_selftest_42600.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM43600), y)
+inv-mpu-iio-objs += icm43600/inv_mpu_init_43600.o
+inv-mpu-iio-objs += icm43600/inv_mpu_core_43600.o
+inv-mpu-iio-objs += icm43600/inv_mpu_parsing_43600.o
+inv-mpu-iio-objs += icm43600/inv_mpu_setup_43600.o
+inv-mpu-iio-objs += icm43600/inv_mpu_misc_43600.o
+inv-mpu-iio-objs += icm43600/inv_mpu_selftest_43600.o
+endif
+
+# Bus support
+obj-$(CONFIG_INV_MPU_IIO_I2C) += inv-mpu-iio-i2c.o
+inv-mpu-iio-i2c-objs := inv_mpu_i2c.o
+obj-$(CONFIG_INV_MPU_IIO_SPI) += inv-mpu-iio-spi.o
+inv-mpu-iio-spi-objs := inv_mpu_spi.o
+
diff --git a/drivers/iio/imu/inv_mpu/README b/drivers/iio/imu/inv_mpu/README
new file mode 100644
index 000000000000..47ff5029ee6e
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/README
@@ -0,0 +1,117 @@
+Kernel driver inv-mpu-iio
+Author: InvenSense, Inc.
+
+
+Table of Contents
+=================
+- Description
+- Integrating the Driver in the Linux Kernel
+- Dts file
+- Communicating with the Driver in Userspace
+
+
+Description
+===========
+This document describes how to install the Invensense device driver into a
+Linux kernel. The supported chips are listed in Kconfig and user selects an
+appropriate one from .e.g. menuconfig.
+
+
+Integrating the Driver in the Linux Kernel
+==========================================
+Please add the files as follows (kernel 3.10):
+- Copy mpu.h to <kernel_root>/include/linux/iio/imu/
+- Copy inv_mpu folder under <kernel_root>/drivers/iio/imu/
+
+In order to see the driver in menuconfig when building the kernel, please
+make modifications as shown below:
+
+    add "source "drivers/iio/imu/inv_mpu/Kconfig""
+      in <kernel_root>/drivers/iio/imu/Kconfig
+
+    add "obj-y += inv_mpu/"
+      in <kernel_root>/drivers/iio/imu/Makefile
+
+
+
+Dts file
+========
+In order to recognize the Invensense device on the I2C/SPI bus, dts(or dtsi)
+file must be modified.
+
+Example)
+ICM20648 + AK09911/BMP280/APDS9930 on AUX I2C
+
+    i2c@f9968000 {
+        /* Invensense */
+        mpu6515_acc@68 {
+            compatible = "inven,icm20648";
+            reg = <0x68>;
+            interrupt-parent = <&msmgpio>;
+            interrupts = <73 0x2>;
+            inven,vdd_ana-supply = <&pm8941_l17>;
+            inven,vcc_i2c-supply = <&pm8941_lvs1>;
+            inven,gpio_int1 = <&msmgpio 73 0x00>;
+            fs_range = <0x00>;
+            /* mount matrix */
+            axis_map_x = <1>;
+            axis_map_y = <0>;
+            axis_map_z = <2>;
+            negate_x = <0>;
+            negate_y = <0>;
+            negate_z = <1>;
+            poll_interval = <200>;
+            min_interval = <5>;
+            inven,secondary_reg = <0x0c>;
+            /* If no compass sensor,
+             * replace "compass" with "none"
+             */
+            inven,secondary_type = "compass";
+            inven,secondary_name = "ak09911";
+            inven,secondary_axis_map_x = <1>;
+            inven,secondary_axis_map_y = <0>;
+            inven,secondary_axis_map_z = <2>;
+            inven,secondary_negate_x = <1>;
+            inven,secondary_negate_y = <1>;
+            inven,secondary_negate_z = <1>;
+            /* If no pressure sensor,
+             * replace "pressure" with "none"
+             */
+            inven,aux_type = "pressure";
+            inven,aux_name = "bmp280";
+            inven,aux_reg = <0x76>;
+            /* If no ALS sensor
+             * replace "als" with "none"
+             */
+            inven,read_only_slave_type = "als";
+            inven,read_only_slave_name = "apds9930";
+            inven,read_only_slave_reg = <0x39>;
+        };
+    };
+
+
+Communicating with the Driver in Userspace
+==========================================
+The driver generates several files in sysfs upon installation.
+These files are used to communicate with the driver. The files can be found at:
+
+(I2C) /sys/devices/*.i2c/i2c-*/*-*/iio:device*
+(SPI) /sys/devices/*.spi/spi_master/spi*/spi*.*/iio:device*
+
+Group and Owner for all entries should be updated to system/system at
+boot time to allow userspace to access properly.
+
+
+License
+=======
+Copyright (C) 2018 InvenSense, Inc.
+
+This software is licensed under the terms of the GNU General Public
+License version 2, as published by the Free Software Foundation, and
+may be copied, distributed, and modified under those terms.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
diff --git a/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c b/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c
new file mode 100644
index 000000000000..92d42eb7337e
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c
@@ -0,0 +1,77 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+int inv_stop_dmp(struct inv_mpu_state *st)
+{
+	return inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+}
+
+int inv_get_pedometer_steps(struct inv_mpu_state *st, int *ped)
+{
+	int r;
+
+	r = read_be32_from_mem(st, ped, PEDSTD_STEPCTR);
+
+	return r;
+}
+
+int inv_process_step_det(struct iio_dev *indio_dev, u8 *dptr)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u32 tmp;
+	u64 t;
+	s16 s[3];
+
+	tmp = be32_to_int(dptr);
+	tmp = inv_get_cntr_diff(st->ts_algo.start_dmp_counter, tmp);
+	t = st->ts_algo.last_run_time - (u64) tmp * st->eng_info[ENGINE_ACCEL].dur;
+	if (st->step_detector_l_on)
+		inv_push_8bytes_buffer(indio_dev, STEP_DETECTOR_HDR, t, s);
+	if (st->step_detector_wake_l_on)
+		inv_push_8bytes_buffer(indio_dev, STEP_DETECTOR_WAKE_HDR, t, s);
+
+	return 0;
+}
+
+int inv_get_pedometer_time(struct inv_mpu_state *st, int *ped)
+{
+	int r;
+
+	r = read_be32_from_mem(st, ped, PEDSTD_TIMECTR);
+
+	return r;
+}
+
+int inv_read_pedometer_counter(struct inv_mpu_state *st)
+{
+	int result;
+	u32 last_step_counter, curr_counter;
+	u64 counter;
+
+	result = read_be32_from_mem(st, &last_step_counter, STPDET_TIMESTAMP);
+	if (result)
+		return result;
+	if (0 != last_step_counter) {
+		result = read_be32_from_mem(st, &curr_counter, DMPRATE_CNTR);
+		if (result)
+			return result;
+		counter = inv_get_cntr_diff(curr_counter, last_step_counter);
+		st->ped.last_step_time = get_time_ns() - counter *
+		    st->eng_info[ENGINE_ACCEL].dur;
+	}
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c
new file mode 100644
index 000000000000..f1082eca1e41
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c
@@ -0,0 +1,1097 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[IAM20680] = {128, "iam20680"},
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static char debug_reg_addr = 0x6;
+#endif
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	result = inv_plat_read(st, addr, 2, d);
+	if (result)
+		goto accel_bias_set_err;
+	accel_reg_bias = ((int)d[0] << 8) | d[1];
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0
+	 */
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps
+	 */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	}
+	return count;
+}
+#endif
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0, sizeof(struct spi_transfer));
+
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store()
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show()
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.accel_enable);
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_wake_l_on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[2]);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 data[2];
+	s32 temp;
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_plat_read(st, REG_RAW_TEMP, 2, data);
+	if (res)
+		return res;
+	mutex_unlock(&st->lock);
+
+	temp = (s16)be16_to_cpup((__be16 *)(data)) * 10000;
+	temp = temp / TEMP_SENSITIVITY + TEMP_OFFSET;
+
+	return snprintf(buf, MAX_WR_SZ, "%d %lld\n", temp, get_time_ns());
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+#endif
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+#endif
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_pedometer_attributes[] = {
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+#endif
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_debug_attributes) +
+#endif
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_pedometer_attributes) +
+#endif
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "iam20680"))
+		st->chip_type = IAM20680;
+	else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+#endif
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	// dummy
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h
new file mode 100644
index 000000000000..8a61696c0107
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_20680_H_
+#define _INV_MPU_IIO_REG_20680_H_
+
+/* Uncomment when HAL does not support the algorithm library
+ * for calibration and sensor fusion not to expose unused
+ * sysfs entries
+ */
+// #define SUPPORT_ONLY_BASIC_FEATURES
+
+/* Uncomment to read data registers for sensor data instead of FIFO */
+//#define SENSOR_DATA_FROM_REGISTERS
+
+/* Uncomment to enable timer based batching */
+#define TIMER_BASED_BATCHING
+
+/* Polling (batch mode) can be enabled only when FIFO read */
+#if defined(SENSOR_DATA_FROM_REGISTERS)
+#undef TIMER_BASED_BATCHING
+#endif
+
+/*register and associated bit definition*/
+#define REG_XA_OFFS_H		0x77
+#define REG_YA_OFFS_H		0x7A
+#define REG_ZA_OFFS_H		0x7D
+#define REG_XG_OFFS_USR_H	0x13
+#define REG_YG_OFFS_USR_H	0x15
+#define REG_ZG_OFFS_USR_H	0x17
+#define REG_SAMPLE_RATE_DIV	0x19
+
+#define REG_CONFIG		0x1A
+#define EXT_SYNC_SET		8
+
+#define REG_GYRO_CONFIG		0x1B
+#define BITS_SELF_TEST_EN	0xE0
+#define SHIFT_GYRO_FS_SEL	0x03
+
+#define REG_ACCEL_CONFIG	0x1C
+#define SHIFT_ACCEL_FS		0x03
+
+#define REG_LP_MODE_CTRL	0x1E
+#define BIT_GYRO_CYCLE_EN	0x80
+
+#define REG_ACCEL_WOM_THR	0x1F
+#define REG_ACCEL_WOM_X_THR	0x20
+#define REG_ACCEL_WOM_Y_THR	0x21
+#define REG_ACCEL_WOM_Z_THR	0x22
+
+#define REG_ACCEL_MOT_THR	0x1F
+#define REG_ACCEL_MOT_DUR	0x20
+
+#define REG_ACCEL_CONFIG_2	0x1D
+#define BIT_ACCEL_FCHOCIE_B	0x08
+
+#define REG_FIFO_EN		0x23
+#define BITS_GYRO_FIFO_EN	0x70
+#define BIT_ACCEL_FIFO_EN	0x08
+
+#define REG_FSYNC_INT		0x36
+#define BIT_FSYNC_INT		0x80
+
+#define REG_INT_PIN_CFG		0x37
+
+#define REG_INT_ENABLE		0x38
+#define BIT_WOM_X_INT_EN	0x80
+#define BIT_WOM_Y_INT_EN	0x40
+#define BIT_WOM_Z_INT_EN	0x20
+#define BIT_WOM_ALL_INT_EN	0xE0
+#define BIT_FSYNC_INT_EN	0x8
+#define BIT_DATA_RDY_EN		0x1
+
+#define REG_INT_STATUS		0x3A
+#define BIT_WOM_X_INT		0x80
+#define BIT_WOM_Y_INT		0x40
+#define BIT_WOM_Z_INT		0x20
+
+#define REG_RAW_ACCEL		0x3B
+#define REG_RAW_TEMP		0x41
+#define REG_RAW_GYRO		0x43
+#define REG_EXT_SENS_DATA_00	0x49
+#define REG_EXT_SENS_DATA_08	0x51
+#define REG_EXT_SENS_DATA_09	0x52
+
+#define REG_ACCEL_INTEL_CTRL	0x69
+#define BIT_ACCEL_INTEL_EN	0x80
+#define BIT_ACCEL_INTEL_MODE	0x40
+
+#define REG_USER_CTRL		0x6A
+#define BIT_COND_RST		0x01
+#define BIT_FIFO_RST		0x04
+#define BIT_FIFO_EN		0x40
+
+#define REG_PWR_MGMT_1		0x6B
+#define BIT_H_RESET		0x80
+#define BIT_SLEEP		0x40
+#define BIT_LP_EN		0x20
+#define BIT_CLK_PLL		0x01
+#define BIT_CLK_MASK		0x07
+
+#define REG_PWR_MGMT_2		0x6C
+#define BIT_PWR_ACCEL_STBY	0x38
+#define BIT_PWR_GYRO_STBY	0x07
+#define BIT_PWR_ALL_OFF		0x3F
+#define BIT_FIFO_LP_EN		0x80
+
+#define REG_MEM_BANK_SEL	0x6D
+#define REG_MEM_START_ADDR	0x6E
+#define REG_MEM_R_W		0x6F
+
+#define REG_FIFO_COUNT_H	0x72
+#define REG_FIFO_R_W		0x74
+#define REG_WHO_AM_I		0x75
+
+#define REG_20680_XG_ST_DATA	0x00
+#define REG_20680_XA_ST_DATA	0xD
+#define REG_20680_XA_OFFS_H	0x77
+#define REG_20680_YA_OFFS_H	0x7A
+#define REG_20680_ZA_OFFS_H	0x7D
+#define REG_20680_ACCEL_CONFIG2	0x1D
+#define BIT_ACCEL_FCHOCIE_B	0x08
+#define BIT_FIFO_SIZE_1K	0x40
+
+#define REG_LP_MODE_CFG		0x1E
+
+#define REG_20680_LP_ACCEL_ODR	0x1E
+#define REG_20680_ACCEL_WOM_THR	0x1F
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET	0x4000
+#define GYRO_ACCURACY_SET	0x2000
+#define CPASS_ACCURACY_SET	0x1000
+
+/* data definitions */
+#define ACCEL_COVARIANCE	0
+#define BYTES_PER_SENSOR	6
+#define BYTES_FOR_TEMP		2
+#define FIFO_COUNT_BYTE		2
+#define HARDWARE_FIFO_SIZE	512
+#define FIFO_SIZE		(HARDWARE_FIFO_SIZE * 7 / 10)
+#define POWER_UP_TIME		100
+#define REG_UP_TIME_USEC	100
+#define LEFT_OVER_BYTES		128
+#define IIO_BUFFER_BYTES	8
+#define BASE_SAMPLE_RATE	1000
+#define DRY_RUN_TIME		50
+#define INV_IAM20680_GYRO_START_TIME	35
+#define INV_IAM20680_ACCEL_START_TIME	30
+#define MODE_1K_INIT_SAMPLE	5
+#define FIRST_SAMPLE_BUF_MS	30
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY	3
+#else
+#define DEFAULT_ACCURACY	1
+#endif
+
+/* temperature */
+#define TEMP_SENSITIVITY	32680   // 326.8 LSB/degC * 100
+#define TEMP_OFFSET		2500    // 25 degC * 100
+
+/* enum for sensor */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_filter_e {
+	INV_FILTER_256HZ_NOLPF2 = 0,
+	INV_FILTER_188HZ,
+	INV_FILTER_98HZ,
+	INV_FILTER_42HZ,
+	INV_FILTER_20HZ,
+	INV_FILTER_10HZ,
+	INV_FILTER_5HZ,
+	INV_FILTER_2100HZ_NOLPF,
+	NUM_FILTER
+};
+
+#define MPU_DEFAULT_DMP_FREQ	200
+#define PEDOMETER_FREQ		(MPU_DEFAULT_DMP_FREQ >> 2)
+#define SENSOR_FUSION_MIN_RATE	100
+#define GESTURE_ACCEL_RATE	50
+#define ESI_GYRO_RATE		1000
+#define MAX_FIFO_PACKET_READ	6
+#define MAX_BATCH_FIFO_SIZE	FIFO_SIZE
+
+#define MIN_MST_ODR_CONFIG	4
+#define MAX_MST_ODR_CONFIG	5
+/* initial rate is important. For non-DMP mode, it is set as 4 1000/256*/
+#define MPU_INIT_SENSOR_RATE	4
+#define MAX_MST_NON_COMPASS_ODR_CONFIG	7
+#define THREE_AXES		3
+#define NINE_ELEM		(THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT		16
+
+#define DMP_DIVIDER		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define DEFAULT_BATCH_RATE	400
+#define DEFAULT_BATCH_TIME	(MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+
+#define TEMPERATURE_SCALE	3340827L
+#define TEMPERATURE_OFFSET	1376256L
+#define SECONDARY_INIT_WAIT	100
+
+/* data limit definitions */
+#define MIN_FIFO_RATE		4
+#define MAX_FIFO_RATE		MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM		8192
+#define MAX_PRS_RATE		281
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+#endif
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c
new file mode 100644
index 000000000000..f65faadda793
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+
+	inv_plat_single_write(st, REG_CONFIG, 3);
+
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(0);
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+				   st->chip_config.fsr << SHIFT_GYRO_FS_SEL);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+				st->chip_config.accel_fs << SHIFT_ACCEL_FS);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = BYTE_MODE;
+#ifdef TIMER_BASED_BATCHING
+	st->batch_timeout = 0;
+	st->is_batch_timer_running = false;
+#endif
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c
new file mode 100644
index 000000000000..79492a0f7865
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_check_fsync(struct inv_mpu_state *st)
+{
+	u8 data[1];
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+	inv_plat_read(st, REG_FSYNC_INT, 1, data);
+	if (data[0] & BIT_FSYNC_INT) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	}
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i;
+	s32 raw[3];
+	s32 calib[3] = { 0, 0, 0 };
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st);
+		break;
+	case SENSOR_GYRO:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_gyro_data(indio_dev, raw, calib, t);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int inv_push_20680_data(struct iio_dev *indio_dev, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 *dptr;
+	int i;
+
+	dptr = d;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			inv_get_dmp_ts(st, i);
+			if (st->sensor[i].send && (!st->ts_algo.first_sample)) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(indio_dev, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_process_20680_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 data[14];
+	bool done_flag;
+	u8 v;
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	u8 reg;
+	int len;
+#endif
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		res = inv_plat_read(st, REG_INT_STATUS, 1, data);
+		if (res)
+			return res;
+		pr_debug("ges cnt=%d, statu=%x\n",
+						st->gesture_int_count, data[0]);
+		if (data[0] & (BIT_WOM_ALL_INT_EN)) {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN | BIT_DATA_RDY_EN);
+				if (res)
+					return res;
+				v = 0;
+				if (st->chip_config.gyro_enable)
+					v |= BITS_GYRO_FIFO_EN;
+
+				if (st->chip_config.accel_enable)
+					v |= BIT_ACCEL_FIFO_EN;
+				res = inv_plat_single_write(st, REG_FIFO_EN, v);
+				if (res)
+					return res;
+				/* First time wake up from WOM.
+				 * We don't need data in the FIFO
+				 */
+				res = inv_reset_fifo(st, true);
+				if (res)
+					return res;
+				res = inv_switch_power_in_lp(st, false);
+				st->gesture_int_count = WOM_DELAY_THRESHOLD;
+
+				return res;
+			}
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		} else {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_FIFO_EN, 0);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN);
+				inv_switch_power_in_lp(st, false);
+
+				return res;
+			}
+			st->gesture_int_count--;
+		}
+	}
+
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE / st->batch.pk_size)) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n",
+				fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	len = 0;
+	if (st->sensor[SENSOR_GYRO].on) {
+		reg = REG_RAW_GYRO;
+		len += BYTES_PER_SENSOR;
+		if (st->sensor[SENSOR_ACCEL].on && !st->sensor[SENSOR_TEMP].on)
+			len += BYTES_FOR_TEMP;
+	}
+	if (st->sensor[SENSOR_TEMP].on) {
+		reg = REG_RAW_TEMP;
+		len += BYTES_FOR_TEMP;
+	}
+	if (st->sensor[SENSOR_ACCEL].on) {
+		reg = REG_RAW_ACCEL;
+		len += BYTES_PER_SENSOR;
+	}
+
+	if (len == 0) {
+		pr_debug("No sensor is enabled\n");
+		return 0;
+	}
+
+	/* read data registers */
+	res = inv_plat_read(st, reg, len, data);
+	if (res < 0) {
+		pr_err("read data registers is failed\n");
+		return res;
+	}
+
+	/* copy sensor data to buffer as FIFO data format */
+	tmp = 0;
+	if (st->sensor[SENSOR_ACCEL].on) {
+		for (i = 0; i < BYTES_PER_SENSOR; i++)
+			dptr[i] = data[tmp + i];
+		dptr += BYTES_PER_SENSOR;
+		tmp += BYTES_PER_SENSOR;
+	}
+
+	if (st->sensor[SENSOR_TEMP].on) {
+		for (i = 0; i < BYTES_FOR_TEMP; i++)
+			dptr[i] = data[tmp + i];
+		dptr += BYTES_FOR_TEMP;
+		tmp += BYTES_FOR_TEMP;
+	}
+
+	if (st->sensor[SENSOR_GYRO].on) {
+		if (st->sensor[SENSOR_ACCEL].on && !st->sensor[SENSOR_TEMP].on)
+			tmp += BYTES_FOR_TEMP;
+		for (i = 0; i < BYTES_PER_SENSOR; i++)
+			dptr[i] = data[tmp + i];
+	}
+#else
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		pr_debug("inside: %x, %x, %x, %x, %x, %x, %x, %x\n",
+				dptr[0], dptr[1], dptr[2], dptr[3],
+				dptr[4], dptr[5], dptr[6], dptr[7]);
+		pr_debug("insid2: %x, %x, %x, %x, %x, %x, %x, %x\n",
+				dptr[8], dptr[9], dptr[10], dptr[11],
+				dptr[12], dptr[13], dptr[14], dptr[15]);
+
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+#endif /* SENSOR_DATA_FROM_REGISTERS */
+	dptr = d;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n",
+			d[0], d[1], d[2], d[3],
+			d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n",
+			d[8], d[9], d[10], d[11],
+			d[12], d[13], d[14], d[15]);
+	total_bytes = fifo_count;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->sensor[i].count =  total_bytes / pk_size;
+	}
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		pr_debug("total%d, pk=%d\n", total_bytes, pk_size);
+		if (total_bytes >= pk_size) {
+			res = inv_push_20680_data(indio_dev, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  _inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+static void _inv_read_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		return;
+	mutex_lock(&st->lock);
+#ifdef TIMER_BASED_BATCHING
+	if (st->batch_timeout) {
+		if (inv_plat_single_write(st, REG_INT_ENABLE, st->int_en))
+			pr_err("REG_INT_ENABLE write error\n");
+	}
+#endif
+	st->wake_sensor_received = false;
+	result = inv_process_20680_data(indio_dev);
+	if (result)
+		goto err_reset_fifo;
+	mutex_unlock(&st->lock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	return;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_switch_power_in_lp(st, false);
+		mutex_unlock(&st->lock);
+
+		return;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_switch_power_in_lp(st, true);
+	inv_reset_fifo(st, true);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+}
+
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+
+	_inv_read_fifo(indio_dev);
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef TIMER_BASED_BATCHING
+void inv_batch_work(struct work_struct *work)
+{
+	struct inv_mpu_state *st =
+		container_of(work, struct inv_mpu_state, batch_work);
+
+	mutex_lock(&st->lock);
+	if (inv_plat_single_write(st, REG_INT_ENABLE, st->int_en | BIT_DATA_RDY_EN))
+		pr_err("REG_INT_ENABLE write error\n");
+	mutex_unlock(&st->lock);
+}
+#endif
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		st->wake_sensor_received = false;
+		inv_process_20680_data(indio_dev);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+		inv_switch_power_in_lp(st, false);
+	}
+#endif /* SENSOR_DATA_FROM_REGISTERS */
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c
new file mode 100644
index 000000000000..2262efde65c7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c
@@ -0,0 +1,755 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* register settings */
+#define DEF_SELFTEST_GYRO_SENS		(32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS			20
+#define SELFTEST_WAIT_TIME		(MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME		20
+#define DEF_GYRO_SCALE			131
+#define DEF_ST_PRECISION		1000
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ST_SCALE			32768
+#define DEF_ST_TRY_TIMES		2
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define DEF_ST_SAMPLES			200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN	500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX	1500
+#define DEF_GYRO_CT_SHIFT_DELTA		500
+
+#define SENSOR_UP_TIME			30
+#define REG_UP_TIME			2
+
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ACCEL_ST_SHIFT_DELTA	500
+#define ACCEL_ST_AL_MIN ((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX ((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+#define THREE_AXIS			3
+#define DEF_ST_IAM20680_ACCEL_LPF	2
+#define DEF_SELFTEST_SAMPLE_RATE	0  /* 1000Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_LP	3  /*  250Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_ACC_LP	10 /*  250Hz LPOSC_CLKSEL */
+#define SAMPLE_RATE_CHANGE_STABLE	50
+#define DEF_SELFTEST_20680_ACCEL_FS	(0 << 3)
+#define DEF_SELFTEST_GYRO_FS		(0 << 3)
+#define DEF_ST_20680_STABLE_TIME	20
+#define BIT_ACCEL_OUT			0x08
+#define BITS_GYRO_OUT			0x70
+#define THREE_AXIS			3
+#define DEF_GYRO_WAIT_TIME		10
+#define DEF_GYRO_WAIT_TIME_LP		50
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX		20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL			60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN		225
+#define DEF_ACCEL_ST_AL_MAX		675
+
+struct recover_regs {
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 config;		/* REG_CONFIG */
+	u8 gyro_config;		/* REG_GYRO_CONFIG */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+	u8 smplrt_div;		/* REG_SAMPLE_RATE_DIV */
+	u8 lp_mode;		/* REG_LP_MODE_CTRL */
+	u8 pwr_mgmt_1;		/* REG_PWR_MGMT_1 */
+	u8 pwr_mgmt_2;		/* REG_PWR_MGMT_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_INT_ENABLE      : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_FIFO_EN         : 0x%02X\n", saved_regs.fifo_en);
+	pr_debug(" REG_USER_CTRL       : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_CONFIG          : 0x%02X\n", saved_regs.config);
+	pr_debug(" REG_GYRO_CONFIG     : 0x%02X\n", saved_regs.gyro_config);
+	pr_debug(" REG_ACCEL_CONFIG    : 0x%02X\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2  : 0x%02X\n", saved_regs.accel_config_2);
+	pr_debug(" REG_SAMPLE_RATE_DIV : 0x%02X\n", saved_regs.smplrt_div);
+	pr_debug(" REG_LP_MODE_CTRL    : 0x%02X\n", saved_regs.lp_mode);
+	pr_debug(" REG_PWR_MGMT_1      : 0x%02X\n", saved_regs.pwr_mgmt_1);
+	pr_debug(" REG_PWR_MGMT_2      : 0x%02X\n", saved_regs.pwr_mgmt_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_read(st, REG_PWR_MGMT_1, 1,
+			&saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	/* wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			(saved_regs.pwr_mgmt_1 & ~BIT_SLEEP));
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_INT_ENABLE, 1,
+			&saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1,
+			&saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1,
+			&saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1,
+			&saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG, 1,
+			&saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SAMPLE_RATE_DIV, 1,
+			&saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_MODE_CTRL, 1,
+			&saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1,
+			&saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN,
+			saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_CONFIG,
+			saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+			saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+			saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+			saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_switch_engine(struct inv_mpu_state *st, bool en, u32 mask)
+{
+	u8 data, mgmt_1;
+	int result;
+
+	if (mask == BIT_PWR_GYRO_STBY) {
+		result = inv_plat_read(st, REG_PWR_MGMT_1, 1, &mgmt_1);
+		if (result)
+			return result;
+		mgmt_1 &= ~BIT_CLK_MASK;
+	}
+
+	if ((mask == BIT_PWR_GYRO_STBY) && (!en)) {
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1, &data);
+	if (result)
+		return result;
+	if (en)
+		data &= (~mask);
+	else
+		data |= mask;
+	data |= BIT_FIFO_LP_EN;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2, data);
+	if (result)
+		return result;
+
+	if ((mask == BIT_PWR_GYRO_STBY) && en) {
+		/* only gyro on needs sensor up time */
+		msleep(SENSOR_UP_TIME);
+		/* after gyro is on & stable, switch internal clock to PLL */
+		mgmt_1 |= BIT_CLK_PLL;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+	if ((mask == BIT_PWR_ACCEL_STBY) && en)
+		msleep(REG_UP_TIME);
+
+	return 0;
+}
+
+int inv_set_offset_reg(struct inv_mpu_state *st, int reg, int val)
+{
+	int result;
+	u8 d;
+
+	d = ((val >> 8) & 0xff);
+	result = inv_plat_single_write(st, reg, d);
+	if (result)
+		return result;
+
+	d = (val & 0xff);
+	result = inv_plat_single_write(st, reg + 1, d);
+
+	return result;
+}
+
+/**
+ * inv_check_gyro_self_test() - check gyro self test. this function
+ *                                   returns zero as success. A non-zero return
+ *                                   value indicates failure in self test.
+ *  @*st: main data structure.
+ *  @*reg_avg: average value of normal test.
+ *  @*st_avg:  average value of self test
+ */
+int inv_check_gyro_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	u8 regs[3];
+	int ret_val, result;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_20680_XG_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test gyro shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA *
+					st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			/* Self Test Pass/Fail Criteria B */
+			if (st_shift_cust[i] < DEF_GYRO_ST_AL *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	if (ret_val == 0) {
+		/* Self Test Pass/Fail Criteria C */
+		for (i = 0; i < 3; i++)
+			if (abs(reg_avg[i]) > DEF_GYRO_OFFSET_MAX *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/**
+ * inv_check_accel_self_test() - check 20680 accel self test. this function
+ *                                   returns zero as success. A non-zero return
+ *                                   value indicates failure in self test.
+ *  @*st: main data structure.
+ *  @*reg_avg: average value of normal test.
+ *  @*st_avg:  average value of self test
+ */
+int inv_check_accel_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	int ret_val, result;
+	int st_shift_prod[3], st_shift_cust[3], st_shift_ratio[3], i;
+	u8 regs[3];
+	int otp_value_zero = 0;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_20680_XA_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test accel shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			st_shift_ratio[i] = abs(st_shift_cust[i] /
+					st_shift_prod[i] - DEF_ST_PRECISION);
+			if (st_shift_ratio[i] > DEF_ACCEL_ST_SHIFT_DELTA)
+				ret_val = 1;
+		}
+	} else {
+		/* Self Test Pass/Fail Criteria B */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = abs(st_avg[i] - reg_avg[i]);
+			if (st_shift_cust[i] < ACCEL_ST_AL_MIN ||
+					st_shift_cust[i] > ACCEL_ST_AL_MAX)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+int inv_do_test(struct inv_mpu_state *st, int self_test_flag,
+		int *gyro_result, int *accel_result, int lp_mode)
+{
+	int result, i, j, packet_size;
+	u8 data[BYTES_PER_SENSOR * 2], d, dd;
+	int fifo_count, packet_count, ind, s;
+
+	packet_size = BYTES_PER_SENSOR * 2;
+
+	/* disable interrupt */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+	/* disable the sensor output to FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (result)
+		return result;
+	/* disable fifo reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+	if (result)
+		return result;
+	/* clear FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (result)
+		return result;
+	/* setup parameters */
+	result = inv_plat_single_write(st, REG_CONFIG, INV_FILTER_98HZ);
+	if (result)
+		return result;
+
+	/* gyro lp mode */
+	if (lp_mode == 1)
+		d = BIT_GYRO_CYCLE_EN;
+	else if (lp_mode == 2)
+		d = DEF_SELFTEST_SAMPLE_RATE_ACC_LP;
+	else
+		d = 0;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, d);
+	if (result)
+		return result;
+
+	/* config accel LPF register */
+	if (lp_mode == 2)
+		d = BIT_ACCEL_FCHOCIE_B;
+	else
+		d = DEF_ST_IAM20680_ACCEL_LPF;
+	result = inv_plat_single_write(st, REG_20680_ACCEL_CONFIG2, d);
+	if (result)
+		return result;
+
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE_LP);
+	} else {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE);
+	}
+	if (result)
+		return result;
+	/* wait for the sampling rate change to stabilize */
+	mdelay(SAMPLE_RATE_CHANGE_STABLE);
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+		self_test_flag | DEF_SELFTEST_GYRO_FS);
+	if (result)
+		return result;
+
+	d = DEF_SELFTEST_20680_ACCEL_FS;
+	d |= self_test_flag;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, d);
+	if (result)
+		return result;
+
+	/* wait for the output to get stable */
+	msleep(DEF_ST_20680_STABLE_TIME);
+
+	/* enable FIFO reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+	if (result)
+		return result;
+	/* enable sensor output to FIFO */
+	d = BITS_GYRO_OUT | BIT_ACCEL_OUT;
+	for (i = 0; i < THREE_AXIS; i++) {
+		gyro_result[i] = 0;
+		accel_result[i] = 0;
+	}
+	s = 0;
+	while (s < 200 /*st->self_test.samples*/) {
+		/* Stop FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+		if (result)
+			return result;
+		/* clear FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+		if (result)
+			return result;
+		/* enable FIFO reading */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+		if (result)
+			return result;
+
+		/* accel lp mode */
+		dd = BIT_CLK_PLL;
+		if (lp_mode == 2)
+			dd |= BIT_LP_EN;
+		else
+			dd &= ~BIT_LP_EN;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, dd);
+		if (result)
+			return result;
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, d);
+		if (result)
+			return result;
+		if (lp_mode)
+			mdelay(DEF_GYRO_WAIT_TIME_LP);
+		else
+			mdelay(DEF_GYRO_WAIT_TIME);
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+		if (result)
+			return result;
+
+		result = inv_plat_read(st, REG_FIFO_COUNT_H,
+					FIFO_COUNT_BYTE, data);
+		if (result)
+			return result;
+		fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+		pr_debug("%s self_test fifo_count - %d\n",
+			 st->hw->name, fifo_count);
+		packet_count = fifo_count / packet_size;
+		i = 0;
+		while ((i < packet_count) && (s < 200)) {
+			short vals[3];
+
+			result = inv_plat_read(st, REG_FIFO_R_W,
+				packet_size, data);
+			if (result)
+				return result;
+			ind = 0;
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				accel_result[j] += vals[j];
+			}
+			ind += BYTES_PER_SENSOR;
+			pr_debug(
+				"%s self_test accel data - %d %+d %+d %+d\n",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				gyro_result[j] += vals[j];
+			}
+			pr_debug("%s self_test gyro data - %d %+d %+d %+d\n",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			s++;
+			i++;
+		}
+	}
+
+	for (j = 0; j < THREE_AXIS; j++) {
+		accel_result[j] = accel_result[j] / s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+	for (j = 0; j < THREE_AXIS; j++) {
+		gyro_result[j] = gyro_result[j] / s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	return 0;
+}
+
+
+int inv_power_up_self_test(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+
+	/* make sure no interrupts */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_ACCEL_STBY);
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXIS], gyro_bias_regular[THREE_AXIS];
+	int accel_bias_st[THREE_AXIS], accel_bias_regular[THREE_AXIS];
+#if 0
+	int gyro_bias_regular_lp[THREE_AXIS];
+	int accel_bias_regular_lp[THREE_AXIS];
+	int dummy_bias_regular[THREE_AXIS];
+#endif
+	int test_times, i;
+	char accel_result, gyro_result;
+
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	result = inv_power_up_self_test(st);
+	if (result)
+		return result;
+	accel_result = 0;
+	gyro_result = 0;
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular,
+			accel_bias_regular, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("%s self_test gyro bias_regular - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular[0], gyro_bias_regular[1],
+		gyro_bias_regular[2]);
+
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, BITS_SELF_TEST_EN, gyro_bias_st,
+					accel_bias_st, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_st - %+d %+d %+d\n",
+		st->hw->name, accel_bias_st[0], accel_bias_st[1],
+		accel_bias_st[2]);
+	pr_debug("%s self_test gyro bias_st - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_st[0], gyro_bias_st[1],
+		gyro_bias_st[2]);
+
+#if 0
+	/* lp gyro mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			dummy_bias_regular, 1);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test gyro bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, gyro_bias_regular_lp[0], gyro_bias_regular_lp[1],
+		 gyro_bias_regular_lp[2]);
+
+	/* lp accel mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, dummy_bias_regular,
+			accel_bias_regular_lp, 2);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, accel_bias_regular_lp[0],
+		 accel_bias_regular_lp[1], accel_bias_regular_lp[2]);
+#endif
+
+	/* copy bias */
+	for (i = 0; i < 3; i++) {
+		/* gyro : LN bias as LN is default mode */
+		st->gyro_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+		/* accel : LN bias as LN is default mode */
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	/* Check is done on continuous mode data */
+	accel_result = !inv_check_accel_self_test(st,
+		accel_bias_regular, accel_bias_st);
+	gyro_result = !inv_check_gyro_self_test(st,
+		gyro_bias_regular, gyro_bias_st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c
new file mode 100644
index 000000000000..d6d030cc7294
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+/* set LN mode for gyro regardless of conditions */
+#define USE_GYRO_LN_MODE
+
+static int inv_calc_engine_dur(struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 int_en, fifo_en, mode, user;
+	int r;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (r)
+		return r;
+	fifo_en = 0;
+	int_en = 0;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		int_en |= BIT_WOM_ALL_INT_EN;
+	}
+#ifdef TIMER_BASED_BATCHING
+	if (st->chip_config.eis_enable)
+		int_en |= BIT_FSYNC_INT_EN;
+	if (!st->batch_timeout)
+		int_en |= BIT_DATA_RDY_EN;
+#else
+	if (st->batch.timeout) {
+		if (!st->batch.fifo_wm_th)
+			int_en = BIT_DATA_RDY_EN;
+	} else {
+		int_en = BIT_DATA_RDY_EN;
+		if (st->chip_config.eis_enable)
+			int_en |= BIT_FSYNC_INT_EN;
+	}
+#endif
+	if (st->sensor[SENSOR_GYRO].on)
+		fifo_en |= BITS_GYRO_FIFO_EN;
+
+	if (st->sensor[SENSOR_ACCEL].on)
+		fifo_en |= BIT_ACCEL_FIFO_EN;
+	r = inv_plat_single_write(st, REG_FIFO_EN, fifo_en);
+	if (r)
+		return r;
+	st->int_en = int_en;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, int_en);
+	if (r)
+		return r;
+	if (st->gesture_only_on && (!st->batch.timeout))
+		mode = BIT_ACCEL_INTEL_EN | BIT_ACCEL_INTEL_MODE;
+	else
+		mode = 0;
+	r = inv_plat_single_write(st, REG_ACCEL_INTEL_CTRL, mode);
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	user = 0;
+#else
+	user = BIT_FIFO_EN;
+#endif
+	r = inv_plat_single_write(st, REG_USER_CTRL, user | st->i2c_dis);
+#ifdef TIMER_BASED_BATCHING
+	if (fifo_en && st->batch_timeout) {
+		if (st->is_batch_timer_running)
+			hrtimer_cancel(&st->hr_batch_timer);
+		st->is_batch_timer_running = true;
+		hrtimer_start(&st->hr_batch_timer,
+			ns_to_ktime(st->batch_timeout), HRTIMER_MODE_REL);
+	} else {
+		if (st->is_batch_timer_running)
+			hrtimer_cancel(&st->hr_batch_timer);
+		st->is_batch_timer_running = false;
+	}
+#endif
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int dur_ms;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+	if (st->mode_1k_on)
+		ts_algo->first_sample = MODE_1K_INIT_SAMPLE;
+	else
+		ts_algo->first_sample = 1;
+
+	dur_ms = st->smplrt_div + 1;
+	if ((ts_algo->first_sample * dur_ms) < FIRST_SAMPLE_BUF_MS)
+		ts_algo->first_sample = FIRST_SAMPLE_BUF_MS / dur_ms;
+	if (ts_algo->first_sample == 0)
+		ts_algo->first_sample = 1;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int r;
+	unsigned int wait_ms;
+
+	if (st->chip_config.gyro_enable | st->chip_config.accel_enable) {
+		w = 0;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else if (st->chip_config.compass_enable) {
+		w = BIT_PWR_GYRO_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY);
+	}
+
+	r = inv_plat_read(st, REG_PWR_MGMT_2, 1, &v);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	if (r)
+		return r;
+
+	wait_ms = 0;
+	if (st->chip_config.gyro_enable
+		&& (v & BIT_PWR_GYRO_STBY)) {
+		wait_ms = INV_IAM20680_GYRO_START_TIME;
+	}
+	if (st->chip_config.accel_enable
+		&& (v & BIT_PWR_ACCEL_STBY)) {
+		if (wait_ms < INV_IAM20680_ACCEL_START_TIME)
+			wait_ms = INV_IAM20680_ACCEL_START_TIME;
+	}
+	if (wait_ms)
+		msleep(wait_ms);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->ts_algo.clock_base].dur;
+			st->sensor[i].div = 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st, int rate)
+{
+	const short hz[] = {188, 98, 42, 20, 10, 5};
+	const int   d[] = {INV_FILTER_188HZ, INV_FILTER_98HZ,
+			INV_FILTER_42HZ, INV_FILTER_20HZ,
+			INV_FILTER_10HZ, INV_FILTER_5HZ};
+	int i, h, data, result;
+
+#ifdef USE_GYRO_LN_MODE
+	if (1) {
+#else
+	if (st->chip_config.eis_enable || st->ois.en || st->mode_1k_on) {
+#endif
+		h = (rate >> 1);
+		i = 0;
+		while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+			i++;
+		data = d[i];
+		data |= EXT_SYNC_SET;
+		result = inv_plat_single_write(st, REG_CONFIG, data);
+		if (result)
+			return result;
+
+		st->chip_config.lpf = data;
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL, 0);
+		st->gyro_lp_mode = 0;
+	} else {
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+							BIT_GYRO_CYCLE_EN);
+		if (result)
+			return result;
+		data = 0;
+		result = inv_plat_single_write(st, REG_CONFIG, data | 3);
+		st->gyro_lp_mode = 1;
+	}
+
+	return result;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result, div;
+
+	if (st->chip_config.gyro_enable)
+		div = g_d;
+	else
+		div = a_d;
+	if (st->chip_config.eis_enable)
+		div = 0;
+
+	st->smplrt_div = div;
+	pr_debug("div= %d\n", div);
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV, div);
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+#ifdef TIMER_BASED_BATCHING
+	u64 timeout;
+	int required_fifo_size;
+
+	if (st->batch.timeout) {
+		required_fifo_size = st->batch.timeout * st->eng_info[ENGINE_GYRO].running_rate
+					* st->batch.pk_size / 1000;
+		if (required_fifo_size > MAX_BATCH_FIFO_SIZE) {
+			required_fifo_size = MAX_BATCH_FIFO_SIZE;
+			timeout = (required_fifo_size / st->batch.pk_size) * (1000 / st->eng_info[ENGINE_GYRO].running_rate);
+		} else {
+			timeout = st->batch.timeout;
+		}
+	} else {
+		timeout = 1000 / st->eng_info[ENGINE_GYRO].running_rate;
+	}
+	if (timeout <= 1000 / st->eng_info[ENGINE_GYRO].running_rate)
+		st->batch_timeout = 0;
+	else
+		st->batch_timeout = timeout * 1000000; // ms to ns
+#endif
+	st->batch.fifo_wm_th = 0;
+
+	return 0;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result, i;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st, st->eng_info[ENGINE_GYRO].running_rate);
+	if (result)
+		return result;
+	// set ADLPF at this point not to change after accel is enabled
+	result = inv_set_accel_config2(st, false);
+	st->batch.pk_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->batch.pk_size +=  st->sensor[i].sample_size;
+	}
+
+	inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	gyro_rate = MPU_INIT_SENSOR_RATE;
+	accel_rate = MPU_INIT_SENSOR_RATE;
+	/* loop the streaming sensors to see which engine needs to be turned on */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		accel_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	if ((gyro_rate >= BASE_SAMPLE_RATE) ||
+					(accel_rate >= BASE_SAMPLE_RATE))
+		st->mode_1k_on = true;
+	else
+		st->mode_1k_on = false;
+	/* engine divider for pressure and compass is set later */
+	if (st->chip_config.eis_enable || st->mode_1k_on) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		// need to update rate and div for 1khz mode
+		for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+						BASE_SAMPLE_RATE
+						/ st->sensor_l[i].rate;
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider = BASE_SAMPLE_RATE /
+			st->eng_info[ENGINE_GYRO].running_rate;
+		st->eng_info[ENGINE_ACCEL].divider = BASE_SAMPLE_RATE /
+			st->eng_info[ENGINE_ACCEL].running_rate;
+	}
+
+	for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(&st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_interrupt(st);
+	inv_determine_engine(st);
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable)) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_stop_interrupt(st);
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_restore_interrupt(st);
+}
+
+/* dummy function for 20608D */
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	return 0;
+}
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	return 0;
+}
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_core_20602.c b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_core_20602.c
new file mode 100644
index 000000000000..d7037a5248f7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_core_20602.c
@@ -0,0 +1,1116 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM20602] = {128, "icm20602"},
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static char debug_reg_addr = 0x6;
+#endif
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	result = inv_plat_read(st, addr, 2, d);
+	if (result)
+		goto accel_bias_set_err;
+	accel_reg_bias = ((int)d[0] << 8) | d[1];
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0 */
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	}
+	return count;
+}
+#endif
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.stationary_detect_enable)
+			return count;
+		st->chip_config.stationary_detect_enable = !!data;
+		pr_info("Stationary Detect %s\n",
+			st->chip_config.stationary_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.motion_detect_enable)
+			return count;
+		st->chip_config.motion_detect_enable = !!data;
+		pr_info("Motion Detect %s\n",
+			st->chip_config.motion_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0, sizeof(struct spi_transfer));
+
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store()
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show()
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.accel_enable);
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.stationary_detect_enable);
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.motion_detect_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_wake_l_on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[2]);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+#endif
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+#endif
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+#endif
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(event_stationary_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STATIONARY_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_motion_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_MOTION_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+#endif
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&dev_attr_out_temperature.attr,
+#endif
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_pedometer_attributes[] = {
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_event_stationary_detect_enable.dev_attr.attr,
+	&iio_dev_attr_event_motion_detect_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+#endif
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_debug_attributes) +
+#endif
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_pedometer_attributes) +
+#endif
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm20602"))
+		st->chip_type = ICM20602;
+	else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+#endif
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	// dummy
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_iio_reg_20602.h b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_iio_reg_20602.h
new file mode 100644
index 000000000000..f587a0d04b59
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_iio_reg_20602.h
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_20602_H_
+#define _INV_MPU_IIO_REG_20602_H_
+
+/* not support gestures, eis, etc. */
+//#define SUPPORT_ONLY_BASIC_FEATURES
+
+/*register and associated bit definition*/
+#define REG_XA_OFFS_H		0x77
+#define REG_YA_OFFS_H		0x7A
+#define REG_ZA_OFFS_H           0x7D
+#define REG_XA_OFFS_L_TC        0x7
+#define REG_PRODUCT_ID          0xC
+#define REG_ST_GCT_X            0xD
+#define REG_XG_OFFS_USR_H        0x13
+#define REG_YG_OFFS_USR_H        0x15
+#define REG_ZG_OFFS_USR_H        0x17
+#define REG_SAMPLE_RATE_DIV     0x19
+
+#define REG_CONFIG              0x1A
+#define EXT_SYNC_SET                      8
+#define BIT_FIFO_COUNT_REC                0x80
+
+#define REG_GYRO_CONFIG		0x1B
+#define BITS_SELF_TEST_EN		0xE0
+#define SHIFT_GYRO_FS_SEL		0x03
+
+#define REG_ACCEL_CONFIG	0x1C
+#define SHIFT_ACCEL_FS			0x03
+
+#define REG_LP_MODE_CTRL	0x1E
+#define BIT_GYRO_CYCLE_EN               0x80
+
+#define REG_ACCEL_WOM_THR	0x1F
+#define REG_ACCEL_WOM_X_THR	0x20
+#define REG_ACCEL_WOM_Y_THR	0x21
+#define REG_ACCEL_WOM_Z_THR	0x22
+
+#define REG_ACCEL_MOT_THR       0x1F
+#define REG_ACCEL_MOT_DUR       0x20
+
+#define REG_ACCEL_CONFIG_2  0x1D
+#define BIT_ACCEL_FCHOCIE_B              0x08
+
+#define REG_FIFO_EN			0x23
+#define BITS_GYRO_FIFO_EN	0x10
+#define BIT_ACCEL_FIFO_EN	0x08
+
+#define REG_FSYNC_INT		0x36
+#define BIT_FSYNC_INT                   0x80
+
+#define REG_INT_PIN_CFG		0x37
+
+#define REG_INT_ENABLE		0x38
+#define BIT_WOM_X_INT_EN		0x80
+#define BIT_WOM_Y_INT_EN		0x40
+#define BIT_WOM_Z_INT_EN		0x20
+#define BIT_WOM_ALL_INT_EN		0xE0
+#define BIT_FSYNC_INT_EN		0x8
+#define BIT_DATA_RDY_EN		        0x1
+
+#define REG_WM_INT_STATUS       0x39
+
+#define REG_INT_STATUS          0x3A
+#define BIT_WOM_X_INT                  0x80
+#define BIT_WOM_Y_INT                  0x40
+#define BIT_WOM_Z_INT                  0x20
+
+#define REG_RAW_ACCEL           0x3B
+#define REG_EXT_SENS_DATA_00    0x49
+#define REG_EXT_SENS_DATA_08    0x51
+#define REG_EXT_SENS_DATA_09    0x52
+
+#define REG_FIFO_WM_TH1         0x60
+#define REG_FIFO_WM_TH2         0x61
+
+#define REG_INT2_STATUS         0x62
+
+#define REG_ACCEL_INTEL_CTRL 0x69
+#define BIT_ACCEL_INTEL_EN              0x80
+#define BIT_ACCEL_INTEL_MODE            0x40
+
+#define REG_USER_CTRL			0x6A
+#define BIT_COND_RST				0x01
+#define BIT_FIFO_RST				0x04
+#define BIT_FIFO_EN				0x40
+
+#define REG_PWR_MGMT_1			0x6B
+#define BIT_H_RESET				0x80
+#define BIT_SLEEP					0x40
+#define BIT_LP_EN                       	0x20
+#define BIT_CLK_PLL				0x01
+#define BIT_CLK_MASK				0x07
+
+#define REG_PWR_MGMT_2			0x6C
+#define BIT_PWR_ACCEL_STBY		0x38
+#define BIT_PWR_GYRO_STBY		0x07
+#define BIT_PWR_ALL_OFF			0x3F
+
+#define REG_MEM_BANK_SEL	0x6D
+#define REG_MEM_START_ADDR	0x6E
+#define REG_MEM_R_W		0x6F
+
+#define REG_SW_ID2 		0x70
+#define BIT_ACC_DEFAULT                   (2 << 4)
+
+#define REG_FIFO_COUNT_H        0x72
+#define REG_FIFO_R_W            0x74
+#define REG_WHO_AM_I              0x75
+
+#define REG_6500_XG_ST_DATA     0x50
+#define REG_6500_XA_ST_DATA     0xD
+#define REG_6500_XA_OFFS_H      0x77
+#define REG_6500_YA_OFFS_H      0x7A
+#define REG_6500_ZA_OFFS_H      0x7D
+#define REG_6500_ACCEL_CONFIG2  0x1D
+#define BIT_ACCEL_FCHOCIE_B              0x08
+#define BIT_FIFO_SIZE_1K                 0x40
+
+#define REG_LP_MODE_CFG		0x1E
+
+#define REG_6500_LP_ACCEL_ODR   0x1E
+#define REG_6500_ACCEL_WOM_THR  0x1F
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET  0x4000
+#define GYRO_ACCURACY_SET   0x2000
+#define CPASS_ACCURACY_SET  0x1000
+
+/* data definitions */
+#define ACCEL_COVARIANCE 0
+#define BYTES_PER_SENSOR         6
+#define BYTES_FOR_TEMP           2
+#define FIFO_COUNT_BYTE          2
+#define HARDWARE_FIFO_SIZE       1008
+#define FIFO_SIZE                (HARDWARE_FIFO_SIZE * 7 / 8)
+#define POWER_UP_TIME            100
+#define REG_UP_TIME_USEC         100
+#define LEFT_OVER_BYTES          128
+#define IIO_BUFFER_BYTES         8
+#define BASE_SAMPLE_RATE         1000
+#define DRY_RUN_TIME             50
+#define INV_ICM20602_GYRO_START_TIME    80
+#define INV_ICM20602_ACCEL_START_TIME   10
+#define MODE_1K_INIT_SAMPLE      5
+#define MODE_VR_INIT_SAMPLE      5
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY         3
+#else
+#define DEFAULT_ACCURACY         1
+#endif
+
+/* enum for sensor */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_filter_e {
+	INV_FILTER_256HZ_NOLPF2 = 0,
+	INV_FILTER_188HZ,
+	INV_FILTER_98HZ,
+	INV_FILTER_42HZ,
+	INV_FILTER_20HZ,
+	INV_FILTER_10HZ,
+	INV_FILTER_5HZ,
+	INV_FILTER_2100HZ_NOLPF,
+	NUM_FILTER
+};
+
+enum inv_avg_filter_e {
+	BIT_AVG_FILTER_500HZ = 0x00,    // 1x
+	BIT_AVG_FILTER_200HZ = 0x20,    // 4x
+	BIT_AVG_FILTER_100HZ = 0x40,    // 16x
+	BIT_AVG_FILTER_50HZ = 0x50,     // 32x
+	BIT_AVG_FILTER_30HZ = 0x60      // 64x
+};
+
+#define MPU_DEFAULT_DMP_FREQ     200
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 2)
+#define SENSOR_FUSION_MIN_RATE   100
+#define GESTURE_ACCEL_RATE       50
+#define ESI_GYRO_RATE            1000
+#define MODE_VR_RATE             500
+#define MAX_FIFO_PACKET_READ     6
+#define MAX_BATCH_FIFO_SIZE      FIFO_SIZE
+
+#define MIN_MST_ODR_CONFIG       4
+#define MAX_MST_ODR_CONFIG       5
+/* initial rate is important. For non-DMP mode, it is set as 4 1000/256*/
+#define MPU_INIT_SENSOR_RATE     4
+#define MAX_MST_NON_COMPASS_ODR_CONFIG 7
+#define THREE_AXES               3
+#define NINE_ELEM                (THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT           16
+
+#define DMP_DIVIDER              (BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define DEFAULT_BATCH_RATE       400
+#define DEFAULT_BATCH_TIME    (MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+
+#define TEMPERATURE_SCALE  3340827L
+#define TEMPERATURE_OFFSET 1376256L
+#define SECONDARY_INIT_WAIT 100
+
+/* data limit definitions */
+#define MIN_FIFO_RATE            4
+#define MAX_FIFO_RATE            MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM              8192
+#define MAX_PRS_RATE             281
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+#endif
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_init_20602.c b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_init_20602.c
new file mode 100644
index 000000000000..1d26c9b55945
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_init_20602.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+
+	inv_plat_single_write(st, REG_CONFIG, 3);
+
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_vr = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_vr = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_vr = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(0);
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+				   st->chip_config.fsr << SHIFT_GYRO_FS_SEL);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+				st->chip_config.accel_fs << SHIFT_ACCEL_FS);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	int result = 0;
+	u8 w;
+
+#define ACCEL_WOM_THR		15
+
+	w = ACCEL_WOM_THR;
+	result = inv_plat_single_write(st, REG_ACCEL_WOM_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_X_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Y_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Z_THR, w);
+
+	return result;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = RECORD_MODE;
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC);
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_plat_read(st, REG_SW_ID2, 1, &v);
+	if (result)
+		return result;
+	v |= BIT_ACC_DEFAULT;
+	result = inv_plat_single_write(st, REG_SW_ID2, v);
+	if (result)
+		return result;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_parsing_20602.c b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_parsing_20602.c
new file mode 100644
index 000000000000..7ae371806f7d
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_parsing_20602.c
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_check_fsync(struct inv_mpu_state *st)
+{
+	u8 data[1];
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+	inv_plat_read(st, REG_FSYNC_INT, 1, data);
+	if (data[0] & BIT_FSYNC_INT) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	}
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i;
+	s32 raw[3];
+	s32 calib[3] = { 0, 0, 0 };
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st);
+		break;
+	case SENSOR_GYRO:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_gyro_data(indio_dev, raw, calib, t);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int inv_push_20602_data(struct iio_dev *indio_dev, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 *dptr;
+	int i;
+
+	dptr = d;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			inv_get_dmp_ts(st, i);
+			if (st->sensor[i].send && (!st->ts_algo.first_sample)) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(indio_dev, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_process_20602_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 data[2];
+	bool done_flag;
+	u8 v;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		res = inv_plat_read(st, REG_INT_STATUS, 1, data);
+		if (res)
+			return res;
+		pr_debug("ges cnt=%d, statu=%x\n",
+						st->gesture_int_count, data[0]);
+		if (data[0] & (BIT_WOM_ALL_INT_EN)) {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN | BIT_DATA_RDY_EN);
+				if (res)
+					return res;
+				v = 0;
+				if (st->chip_config.gyro_enable)
+					v |= BITS_GYRO_FIFO_EN;
+
+				if (st->chip_config.accel_enable)
+					v |= BIT_ACCEL_FIFO_EN;
+				res = inv_plat_single_write(st, REG_FIFO_EN, v);
+				if (res)
+					return res;
+				/* First time wake up from WOM.
+					We don't need data in the FIFO */
+				res = inv_reset_fifo(st, true);
+				if (res)
+					return res;
+				res = inv_switch_power_in_lp(st, false);
+				if (st->chip_config.stationary_detect_enable)
+					st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+				else
+					st->gesture_int_count = WOM_DELAY_THRESHOLD;
+
+				return res;
+			}
+			if (st->chip_config.stationary_detect_enable)
+				st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+			else
+				st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		} else {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_FIFO_EN, 0);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN);
+				inv_switch_power_in_lp(st, false);
+
+				return res;
+			}
+			st->gesture_int_count--;
+		}
+	}
+
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE / st->batch.pk_size)) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n", fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		pr_debug("inside: %x, %x, %x, %x, %x, %x, %x, %x\n", dptr[0], dptr[1], dptr[2],
+						dptr[3], dptr[4], dptr[5], dptr[6], dptr[7]);
+		pr_debug("insid2: %x, %x, %x, %x, %x, %x, %x, %x\n", dptr[8], dptr[9], dptr[10],
+						dptr[11], dptr[12], dptr[13], dptr[14], dptr[15]);
+
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+
+	dptr = d;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n", d[0], d[1], d[2],
+						d[3], d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n", d[8], d[9], d[10],
+					d[11], d[12], d[13], d[14], d[15]);
+	total_bytes = fifo_count;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->sensor[i].count =  total_bytes / pk_size;
+		}
+	}
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		pr_debug("total%d, pk=%d\n", total_bytes, pk_size);
+		if (total_bytes >= pk_size) {
+			res = inv_push_20602_data(indio_dev, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+	st->wake_sensor_received = false;
+	result = inv_process_20602_data(indio_dev);
+	if (result)
+		goto err_reset_fifo;
+	mutex_unlock(&st->lock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_switch_power_in_lp(st, false);
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_switch_power_in_lp(st, true);
+	inv_reset_fifo(st, true);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		st->wake_sensor_received = false;
+		inv_process_20602_data(indio_dev);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+		inv_switch_power_in_lp(st, false);
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_selftest_20602.c b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_selftest_20602.c
new file mode 100644
index 000000000000..e4aa894e5835
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_selftest_20602.c
@@ -0,0 +1,745 @@
+/*
+* Copyright (C) 2017-2018 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* register settings */
+#define DEF_SELFTEST_GYRO_SENS          (32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS                     20
+#define SELFTEST_WAIT_TIME              (MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME              20
+#define DEF_GYRO_SCALE                  131
+#define DEF_ST_PRECISION                1000
+#define DEF_ST_ACCEL_FS_MG              2000UL
+#define DEF_ST_SCALE                    32768
+#define DEF_ST_TRY_TIMES                2
+#define DEF_ST_ACCEL_RESULT_SHIFT       1
+#define DEF_ST_SAMPLES                  200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN    500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX    1500
+#define DEF_GYRO_CT_SHIFT_DELTA         500
+
+#define SENSOR_UP_TIME	30
+#define REG_UP_TIME		2
+
+#define DEF_ST_ACCEL_FS_MG         2000UL
+#define DEF_ACCEL_ST_SHIFT_DELTA   500
+#define ACCEL_ST_AL_MIN ((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX ((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+#define THREE_AXIS               3
+#define DEF_ST_MPU6500_ACCEL_LPF        2
+#define DEF_SELFTEST_SAMPLE_RATE        0 /* 1000Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_LP     4 /*  200Hz */
+#define INV_MPU_SAMPLE_RATE_CHANGE_STABLE 50
+#define DEF_SELFTEST_6500_ACCEL_FS      (0 << 3)
+#define DEF_SELFTEST_GYRO_FS            (0 << 3)
+#define DEF_ST_6500_STABLE_TIME         20
+#define BIT_ACCEL_OUT           0x08
+#define BITS_GYRO_OUT           0x70
+#define THREE_AXIS               3
+#define DEF_GYRO_WAIT_TIME              10
+#define DEF_GYRO_WAIT_TIME_LP           50
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX             20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL                  60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN             225
+#define DEF_ACCEL_ST_AL_MAX             675
+
+struct recover_regs {
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 fifo_en;			/* REG_FIFO_EN */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 config;			/* REG_CONFIG */
+	u8 gyro_config;		/* REG_GYRO_CONFIG */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+	u8 smplrt_div;		/* REG_SAMPLE_RATE_DIV */
+	u8 lp_mode;			/* REG_LP_MODE_CTRL */
+	u8 pwr_mgmt_1;		/* REG_PWR_MGMT_1 */
+	u8 pwr_mgmt_2;		/* REG_PWR_MGMT_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_INT_ENABLE      : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_FIFO_EN         : 0x%02X\n", saved_regs.fifo_en);
+	pr_debug(" REG_USER_CTRL       : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_CONFIG          : 0x%02X\n", saved_regs.config);
+	pr_debug(" REG_GYRO_CONFIG     : 0x%02X\n", saved_regs.gyro_config);
+	pr_debug(" REG_ACCEL_CONFIG    : 0x%02X\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2  : 0x%02X\n", saved_regs.accel_config_2);
+	pr_debug(" REG_SAMPLE_RATE_DIV : 0x%02X\n", saved_regs.smplrt_div);
+	pr_debug(" REG_LP_MODE_CTRL    : 0x%02X\n", saved_regs.lp_mode);
+	pr_debug(" REG_PWR_MGMT_1      : 0x%02X\n", saved_regs.pwr_mgmt_1);
+	pr_debug(" REG_PWR_MGMT_2      : 0x%02X\n", saved_regs.pwr_mgmt_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_read(st, REG_PWR_MGMT_1, 1,
+			&saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	/* wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			(saved_regs.pwr_mgmt_1 & ~BIT_SLEEP));
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_INT_ENABLE, 1,
+			&saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1,
+			&saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1,
+			&saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1,
+			&saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG, 1,
+			&saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SAMPLE_RATE_DIV, 1,
+			&saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_MODE_CTRL, 1,
+			&saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1,
+			&saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN,
+			saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_CONFIG,
+			saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+			saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+			saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+			saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_switch_engine(struct inv_mpu_state *st, bool en, u32 mask)
+{
+	u8 data, mgmt_1;
+	int result;
+
+	if (BIT_PWR_GYRO_STBY == mask) {
+		result = inv_plat_read(st, REG_PWR_MGMT_1, 1, &mgmt_1);
+		if (result)
+			return result;
+		mgmt_1 &= ~BIT_CLK_MASK;
+	}
+
+	if ((BIT_PWR_GYRO_STBY == mask) && (!en)) {
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1, &data);
+	if (result)
+		return result;
+	if (en)
+		data &= (~mask);
+	else
+		data |= mask;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2, data);
+	if (result)
+		return result;
+
+	if ((BIT_PWR_GYRO_STBY == mask) && en) {
+		/* only gyro on needs sensor up time */
+		msleep(SENSOR_UP_TIME);
+		/* after gyro is on & stable, switch internal clock to PLL */
+		mgmt_1 |= BIT_CLK_PLL;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+	if ((BIT_PWR_ACCEL_STBY == mask) && en)
+		msleep(REG_UP_TIME);
+
+	return 0;
+}
+
+int inv_set_offset_reg(struct inv_mpu_state *st, int reg, int val)
+{
+	int result;
+	u8 d;
+
+	d = ((val >> 8) & 0xff);
+	result = inv_plat_single_write(st, reg, d);
+	if (result)
+		return result;
+
+	d = (val & 0xff);
+	result = inv_plat_single_write(st, reg + 1, d);
+
+	return result;
+}
+
+/**
+* inv_check_gyro_self_test() - check gyro self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_gyro_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg) {
+	u8 regs[3];
+	int ret_val, result;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XG_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test gyro shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA
+						* st_shift_prod[i])
+					ret_val = 1;
+		} else {
+			/* Self Test Pass/Fail Criteria B */
+			if (st_shift_cust[i] < DEF_GYRO_ST_AL *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	if (ret_val == 0) {
+		/* Self Test Pass/Fail Criteria C */
+		for (i = 0; i < 3; i++)
+			if (abs(reg_avg[i]) > DEF_GYRO_OFFSET_MAX *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/**
+* inv_check_accel_self_test() - check 6500 accel self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_accel_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg) {
+	int ret_val, result;
+	int st_shift_prod[3], st_shift_cust[3], st_shift_ratio[3], i;
+	u8 regs[3];
+	int otp_value_zero = 0;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XA_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test accel shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			st_shift_ratio[i] = abs(st_shift_cust[i] /
+					st_shift_prod[i] - DEF_ST_PRECISION);
+			if (st_shift_ratio[i] > DEF_ACCEL_ST_SHIFT_DELTA)
+				ret_val = 1;
+		}
+	} else {
+		/* Self Test Pass/Fail Criteria B */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = abs(st_avg[i] - reg_avg[i]);
+			if (st_shift_cust[i] < ACCEL_ST_AL_MIN ||
+					st_shift_cust[i] > ACCEL_ST_AL_MAX)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+int inv_do_test(struct inv_mpu_state *st, int self_test_flag,
+		int *gyro_result, int *accel_result, int lp_mode)
+{
+	int result, i, j, packet_size;
+	u8 data[BYTES_PER_SENSOR * 2 + BYTES_FOR_TEMP], d, dd;
+	int fifo_count, packet_count, ind, s;
+
+	packet_size = BYTES_PER_SENSOR * 2 + BYTES_FOR_TEMP;
+
+	/* disable interrupt */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+	/* disable the sensor output to FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (result)
+		return result;
+	/* disable fifo reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+	if (result)
+		return result;
+	/* clear FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (result)
+		return result;
+	/* setup parameters */
+	result = inv_plat_single_write(st, REG_CONFIG, INV_FILTER_98HZ);
+	if (result)
+		return result;
+
+	/* gyro lp mode */
+	if (lp_mode == 1)
+		d  = BIT_GYRO_CYCLE_EN;
+	else
+		d = 0;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, d);
+	if (result)
+		return result;
+
+	/* config accel LPF register for MPU6500 */
+	if (lp_mode == 2)
+		d = BIT_ACCEL_FCHOCIE_B;
+	else
+		d = DEF_ST_MPU6500_ACCEL_LPF;
+	result = inv_plat_single_write(st, REG_6500_ACCEL_CONFIG2, d);
+	if (result)
+		return result;
+
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE_LP);
+	} else {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE);
+	}
+	if (result)
+		return result;
+	/* wait for the sampling rate change to stabilize */
+	mdelay(INV_MPU_SAMPLE_RATE_CHANGE_STABLE);
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+		self_test_flag | DEF_SELFTEST_GYRO_FS);
+	if (result)
+		return result;
+
+	d = DEF_SELFTEST_6500_ACCEL_FS;
+	d |= self_test_flag;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, d);
+	if (result)
+		return result;
+
+	/* wait for the output to get stable */
+	msleep(DEF_ST_6500_STABLE_TIME);
+
+	/* enable FIFO reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+	if (result)
+		return result;
+	/* enable sensor output to FIFO */
+	d = BITS_GYRO_OUT | BIT_ACCEL_OUT;
+	for (i = 0; i < THREE_AXIS; i++) {
+		gyro_result[i] = 0;
+		accel_result[i] = 0;
+	}
+	s = 0;
+	while (s < 200 /*st->self_test.samples*/) {
+		/* Stop FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+		if (result)
+			return result;
+		/* clear FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+		if (result)
+			return result;
+		/* enable FIFO reading */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+		if (result)
+			return result;
+
+		/* accel lp mode */
+		dd = BIT_CLK_PLL;
+		if (lp_mode == 2)
+			dd |= BIT_LP_EN;
+		else
+			dd &= ~BIT_LP_EN;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, dd);
+		if (result)
+			return result;
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, d);
+		if (result)
+			return result;
+		if (lp_mode)
+			mdelay(DEF_GYRO_WAIT_TIME_LP);
+		else
+			mdelay(DEF_GYRO_WAIT_TIME);
+
+		result = inv_plat_read(st, REG_FIFO_COUNT_H,
+					FIFO_COUNT_BYTE, data);
+		if (result)
+			return result;
+		fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+		pr_debug("%s self_test fifo_count - %d\n",
+			 st->hw->name, fifo_count);
+		packet_count = fifo_count / packet_size;
+		i = 0;
+		while ((i < packet_count) && (s < 200 /*st->self_test.samples*/)) {
+			short vals[3];
+			result = inv_plat_read(st, REG_FIFO_R_W,
+				packet_size, data);
+			if (result)
+				return result;
+			ind = 0;
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				accel_result[j] += vals[j];
+			}
+			ind += (BYTES_PER_SENSOR + BYTES_FOR_TEMP);
+			pr_debug(
+				"%s self_test accel data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				gyro_result[j] += vals[j];
+			}
+			pr_debug("%s self_test gyro data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			s++;
+			i++;
+		}
+	}
+
+	for (j = 0; j < THREE_AXIS; j++) {
+		accel_result[j] = accel_result[j] / s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+	for (j = 0; j < THREE_AXIS; j++) {
+		gyro_result[j] = gyro_result[j] / s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	return 0;
+}
+
+
+int inv_power_up_self_test(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+
+	/* make sure no interrupts */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_ACCEL_STBY);
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXIS], gyro_bias_regular[THREE_AXIS];
+	int accel_bias_st[THREE_AXIS], accel_bias_regular[THREE_AXIS];
+	int gyro_bias_regular_lp[THREE_AXIS];
+#if 0
+	int accel_bias_regular_lp[THREE_AXIS];
+#endif
+	int dummy_bias_regular[THREE_AXIS];
+	int test_times, i;
+	char accel_result, gyro_result;
+
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	result = inv_power_up_self_test(st);
+	if (result)
+		return result;
+	accel_result = 0;
+	gyro_result = 0;
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular,
+			accel_bias_regular, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("%s self_test gyro bias_regular - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular[0], gyro_bias_regular[1],
+		gyro_bias_regular[2]);
+
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, BITS_SELF_TEST_EN, gyro_bias_st,
+					accel_bias_st, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_st - %+d %+d %+d\n",
+		st->hw->name, accel_bias_st[0], accel_bias_st[1],
+		accel_bias_st[2]);
+	pr_debug("%s self_test gyro bias_st - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_st[0], gyro_bias_st[1],
+		gyro_bias_st[2]);
+
+
+	/* lp gyro mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			dummy_bias_regular, 1);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test gyro bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, gyro_bias_regular_lp[0], gyro_bias_regular_lp[1],
+		 gyro_bias_regular_lp[2]);
+
+#if 0
+	/* lp accel mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, dummy_bias_regular,
+			accel_bias_regular_lp, 2);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, accel_bias_regular_lp[0],
+		 accel_bias_regular_lp[1], accel_bias_regular_lp[2]);
+#endif
+
+	/* copy bias */
+	for (i = 0; i < 3; i++) {
+		/* gyro : LP bias as LP is default mode */
+		st->gyro_st_bias[i] = gyro_bias_regular_lp[i] / DEF_ST_PRECISION;
+		/* accel : LN bias as LN is default mode */
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	/* Check is done on continuous mode data */
+	accel_result = !inv_check_accel_self_test(st,
+		accel_bias_regular, accel_bias_st);
+	gyro_result = !inv_check_gyro_self_test(st,
+		gyro_bias_regular, gyro_bias_st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_setup_20602.c b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_setup_20602.c
new file mode 100644
index 000000000000..f91f1a030219
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20602/inv_mpu_setup_20602.c
@@ -0,0 +1,540 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_engine_dur(struct inv_mpu_state *st,
+				struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	if (st->mode_1k_on)
+		ei->dur = ei->base_time_1k / ei->orig_rate;
+	else if (st->mode_vr_on)
+		ei->dur = ei->base_time_vr / ei->orig_rate;
+	else
+		ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 int_en, fifo_en, mode, user;
+	int r;
+	char data;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (r)
+		return r;
+	//dummy fifo read
+	inv_plat_read(st, REG_FIFO_R_W, 1, &data);
+	fifo_en = 0;
+	int_en = 0;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		if (st->chip_config.stationary_detect_enable)
+			st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+		else
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		int_en |= BIT_WOM_ALL_INT_EN;
+	}
+	if (st->batch.timeout) {
+		if(!st->batch.fifo_wm_th)
+			int_en = BIT_DATA_RDY_EN;
+	} else {
+		int_en = BIT_DATA_RDY_EN;
+		if (st->chip_config.eis_enable)
+			int_en |= BIT_FSYNC_INT_EN;
+	}
+	if (st->sensor[SENSOR_GYRO].on)
+		fifo_en |= BITS_GYRO_FIFO_EN;
+
+	if (st->sensor[SENSOR_ACCEL].on)
+		fifo_en |= BIT_ACCEL_FIFO_EN;
+	r = inv_plat_single_write(st, REG_FIFO_EN, fifo_en);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, int_en);
+	if (r)
+		return r;
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		mode = BIT_ACCEL_INTEL_EN | BIT_ACCEL_INTEL_MODE;
+	} else {
+		mode = 0;
+	}
+	r = inv_plat_single_write(st, REG_ACCEL_INTEL_CTRL, mode);
+	user = BIT_FIFO_EN;
+	r = inv_plat_single_write(st, REG_USER_CTRL, user | st->i2c_dis);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+	if (st->mode_1k_on)
+		ts_algo->first_sample = MODE_1K_INIT_SAMPLE;
+	else if(st->mode_vr_on)
+		ts_algo->first_sample = MODE_VR_INIT_SAMPLE;
+	else
+		ts_algo->first_sample = 1;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int r;
+	unsigned int wait_ms;
+
+	if (st->chip_config.gyro_enable | st->chip_config.accel_enable) {
+		w = 0;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else if (st->chip_config.compass_enable) {
+		w = BIT_PWR_GYRO_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY);
+	}
+
+	r = inv_plat_read(st, REG_PWR_MGMT_2, 1, &v);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	if (r)
+		return r;
+
+	wait_ms = 0;
+	/* wait when enabling gyro */
+	if (st->chip_config.gyro_enable
+		&& (v & BIT_PWR_GYRO_STBY)) {
+		wait_ms = INV_ICM20602_GYRO_START_TIME;
+	}
+	/* wait when disabling gyro */
+	if (!(v & BIT_PWR_GYRO_STBY) &&
+			!st->chip_config.gyro_enable) {
+		if (wait_ms < 150)
+			wait_ms = 150;
+	}
+	/* wait when enabling accel */
+	if (st->chip_config.accel_enable
+		&& (v & BIT_PWR_ACCEL_STBY)) {
+		if (INV_ICM20602_ACCEL_START_TIME > wait_ms)
+			wait_ms = INV_ICM20602_ACCEL_START_TIME;
+	}
+	if (wait_ms)
+		msleep(wait_ms);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->ts_algo.clock_base].dur;
+			st->sensor[i].div = 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf_gyro_cycle_avgcfg() - set gyro cycle mode and
+ * set avg filter config based on rate.
+ */
+static int inv_set_lpf_gyro_cycle_avgfltr(struct inv_mpu_state *st, int rate)
+{
+	const short odr[] = {30, 50, 100, 200, 500};
+	const int fltrconfig[] = {
+		BIT_AVG_FILTER_30HZ,
+		BIT_AVG_FILTER_50HZ,
+		BIT_AVG_FILTER_100HZ,
+		BIT_AVG_FILTER_200HZ,
+		BIT_AVG_FILTER_500HZ
+	};
+	int i, result, data;
+	i = 0;
+	while ((rate > odr[i]) && (i < ARRAY_SIZE(fltrconfig) - 1))
+		i++;
+	data = (BIT_GYRO_CYCLE_EN | fltrconfig[i]);
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, data);
+	return result;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st, int rate)
+{
+	const short hz[] = {188, 98, 42, 20, 10, 5};
+	const int   d[] = {INV_FILTER_188HZ, INV_FILTER_98HZ,
+			INV_FILTER_42HZ, INV_FILTER_20HZ,
+			INV_FILTER_10HZ, INV_FILTER_5HZ};
+	int i, h, data, result;
+
+	if (st->chip_config.eis_enable || st->ois.en ||
+		st->mode_1k_on || st->mode_vr_on) {
+		h = (rate >> 1);
+		i = 0;
+		while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+			i++;
+		data = d[i];
+		data |= (EXT_SYNC_SET | BIT_FIFO_COUNT_REC);
+		result = inv_plat_single_write(st, REG_CONFIG, data);
+		if (result)
+			return result;
+
+		st->chip_config.lpf = data;
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL, 0);
+		st->gyro_lp_mode = 0;
+	} else {
+		result = inv_set_lpf_gyro_cycle_avgfltr(st, rate);
+		if (result)
+			return result;
+		data = (BIT_FIFO_COUNT_REC);
+		result = inv_plat_single_write(st, REG_CONFIG, data | 3);
+		st->gyro_lp_mode = 1;
+	}
+
+	return result;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result, div;
+
+	if (st->chip_config.gyro_enable)
+		div = g_d;
+	else
+		div = a_d;
+	if (st->chip_config.eis_enable)
+		div = 0;
+
+	pr_debug("div= %d\n", div);
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV, div);
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+	int res = 0;
+	u32 w;
+
+	if (st->batch.timeout) {
+		w = st->batch.timeout * st->eng_info[ENGINE_GYRO].running_rate
+					* st->batch.pk_size / 1000;
+		if (w > MAX_BATCH_FIFO_SIZE)
+			w = MAX_BATCH_FIFO_SIZE;
+	} else {
+		w = 0;
+	}
+	if (st->batch.pk_size)
+		w /= st->batch.pk_size;
+	st->batch.fifo_wm_th = w;
+	pr_debug("running= %d, pksize=%d, to=%d w=%d\n",
+		st->eng_info[ENGINE_GYRO].running_rate,
+		st->batch.pk_size, st->batch.timeout, w);
+	res = inv_plat_single_write(st, REG_FIFO_WM_TH2, w & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_FIFO_WM_TH1, (w >> 8) & 0xff);
+
+	return res;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result, i;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st, st->eng_info[ENGINE_GYRO].running_rate);
+	if (result)
+		return result;
+	// set ADLPF at this point not to change after accel is enabled
+	result = inv_set_accel_config2(st, false);
+	st->batch.pk_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->batch.pk_size +=  st->sensor[i].sample_size;
+	}
+
+	inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	gyro_rate = MPU_INIT_SENSOR_RATE;
+	accel_rate = MPU_INIT_SENSOR_RATE;
+	/* loop the streaming sensors to see which engine needs to be turned on
+		*/
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	st->sensor[SENSOR_TEMP].on = true;
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		accel_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	if ((gyro_rate > MPU_DEFAULT_DMP_FREQ) ||
+					(accel_rate > MPU_DEFAULT_DMP_FREQ)) {
+		if ((gyro_rate == MODE_VR_RATE) ||
+			(accel_rate == MODE_VR_RATE))
+			st->mode_vr_on = true;
+		else
+			st->mode_1k_on = true;
+	} else {
+		st->mode_1k_on = false;
+		st->mode_vr_on = false;
+	}
+	/* engine divider for pressure and compass is set later */
+	if (st->chip_config.eis_enable || st->mode_1k_on) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		// need to update rate and div for 1khz mode
+		for ( i = 0 ; i < SENSOR_L_NUM_MAX ; i++ ) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+					    ((BASE_SAMPLE_RATE /
+						 st->eng_info[ENGINE_GYRO].divider) /
+						 st->sensor_l[i].rate);
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else if (st->mode_vr_on) {
+		st->eng_info[ENGINE_GYRO].divider = 2;
+		st->eng_info[ENGINE_ACCEL].divider = 2;
+		// need to update rate and div for VR mode
+		for ( i = 0 ; i < SENSOR_L_NUM_MAX ; i++ ) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+					    ((BASE_SAMPLE_RATE /
+						 st->eng_info[ENGINE_GYRO].divider) /
+						 st->sensor_l[i].rate);
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_GYRO].running_rate);
+		st->eng_info[ENGINE_ACCEL].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_ACCEL].running_rate);
+	}
+
+	for ( i = 0 ; i < SENSOR_L_NUM_MAX ; i++ )
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_interrupt(st);
+	inv_determine_engine(st);
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable)) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_stop_interrupt(st);
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_restore_interrupt(st);
+}
+
+/* dummy function for 20608D */
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	return 0;
+}
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	return 0;
+}
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/dmp3Default_20608D.h b/drivers/iio/imu/inv_mpu/icm20608d/dmp3Default_20608D.h
new file mode 100644
index 000000000000..005a155c211b
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/dmp3Default_20608D.h
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2012-2018 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+//#define INV_IPL
+
+#ifndef INV_IPL
+#define CFG_PEDSTEP_DET                     (3371)
+#define OUT_ACCL_DAT                        (2380)
+#define CFG_FB_GAIN_GYRO_ON                 (1959)
+#define CFG_OUT_GYRO                        (2405)
+#define PED_STEP_COUNT2_DETECTED            (3377)
+#define GYRO_FIFO_RATE                      (2391)
+#define FSYNC_END                           (1342)
+#define PREV_PQUAT                          (2432)
+#define ACCEL_FIFO_RATE                     (2356)
+#define PQUAT_FIFO_RATE                     (2321)
+#define CFG_FIFO_INT                        (2533)
+#define CFG_AUTH                            (1361)
+#define CFG_OUT_FSYNC                       (1327)
+#define FCFG_1                              (1428)
+#define FCFG_3                              (1458)
+#define FCFG_2                              (1432)
+#define FCFG_7                              (1439)
+#define CFG_OUT_3QUAT                       (2263)
+#define OUT_3QUAT_DAT                       (2274)
+#define CFG_PED_ENABLE                      (2543)
+#define CFG_EXT_GYRO_BIAS                   (1547)
+#define CFG_7                               (1895)
+#define OUT_PQUAT_DAT                       (2345)
+#define CFG_OUT_6QUAT                       (2299)
+#define CFG_PED_INT                         (3360)
+#define SMD_TP2                             (1835)
+#define SMD_TP1                             (1812)
+#define STEPDET_END                         (2249)
+#define CFG_MOTION_BIAS                     (1896)
+#define CFG_OUT_ACCL                        (2370)
+#define CFG_OUT_STEPDET                     (2232)
+#define OUT_6QUAT_DAT                       (2310)
+#define QUAT6_FIFO_RATE                     (2285)
+#define OUT_GYRO_DAT                        (2415)
+#define CFG_OUT_PQUAT                       (2335)
+#else
+#define CFG_OUT_ACCL                        (2359)
+#define CFG_PEDSTEP_DET                     (3360)
+#define OUT_ACCL_DAT                        (2369)
+#define CFG_FB_GAIN_GYRO_ON                 (1930)
+#define CFG_OUT_GYRO                        (2394)
+#define PED_STEP_COUNT2_DETECTED            (3366)
+#define GYRO_FIFO_RATE                      (2380)
+#define FSYNC_END                           (1313)
+#define PREV_PQUAT                          (2421)
+#define ACCEL_FIFO_RATE                     (2345)
+#define PQUAT_FIFO_RATE                     (2310)
+#define CFG_FIFO_INT                        (2522)
+#define CFG_AUTH                            (1332)
+#define CFG_OUT_FSYNC                       (1298)
+#define FCFG_1                              (1399)
+#define FCFG_3                              (1429)
+#define FCFG_2                              (1403)
+#define FCFG_7                              (1410)
+#define CFG_OUT_3QUAT                       (2252)
+#define OUT_3QUAT_DAT                       (2263)
+#define CFG_PED_ENABLE                      (2532)
+#define CFG_EXT_GYRO_BIAS                   (1518)
+#define CFG_7                               (1866)
+#define OUT_PQUAT_DAT                       (2334)
+#define CFG_OUT_6QUAT                       (2288)
+#define CFG_PED_INT                         (3349)
+#define SMD_TP2                             (1806)
+#define SMD_TP1                             (1783)
+#define STEPDET_END                         (2238)
+#define CFG_MOTION_BIAS                     (1867)
+#define CFG_OUT_STEPDET                     (2221)
+#define OUT_6QUAT_DAT                       (2299)
+#define QUAT6_FIFO_RATE                     (2274)
+#define OUT_GYRO_DAT                        (2404)
+#define CFG_OUT_PQUAT                       (2324)
+#endif
+
+#define D_EXT_GYRO_BIAS_X       (61 * 16)
+#define D_EXT_GYRO_BIAS_Y       ((61 * 16) + 4)
+#define D_EXT_GYRO_BIAS_Z       ((61 * 16) + 8)
+#define GYRO_BIAS_X	D_EXT_GYRO_BIAS_X
+#define GYRO_BIAS_Y	D_EXT_GYRO_BIAS_Y
+#define GYRO_BIAS_Z	D_EXT_GYRO_BIAS_Z
+
+#define D_EIS_ENABLE			(2 * 16 + 10)
+
+#define D_SMD_ENABLE            (18 * 16)
+#define D_SMD_MOT_THLD          (21 * 16 + 8)
+#define SMD_VAR_TH	D_SMD_MOT_THLD
+
+#define D_SMD_DELAY_THLD        (21 * 16 + 4)
+#define D_SMD_DELAY2_THLD       (21 * 16 + 12)
+#define D_SMD_EXE_STATE         (22 * 16)
+#define D_SMD_DELAY_CNTR        (21 * 16)
+
+#define D_VIB_DET_RATIO         (30 * 16 + 0)
+#define D_VIB_MAG_TH            (31 * 16 + 0)
+#define D_VIB_K                 (13 * 16 + 8)
+#define D_VIB_K_1               (13 * 16 + 12)
+
+#define D_ACC_SCALE             (29 * 16 + 0)
+#define ACC_SCALE D_ACC_SCALE
+#define D_ACC_DATA_SCALE        (15 * 16 + 4)
+#define ACC_DATA_SCALE D_ACC_DATA_SCALE
+
+#define D_AUTH_OUT              (992)
+#define D_AUTH_IN               (996)
+#define D_AUTH_A                (1000)
+#define D_AUTH_B                (1004)
+#define D_DMP_AUTH_INPUT		(70 * 16 + 4)
+#define D_DMP_AUTH_OUTPUT		(70 * 16 + 0)
+
+#define SC_AUT_OUTPUT_20608D		D_DMP_AUTH_OUTPUT
+#define SC_AUT_INPUT_20608D		D_DMP_AUTH_INPUT
+
+#define D_PEDSTD_BP_B           (768 + 0x1C)
+#define D_PEDSTD_BP_A4          (768 + 0x40)
+#define D_PEDSTD_BP_A3          (768 + 0x44)
+#define D_PEDSTD_BP_A2          (768 + 0x48)
+#define D_PEDSTD_BP_A1          (768 + 0x4C)
+#define D_PEDSTD_SB             (768 + 0x28)
+#define D_PEDSTD_SB_TIME        (768 + 0x2C)
+#define D_PEDSTD_PEAKTHRSH      (768 + 0x98)
+#define D_PEDSTD_TIML           (768 + 0x2A)
+#define D_PEDSTD_TIMH           (768 + 0x2E)
+#define D_PEDSTD_PEAK           (768 + 0X94)
+#define D_PEDSTD_STEPCTR        (768 + 0x60)
+#define PEDSTD_STEPCTR		D_PEDSTD_STEPCTR
+#define D_PEDSTD_STEPCTR2       (58 * 16 + 8)
+#define D_PEDSTD_TIMECTR        (964)
+#define PEDSTD_TIMECTR		D_PEDSTD_TIMECTR
+#define D_PEDSTD_DECI           (768 + 0xA0)
+#define D_PEDSTD_SB2			(60 * 16 + 14)
+#define D_STPDET_TIMESTAMP      (28 * 16 + 8)
+#define STPDET_TIMESTAMP	D_STPDET_TIMESTAMP
+#define D_PEDSTD_DRIVE_STATE    (58)
+#define D_PEDSTEP_IND			(26*16 + 6)
+#define PEDSTEP_IND				D_PEDSTEP_IND
+
+#define D_HOST_NO_MOT           (976)
+#define D_ACCEL_BIAS            (660)
+
+/* Batch mode */
+#define D_BM_BATCH_CNTR         (27*16+4)
+#define D_BM_BATCH_THLD         (27*16+12)
+#define BM_BATCH_CNTR		D_BM_BATCH_CNTR
+#define BM_BATCH_THLD		D_BM_BATCH_THLD
+
+#define D_BM_ENABLE             (28*16+6)
+#define D_BM_NUMWORD_TOFILL     (28*16+4)
+
+/* DMP running counter */
+#define D_DMP_RUN_CNTR          (24*16)
+#define DMPRATE_CNTR		D_DMP_RUN_CNTR
+
+/* Sensor's ODR */
+#define D_ODR_S2                (45*16+10)
+#define D_ODR_S3                (45*16+14)
+#define D_ODR_S4                (46*16+8)
+#define D_ODR_S5                (46*16+12)
+#define D_ODR_S1                (45*16+12)
+
+#define ODR_ACCEL			D_ODR_S4
+#define ODR_GYRO			D_ODR_S5
+#define ODR_QUAT6			D_ODR_S2
+#define ODR_PQUAT6			D_ODR_S3
+#define ODR_LPQ			D_ODR_S1
+
+/* sensor output data rate counter */
+#define D_ODR_CNTR_S2           (45*16+2)
+#define D_ODR_CNTR_S3           (45*16+6)
+#define D_ODR_CNTR_S4           (46*16)
+#define D_ODR_CNTR_S5           (46*16+4)
+#define D_ODR_CNTR_S1           (45*16+4)
+
+#define ODR_CNTR_ACCEL				D_ODR_CNTR_S4
+#define ODR_CNTR_GYRO				D_ODR_CNTR_S5
+#define ODR_CNTR_QUAT6				D_ODR_CNTR_S2
+#define ODR_CNTR_PQUAT6			D_ODR_CNTR_S3
+#define ODR_CNTR_LPQ			        D_ODR_CNTR_S1
+
+/* DMP Fusion LP-Quat */
+#define D_FS_LPQ0               (59*16)
+#define D_FS_LPQ1               (59*16 + 4)
+#define D_FS_LPQ2               (59*16 + 8)
+#define D_FS_LPQ3               (59*16 + 12)
+
+/* DMP Fusion (Accel+Gyro) Quat */
+#define D_ACCEL_FB_GAIN			(6*16)
+#define D_GYRO_SF				(6*16 + 8)
+#define GYRO_SF		D_GYRO_SF
+#define D_FS_Q0                 (12*16)
+#define D_FS_Q1                 (12*16 + 4)
+#define D_FS_Q2                 (12*16 + 8)
+#define D_FS_Q3                 (12*16 + 12)
+
+/* AK compass support */
+#define D_CPASS_STATUS_CHK		(22*16 + 8)
+
+/* data packet size reg 1 */
+#define HEADER_SZ		2
+#define ACCEL_DATA_SZ	6
+#define GYRO_DATA_SZ	18
+#define QUAT6_DATA_SZ	14
+#define LPQ_DATA_SZ	14
+#define PQUAT6_DATA_SZ	6
+#define PED_STEPDET_TIMESTAMP_SZ	4
+#define FOOTER_SZ		2
+#define ACCEL_ACCURACY_SZ	2
+#define GYRO_ACCURACY_SZ	2
+#define CPASS_ACCURACY_SZ	2
+#define FSYNC_PK_SZ		2
+
+#define ACCEL_SET				0x4000
+#define GYRO_SET				0x2000
+#define LPQ_SET				0x0800
+#define QUAT6_SET				0x0400
+#define PQUAT6_SET			0x0200
+#define PED_STEPDET_SET		0x0100
+#define HEADER2_SET			0x0008
+#define PED_STEPIND_SET		0x0007
+#define FSYNC_HDR               0x7000
+
+/* high byte of motion event control */
+#define PEDOMETER_EN        0x4000
+#define PEDOMETER_INT_EN    0x2000
+#define TILT_INT_EN         0x1000
+#define SMD_EN              0x0800
+#define SECOND_SENSOR_AUTO  0x0400
+#define ACCEL_CAL_EN        0x0200
+#define GYRO_CAL_EN         0x0100
+/* low byte of motion event control */
+#define COMPASS_CAL_EN      0x0080
+#define NINE_AXIS_EN        0x0040
+#define S_HEALTH_EN         0x0020
+#define FLIP_PICKUP_EN      0x0010
+#define GEOMAG_RV_EN        0x0008
+#define BRING_LOOK_SEE_EN   0x0004
+#define BAC_ACCEL_ONLY_EN   0x0002
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_core_20608.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_core_20608.c
new file mode 100644
index 000000000000..d59824a09caf
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_core_20608.c
@@ -0,0 +1,2078 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM20608D] = {128, "icm20608d"},
+	[ICM20789] = {128, "icm20608d"},
+};
+
+static const struct i2c_board_info inv_icp101xx_i2c_info = {
+	I2C_BOARD_INFO("icp101xx", 0x63),
+};
+
+static int debug_mem_read_addr = 0x900;
+static char debug_reg_addr = 0x6;
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+/*
+ * inv_firmware_loaded_store() -  calling this function will change
+ *                        firmware load
+ */
+static ssize_t inv_firmware_loaded_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+
+	if (data)
+		return -EINVAL;
+	st->chip_config.firmware_loaded = 0;
+
+	return count;
+
+}
+
+static int inv_dry_run_dmp(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	st->smd.on = 1;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+	msleep(DRY_RUN_TIME);
+	st->smd.on = 0;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+
+	return 0;
+}
+
+static int _dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data, output;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto dmp_bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_GYRO_ACCURACY] = true;
+		result = write_be32_to_mem(st, data, D_EXT_GYRO_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, D_EXT_GYRO_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, D_EXT_GYRO_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		result = write_be32_to_mem(st, data, st->aut_key_in);
+		if (result)
+			goto dmp_bias_store_fail;
+		result = write_be32_to_mem(st, 0, st->aut_key_out);
+		if (result)
+			goto dmp_bias_store_fail;
+		/* dry run DMP to get the auth key output */
+		inv_dry_run_dmp(indio_dev);
+		result = inv_switch_power_in_lp(st, true);
+		if (result)
+			goto dmp_bias_store_fail;
+		result = read_be32_from_mem(st, &output, st->aut_key_out);
+		if (result)
+			goto dmp_bias_store_fail;
+		inv_push_marker_to_buffer(indio_dev, EIS_CALIB_HDR, output);
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_MISC_GYRO_RECALIBRATION:
+		return -ENOSYS;
+	case ATTR_DMP_MISC_ACCEL_RECALIBRATION:
+		return -ENOSYS;
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		return -ENOSYS;
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		return -ENOSYS;
+	case ATTR_DMP_DEBUG_MEM_READ:
+		debug_mem_read_addr = data;
+		break;
+	case ATTR_DMP_DEBUG_MEM_WRITE:
+		inv_write_2bytes(st, debug_mem_read_addr, data);
+		break;
+	default:
+		break;
+	}
+
+dmp_bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[0];
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[1];
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[2];
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0 */
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _dmp_bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	case ATTR_DEBUG_WRITE_CFG:
+		break;
+	}
+	return count;
+}
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		st->chip_config.low_power_gyro_on = !!data;
+		break;
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		st->debug_determine_engine_on = !!data;
+		break;
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_INT_ON:
+		result  = inv_enable_pedometer_interrupt(st, !!data);
+		if (result)
+			return result;
+		st->ped.int_on = !!data;
+		return 0;
+	case ATTR_DMP_PED_STEP_THRESH:
+		st->ped.step_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_THRESH:
+		st->ped.int_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_MODE:
+		st->ped.int_mode = !!data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int _debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (!st->debug_determine_engine_on)
+		return -EINVAL;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return -ENOSYS;
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		st->gyro_cal_enable = !!data;
+		break;
+	case ATTR_DMP_EVENT_INT_ON:
+		st->chip_config.dmp_event_int_on = !!data;
+		break;
+	case ATTR_DMP_ON:
+		st->chip_config.dmp_on = !!data;
+		break;
+	case ATTR_GYRO_ENABLE:
+		st->chip_config.gyro_enable = !!data;
+		break;
+	case ATTR_ACCEL_ENABLE:
+		st->chip_config.accel_enable = !!data;
+		break;
+	case ATTR_COMPASS_ENABLE:
+		return -ENODEV;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = DEBUG_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_debug_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _debug_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int step;
+
+	result = inv_get_pedometer_steps(st, &step);
+	if (result) {
+		pr_info("Failed to read step count\n");
+		return result;
+	}
+	inv_send_steps(indio_dev, step, get_time_ns());
+	st->prev_steps = step;
+
+	return 0;
+}
+
+static int inv_send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	inv_switch_power_in_lp(st, true);
+	_send_pedo_steps(indio_dev);
+	inv_switch_power_in_lp(st, false);
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		if ((!!data) == st->smd.on) {
+			pr_debug("SMD is %s\n  Same",
+						st->smd.on ? "On" : "Off");
+			return count;
+		}
+		st->smd.on = !!data;
+		pr_debug("SMD is %s\n", st->smd.on ? "On" : "Off");
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0, sizeof(struct spi_transfer));
+
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_ACTIVITY_ON:
+		return -ENODEV;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		if (st->step_counter_l_on)
+			inv_send_pedo_steps(indio_dev);
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		if (st->step_counter_wake_l_on)
+			inv_send_pedo_steps(indio_dev);
+		break;
+	case ATTR_DMP_STEP_COUNTER_SEND:
+		if (st->step_counter_l_on || st->step_counter_wake_l_on)
+			_send_pedo_steps(indio_dev);
+		return count;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store() -  calling this function will store current
+ *                        non-dmp parameter settings
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_bias_show() -  calling this function will show current
+ *                        dmp gyro/accel bias.
+ */
+static int _attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int axes, addr, result, dmp_bias;
+	int sensor_type;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		return -ENOSYS;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		axes = 0;
+		addr = D_EXT_GYRO_BIAS_X;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		axes = 1;
+		addr = D_EXT_GYRO_BIAS_Y;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		axes = 2;
+		addr = D_EXT_GYRO_BIAS_Z;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		return -ENODEV;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		axes = 0;
+		addr = st->aut_key_out;
+		sensor_type = -1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = read_be32_from_mem(st, &dmp_bias, addr);
+	if (result)
+		return result;
+	inv_switch_power_in_lp(st, false);
+	if (SENSOR_GYRO == sensor_type)
+		st->input_gyro_dmp_bias[axes] = dmp_bias;
+	else if (SENSOR_ACCEL == sensor_type)
+		st->input_accel_dmp_bias[axes] = dmp_bias;
+	else if (sensor_type != -1)
+		return -EINVAL;
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", dmp_bias);
+}
+
+static ssize_t inv_attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _attr_bias_show(dev, attr, buf);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show() -  calling this function will show current
+ *                        dmp parameters.
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_COMPASS_SCALE:
+		return -ENODEV;
+	case ATTR_COMPASS_SENSITIVITY_X:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[0]);
+	case ATTR_COMPASS_SENSITIVITY_Y:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[1]);
+	case ATTR_COMPASS_SENSITIVITY_Z:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[2]);
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.accel_enable);
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return -ENOSYS;
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_cal_enable);
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->debug_determine_engine_on);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		return -ENOSYS;
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		return -ENOSYS;
+	case ATTR_FIRMWARE_LOADED:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.firmware_loaded);
+	case ATTR_DMP_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.dmp_on);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_EVENT_INT_ON:
+		return snprintf(buf, MAX_WR_SZ,
+			"%d\n", st->chip_config.dmp_event_int_on);
+	case ATTR_DMP_PED_INT_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_on);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_STEP_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.step_thresh);
+	case ATTR_DMP_PED_INT_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_thresh);
+	case ATTR_DMP_PED_INT_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_mode);
+	case ATTR_DMP_SMD_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->smd.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		return -ENOSYS;
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_COMPASS_ENABLE:
+		return -ENODEV;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_wake_l_on);
+	case ATTR_DMP_ACTIVITY_ON:
+		return -ENODEV;
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on);
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return -ENOSYS;
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_COMPASS_MATRIX:
+		return -ENODEV;
+	case ATTR_SECONDARY_NAME:
+		return -ENODEV;
+	case ATTR_DMP_DEBUG_MEM_READ:
+		{
+			int out;
+
+			inv_switch_power_in_lp(st, true);
+			result =
+				read_be32_from_mem(st, &out, debug_mem_read_addr);
+			if (result)
+				return result;
+			inv_switch_power_in_lp(st, false);
+			return snprintf(buf, MAX_WR_SZ, "0x%x\n", out);
+		}
+	case ATTR_DMP_MAGN_ACCURACY:
+		return -ENODEV;
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[2]);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_attr64_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u64 tmp;
+	u32 ped;
+
+	mutex_lock(&st->lock);
+	result = 0;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_steps(st, &ped);
+		result |= inv_read_pedometer_counter(st);
+		tmp = (u64) st->ped.step + (u64) ped;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_time(st, &ped);
+		tmp = (u64) st->ped.time + ((u64) ped) * MS_PER_PED_TICKS;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_COUNTER:
+		tmp = st->ped.last_step_time;
+		break;
+	default:
+		tmp = 0;
+		result = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&st->lock);
+	if (result)
+		return -EINVAL;
+	return snprintf(buf, MAX_WR_SZ, "%lld\n", tmp);
+}
+
+static ssize_t inv_attr64_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u8 d[4] = { 0, 0, 0, 0 };
+	u64 data;
+
+	mutex_lock(&st->lock);
+	if (!st->chip_config.firmware_loaded) {
+		mutex_unlock(&st->lock);
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		mutex_unlock(&st->lock);
+		return result;
+	}
+	result = kstrtoull(buf, 10, &data);
+	if (result)
+		goto attr64_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		result = mem_w(PEDSTD_STEPCTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.step = data;
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		result = mem_w(PEDSTD_TIMECTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.time = data;
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+attr64_store_fail:
+	mutex_unlock(&st->lock);
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+	int test_res = 0;
+	s16 gyro_offset_reg[3];
+	s16 accel_offset_reg[3];
+
+	mutex_lock(&st->lock);
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+
+	/* save the current offset registers */
+	res = inv_read_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+	if (res)
+		goto err_out;
+	/* write initial offset register values */
+	res = inv_write_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (res)
+		goto restore_regs;
+
+	res = inv_switch_power_in_lp(st, false);
+	if (res)
+		goto restore_regs;
+
+	test_res = inv_hw_self_test(st);
+
+restore_regs:
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+	/* restore offset register values */
+	inv_write_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+
+err_out:
+	inv_switch_power_in_lp(st, false);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", test_res);
+}
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+/*
+ * inv_smd_show() -  calling this function showes smd interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_smd_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_activity_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+static ssize_t inv_pick_up_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+static DEVICE_ATTR(poll_smd, S_IRUGO, inv_smd_show, NULL);
+static DEVICE_ATTR(poll_pedometer, S_IRUGO, inv_ped_show, NULL);
+static DEVICE_ATTR(poll_activity, S_IRUGO, inv_activity_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO, inv_tilt_show, NULL);
+static DEVICE_ATTR(poll_pick_up, S_IRUGO, inv_pick_up_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_3quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_THREEQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PEDQ_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_3quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_THREEQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PEDQ_WAKE);
+
+/* debug determine engine related sysfs */
+static IIO_DEVICE_ATTR(debug_anglvel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_gyro_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_GYRO_CAL_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ACCEL_CAL_ENABLE);
+
+static IIO_DEVICE_ATTR(debug_gyro_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_GYRO_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_ACCEL_ENABLE);
+static IIO_DEVICE_ATTR(debug_compass_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_COMPASS_ENABLE);
+static IIO_DEVICE_ATTR(debug_dmp_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ON);
+static IIO_DEVICE_ATTR(debug_dmp_event_int_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_EVENT_INT_ON);
+static IIO_DEVICE_ATTR(debug_mem_read, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_READ);
+static IIO_DEVICE_ATTR(debug_mem_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_WRITE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+static IIO_DEVICE_ATTR(info_firmware_loaded, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_firmware_loaded_store, ATTR_FIRMWARE_LOADED);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+
+static IIO_DEVICE_ATTR(debug_low_power_gyro_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_LOW_POWER_GYRO_ON);
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_cfg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_WRITE_CFG);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+
+static IIO_DEVICE_ATTR(in_accel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_sc_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store, ATTR_DMP_SC_AUTH);
+
+static IIO_DEVICE_ATTR(in_eis_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store, ATTR_DMP_EIS_AUTH);
+
+static IIO_DEVICE_ATTR(debug_determine_engine_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON);
+static IIO_DEVICE_ATTR(misc_gyro_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_GYRO_RECALIBRATION);
+static IIO_DEVICE_ATTR(misc_accel_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_ACCEL_RECALIBRATION);
+static IIO_DEVICE_ATTR(params_accel_calibration_threshold, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD);
+static IIO_DEVICE_ATTR(params_accel_calibration_rate, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE);
+
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_send, S_IRUGO | S_IWUSR, NULL,
+		inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_SEND);
+static IIO_DEVICE_ATTR(in_activity_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_ACTIVITY_ON);
+
+static IIO_DEVICE_ATTR(event_smd_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_SMD_ENABLE);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+
+static IIO_DEVICE_ATTR(params_pedometer_int_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_ON);
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+static IIO_DEVICE_ATTR(params_pedometer_step_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_STEP_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_INT_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_MODE);
+
+static IIO_DEVICE_ATTR(out_pedometer_steps, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_STEPS);
+static IIO_DEVICE_ATTR(out_pedometer_time, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_TIME);
+static IIO_DEVICE_ATTR(out_pedometer_counter, S_IRUGO | S_IWUSR,
+			inv_attr64_show, NULL, ATTR_DMP_PEDOMETER_COUNTER);
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+	&iio_dev_attr_in_sc_auth.dev_attr.attr,
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+	&iio_dev_attr_in_eis_auth.dev_attr.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_debug_mem_read.dev_attr.attr,
+	&iio_dev_attr_debug_mem_write.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_accel_enable.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_event_int_on.dev_attr.attr,
+	&iio_dev_attr_debug_low_power_gyro_on.dev_attr.attr,
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+	&iio_dev_attr_debug_cfg_write.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_on.dev_attr.attr,
+	&iio_dev_attr_debug_accel_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_accel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_determine_engine_on.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_enable.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_anglvel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_compass_enable.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_step_thresh.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_thresh.dev_attr.attr,
+	&iio_dev_attr_misc_gyro_recalibration.dev_attr.attr,
+	&iio_dev_attr_misc_accel_recalibration.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_threshold.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_dmp_attributes[] = {
+	&iio_dev_attr_in_calib_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_info_firmware_loaded.dev_attr.attr,
+	&iio_dev_attr_in_activity_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_3quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_3quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_rate.dev_attr.attr,
+	&dev_attr_poll_activity.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_tilt.attr,
+	&dev_attr_poll_pick_up.attr,
+	&iio_dev_attr_params_pedometer_int_on.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_mode.dev_attr.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_send.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_steps.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_time.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_counter.dev_attr.attr,
+};
+
+static const struct attribute *inv_smd_attributes[] = {
+	&dev_attr_poll_smd.attr,
+	&iio_dev_attr_event_smd_enable.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+					ARRAY_SIZE(inv_debug_attributes) +
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_dmp_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+					ARRAY_SIZE(inv_pedometer_attributes) +
+					ARRAY_SIZE(inv_smd_attributes) +
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm20608d"))
+		st->chip_type = ICM20608D;
+	else if (!strcmp(name, "icm20789"))
+		st->chip_type = ICM20789;
+	else
+		return -EPERM;
+	if (st->chip_type == ICM20789 && st->bus_type != BUS_I2C) {
+		dev_err(st->dev, "icm20789 only supported on i2c bus\n");
+		return -ENODEV;
+	}
+	st->dmp_image_size = DMP_IMAGE_SIZE_20608D;
+	st->dmp_start_address = DMP_START_ADDR_20608D;
+	st->aut_key_in = SC_AUT_INPUT_20608D;
+	st->aut_key_out = SC_AUT_OUTPUT_20608D;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_smd_attributes,
+				sizeof(inv_smd_attributes));
+	t_ind += ARRAY_SIZE(inv_smd_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_dmp_attributes,
+				sizeof(inv_dmp_attributes));
+	t_ind += ARRAY_SIZE(inv_dmp_attributes);
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	if (st->chip_type == ICM20789) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+		st->aux_dev = i2c_new_device(st->sl_handle,
+					     &inv_icp101xx_i2c_info);
+		if (st->aux_dev == NULL)
+			dev_err(st->dev, "error adding icp101xx device\n");
+#else
+		st->aux_dev = i2c_new_client_device(st->sl_handle,
+						    &inv_icp101xx_i2c_info);
+		if (IS_ERR(st->aux_dev))
+			dev_err(st->dev, "error %d adding icp101xx device\n",
+				PTR_ERR(st->aux_dev));
+#endif
+	}
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+/*
+ * inv_dmp_firmware_write() -  calling this function will load the firmware.
+ */
+static ssize_t inv_dmp_firmware_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	u32 crc_value;
+/* /system/vendor/firmware/inv_dmpfirmware.bin */
+/* from vanadium-host-hal/sources/vendor/invensense/hammerhead/proprietary */
+#ifndef INV_IPL
+#define FIRMWARE_CRC_20608D           0xccfe3786
+#else
+#define FIRMWARE_CRC_20608D           0x954601ed
+#endif
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->firmware) {
+		st->firmware = kmalloc(st->dmp_image_size, GFP_KERNEL);
+		if (!st->firmware) {
+			pr_err("no memory while loading firmware\n");
+			return -ENOMEM;
+		}
+	}
+	offset = pos;
+	memcpy(st->firmware + pos, buf, size);
+	if ((!size) && (st->dmp_image_size != pos)) {
+		pr_err("wrong size for DMP firmware 0x%08x vs 0x%08x\n",
+			offset, st->dmp_image_size);
+		kfree(st->firmware);
+		st->firmware = 0;
+		return -EINVAL;
+	}
+	if (st->dmp_image_size == (pos + size)) {
+		result = ~crc32(~0, st->firmware, st->dmp_image_size);
+		crc_value = FIRMWARE_CRC_20608D;
+		pr_info("%s: firmware CRC actual:0x%08x expected:0x%08x\n",
+			__func__, result, crc_value);
+		if (crc_value != result) {
+			pr_err("%s: firmware CRC error\n", __func__);
+			return -EINVAL;
+		} else
+			pr_info("%s: CRC matched\n", __func__);
+
+		mutex_lock(&st->lock);
+		result = inv_firmware_load(st);
+		kfree(st->firmware);
+		st->firmware = 0;
+		mutex_unlock(&st->lock);
+		if (result) {
+			pr_err("firmware load failed\n");
+			return result;
+		}
+	}
+
+	return size;
+}
+
+static ssize_t inv_dmp_firmware_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&st->lock);
+	offset = off;
+	result = inv_dmp_read(st, offset, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+int inv_accel_covariance_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int i;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (size != ACCEL_COVARIANCE_SIZE)
+		return -EINVAL;
+
+	for (i = 0; i < COVARIANCE_SIZE; i++)
+		memcpy((u8 *) &st->accel_covariance[i],
+			&buf[i * sizeof(int)], sizeof(int));
+
+	return size;
+}
+
+static int inv_dmp_covar_read(struct inv_mpu_state *st,
+			int off, int size, u8 *buf)
+{
+	int data, result, i;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+	for (i = 0; i < COVARIANCE_SIZE * sizeof(int); i += sizeof(int)) {
+		result = read_be32_from_mem(st, (u32 *) &data, off + i);
+		if (result)
+			return result;
+		memcpy(buf + i, (u8 *) &data, sizeof(int));
+	}
+
+	return 0;
+}
+
+int inv_accel_covariance_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&st->lock);
+	result = inv_dmp_covar_read(st, ACCEL_COVARIANCE, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ *  inv_create_dmp_sysfs() - create binary sysfs dmp entry.
+ */
+static struct bin_attribute dmp_firmware = {
+	.attr = {
+		.name = "misc_bin_dmp_firmware",
+		.mode = S_IRUGO | S_IWUGO},
+	.read = inv_dmp_firmware_read,
+	.write = inv_dmp_firmware_write,
+};
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	int result = 0;
+	struct inv_mpu_state *st = iio_priv(ind);
+
+	if (st->chip_type == ICM20608D || st->chip_type == ICM20789) {
+		dmp_firmware.size = st->dmp_image_size;
+		result = sysfs_create_bin_file(&ind->dev.kobj, &dmp_firmware);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_dmp_fifo.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_dmp_fifo.c
new file mode 100644
index 000000000000..b405ff6874a5
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_dmp_fifo.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2017-2018 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_get_step_params(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	st->prev_steps = st->curr_steps;
+	result |= read_be32_from_mem(st, &st->curr_steps, PEDSTD_STEPCTR);
+	result |= read_be32_from_mem(st, &st->ts_algo.start_dmp_counter,
+								DMPRATE_CNTR);
+	result |= inv_switch_power_in_lp(st, false);
+
+	return result;
+}
+/**
+  * static int inv_prescan_data(struct inv_mpu_state *st, u8 * dptr, int len)
+  *  prescan data to know what type of data and how many samples of data
+  *  in current FIFO reading.
+*/
+static int inv_prescan_data(struct inv_mpu_state *st, u8 *dptr, int len)
+{
+	int res, pk_size, i;
+	bool done_flag;
+	u16 hdr;
+
+	done_flag = false;
+	st->header_count = 0;
+	st->step_det_count = 0;
+	st->ts_algo.calib_counter++;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].count = 0;
+	while (!done_flag) {
+		if (len > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			if (!hdr) {
+				pr_err("error header zero\n");
+				st->left_over_size = 0;
+				return -EINVAL;
+			}
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				if (!st->chip_config.is_asleep)
+					pr_err
+				("prescan error in header parsing=%x size=%d\n",
+				hdr, len);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (len >= pk_size) {
+				inv_pre_parse_packet(st, hdr, dptr + HEADER_SZ);
+				len -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	if (st->step_det_count)
+		inv_get_step_params(st);
+	inv_bound_timestamp(st);
+
+	return 0;
+}
+
+int inv_process_dmp_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size;
+	u8 *dptr, *d;
+	u16 hdr;
+	u8 data[2];
+	bool done_flag;
+
+	st->ts_algo.last_run_time = get_time_ns();
+	res = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, data);
+	if (res) {
+		pr_debug("read REG_FIFO_COUNT_H failed\n");
+		return res;
+	}
+	fifo_count = be16_to_cpup((__be16 *) (data));
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+
+	if (fifo_count >= HARDWARE_FIFO_SIZE) {
+		pr_warn("fifo overflow fifo_count=%d\n", fifo_count);
+		return -EOVERFLOW;
+	}
+
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		pr_debug("left over size error\n");
+		return -EINVAL;
+	}
+
+	if (st->left_over_size > 0)
+		memcpy(d, st->left_over, st->left_over_size);
+
+	dptr = d + st->left_over_size;
+	total_bytes = fifo_count;
+	while (total_bytes > 0) {
+		if (total_bytes < MAX_FIFO_READ_SIZE)
+			tmp = total_bytes;
+		else
+			tmp = MAX_FIFO_READ_SIZE;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_debug("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+	dptr = d;
+	total_bytes = fifo_count + st->left_over_size;
+	res = inv_prescan_data(st, dptr, total_bytes);
+	if (res) {
+		pr_info("prescan failed\n");
+		return -EINVAL;
+	}
+	dptr = d;
+	done_flag = false;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n", d[0], d[1], d[2],
+						d[3], d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n", d[8], d[9], d[10],
+					d[11], d[12], d[13], d[14], d[15]);
+	while (!done_flag) {
+		if (total_bytes > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				pr_err
+		("processing error in header parsing=%x fifo_count= %d\n",
+		hdr, fifo_count);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (total_bytes >= pk_size) {
+				inv_parse_packet(indio_dev, hdr, dptr + HEADER_SZ);
+				total_bytes -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	st->left_over_size = total_bytes;
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		return -EINVAL;
+	}
+
+	if (st->left_over_size)
+		memcpy(st->left_over, dptr, st->left_over_size);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_iio_reg_20608.h b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_iio_reg_20608.h
new file mode 100644
index 000000000000..e6ff238da1b0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_iio_reg_20608.h
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_20608_H_
+#define _INV_MPU_IIO_REG_20608_H_
+
+/* Uncomment to use Gyro LN mode rather than LP mode */
+//#define USE_GYRO_LN_MODE
+
+/*register and associated bit definition*/
+#define REG_XA_OFFS_H		0x77
+#define REG_YA_OFFS_H		0x7A
+#define REG_ZA_OFFS_H           0x7D
+#define REG_XA_OFFS_L_TC        0x7
+#define REG_PRODUCT_ID          0xC
+#define REG_ST_GCT_X            0xD
+#define REG_XG_OFFS_USR_H        0x13
+#define REG_YG_OFFS_USR_H        0x15
+#define REG_ZG_OFFS_USR_H        0x17
+#define REG_SAMPLE_RATE_DIV     0x19
+
+#define REG_CONFIG              0x1A
+#define EXT_SYNC_SET                      8
+
+#define REG_GYRO_CONFIG		0x1B
+#define BITS_SELF_TEST_EN		0xE0
+#define SHIFT_GYRO_FS_SEL		0x03
+
+#define REG_ACCEL_CONFIG		0x1C
+#define SHIFT_ACCEL_FS			0x03
+#define REG_ACCEL_MOT_THR       0x1F
+#define REG_ACCEL_MOT_DUR       0x20
+
+#define REG_ACCEL_CONFIG_2  0x1D
+#define BIT_ACCEL_FCHOCIE_B              0x08
+
+#define REG_FIFO_EN		0x23
+#define BITS_TEMP_FIFO_EN                   0x80
+#define BITS_GYRO_FIFO_EN		    0x70
+#define BIT_ACCEL_FIFO_EN	            0x08
+#define BIT_SLV_0_FIFO_EN                   0x01
+
+#define REG_I2C_SLV0_ADDR       0x25
+#define REG_I2C_SLV0_REG        0x26
+#define REG_I2C_SLV0_CTRL       0x27
+#define REG_I2C_SLV1_ADDR       0x28
+#define REG_I2C_SLV1_REG        0x29
+#define REG_I2C_SLV1_CTRL       0x2A
+#define REG_I2C_SLV2_ADDR       0x2B
+#define REG_I2C_SLV2_REG        0x2C
+#define REG_I2C_SLV2_CTRL       0x2D
+
+#define REG_I2C_SLV4_CTRL       0x34
+
+#define REG_FSYNC_INT		0x36
+#define BIT_FSYNC_INT                   0x80
+
+#define REG_INT_PIN_CFG		0x37
+#define BIT_BYPASS_EN		0x2
+
+#define REG_INT_ENABLE		0x38
+#define BIT_WOM_INT_EN		        0xe0
+#define BIT_FIFO_OFLOW_EN	        0x10
+#define BIT_FSYNC_INT_EN	        0x8
+#define BIT_DMP_INT_EN		        0x02
+#define BIT_DATA_RDY_EN		        0x01
+
+#define REG_DMP_INT_STATUS      0x39
+#define BIT_DMP_INT_CI          0x01
+
+#define REG_INT_STATUS          0x3A
+#define BIT_WOM_INT                    0xE0
+
+#define REG_RAW_ACCEL           0x3B
+#define REG_EXT_SLV_SENS_DATA_00         0x49
+
+#define REG_ACCEL_INTEL_STATUS  0x61
+
+#define REG_I2C_SLV0_DO          0x63
+#define REG_I2C_SLV1_DO          0x64
+#define REG_I2C_SLV2_DO          0x65
+
+#define REG_I2C_MST_DELAY_CTRL   0x67
+#define BIT_I2C_SLV1_DELAY_EN                   0x02
+#define BIT_I2C_SLV0_DELAY_EN                   0x01
+
+#define REG_USER_CTRL            0x6A
+#define BIT_COND_RST				0x01
+#define BIT_FIFO_RST				0x04
+#define BIT_DMP_RST				0x08
+#define BIT_I2C_IF_DIS				0x10
+#define BIT_I2C_MST_EN                          0x20
+#define BIT_FIFO_EN				0x40
+#define BIT_DMP_EN				0x80
+
+#define REG_PWR_MGMT_1	         0x6B
+#define BIT_H_RESET				0x80
+#define BIT_SLEEP				0x40
+#define BIT_LP_EN                       	0x20
+#define BIT_CLK_PLL				0x01
+#define BIT_CLK_MASK				0x07
+
+#define REG_PWR_MGMT_2			0x6C
+#define BIT_PWR_ACCEL_STBY		0x38
+#define BIT_PWR_GYRO_STBY		0x07
+#define BIT_PWR_ALL_OFF			0x3F
+#define BIT_FIFO_LP_EN			0x80
+#define BIT_DMP_LP_DIS			0x40
+
+#define REG_MEM_BANK_SEL		0x6D
+#define REG_MEM_START_ADDR	0x6E
+#define REG_MEM_R_W				0x6F
+#define REG_PRGM_START_ADDRH	0x70
+
+#define REG_FIFO_COUNT_H        0x72
+#define REG_FIFO_R_W            0x74
+#define REG_WHO_AM_I              0x75
+
+#define REG_6500_XG_ST_DATA     0x0
+#define REG_6500_XA_ST_DATA     0xD
+#define REG_6500_XA_OFFS_H      0x77
+#define REG_6500_YA_OFFS_H      0x7A
+#define REG_6500_ZA_OFFS_H      0x7D
+#define REG_6500_ACCEL_CONFIG2  0x1D
+#define BIT_ACCEL_FCHOCIE_B              0x08
+#define BIT_FIFO_SIZE_1K                 0x40
+
+#define REG_LP_MODE_CFG		0x1E
+#define BIT_GYRO_CYCLE			0x80
+#define BIT_G_AVGCFG_MASK		0x70
+#define BIT_LPOSC_CLKSEL_MASK	0x0F
+
+#define REG_6500_LP_ACCEL_ODR   0x1E
+#define REG_6500_ACCEL_WOM_THR  0x1F
+
+#define REG_SELF_TEST1                0x00
+#define REG_SELF_TEST2                0x01
+#define REG_SELF_TEST3                0x02
+#define REG_SELF_TEST4                0x0D
+#define REG_SELF_TEST5                0x0E
+#define REG_SELF_TEST6                0x0F
+
+#define INV_MPU_BIT_SLV_EN      0x80
+#define INV_MPU_BIT_BYTE_SW     0x40
+#define INV_MPU_BIT_REG_DIS     0x20
+#define INV_MPU_BIT_GRP         0x10
+#define INV_MPU_BIT_I2C_READ    0x80
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET  0x4000
+#define GYRO_ACCURACY_SET   0x2000
+#define CPASS_ACCURACY_SET  0x1000
+#define FSYNC_SET           0x0800
+#define FLIP_PICKUP_SET     0x0400
+#define BATCH_MODE_EN       0x0100
+
+#define INV_FSYNC_TEMP_BIT     0x1
+
+#define ACCEL_COVARIANCE 0
+
+/* dummy definitions */
+#define BANK_SEL_0                      0x00
+#define BANK_SEL_1                      0x10
+#define BANK_SEL_2                      0x20
+#define BANK_SEL_3                      0x30
+
+/* data definitions */
+#define BYTES_PER_SENSOR         6
+#define BYTES_FOR_COMPASS        10
+#define FIFO_COUNT_BYTE          2
+#define HARDWARE_FIFO_SIZE       512
+#define FIFO_SIZE                (HARDWARE_FIFO_SIZE * 7 / 8)
+#define POWER_UP_TIME            100
+#define REG_UP_TIME_USEC         5000
+#define DMP_RESET_TIME           20
+#define GYRO_ENGINE_UP_TIME      50
+#define MPU_MEM_BANK_SIZE        256
+#define IIO_BUFFER_BYTES         8
+#define HEADERED_NORMAL_BYTES    8
+#define HEADERED_Q_BYTES         16
+#define LEFT_OVER_BYTES          128
+#define BASE_SAMPLE_RATE         1000
+#define DRY_RUN_TIME             50
+#define INV_ICM20608_GYRO_START_TIME 80
+#define INV_ICM20608_ACCEL_START_TIME 10
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY         3
+#else
+#define DEFAULT_ACCURACY         1
+#endif
+
+/* enum for sensor
+   The sequence is important.
+   It represents the order of apperance from DMP */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_SIXQ,
+	SENSOR_THREEQ,
+	SENSOR_PEDQ,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_filter_e {
+	INV_FILTER_256HZ_NOLPF2 = 0,
+	INV_FILTER_188HZ,
+	INV_FILTER_98HZ,
+	INV_FILTER_42HZ,
+	INV_FILTER_20HZ,
+	INV_FILTER_10HZ,
+	INV_FILTER_5HZ,
+	INV_FILTER_2100HZ_NOLPF,
+	NUM_FILTER
+};
+
+#define MPU_DEFAULT_DMP_FREQ     200
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 2)
+
+#define DMP_OFFSET               0x20
+#ifndef INV_IPL
+#define DMP_IMAGE_SIZE_20608D         (3543 + DMP_OFFSET)
+#else
+#define DMP_IMAGE_SIZE_20608D         (3532 + DMP_OFFSET)
+#endif
+
+/* initial rate is important. For DMP mode, it is set as 1 since DMP decimate*/
+#define MPU_INIT_SENSOR_RATE     1
+#define MIN_MST_ODR_CONFIG       4
+#define MAX_MST_ODR_CONFIG       5
+#define MIN_COMPASS_RATE         4
+#define MAX_COMPASS_RATE    100
+#define MAX_MST_NON_COMPASS_ODR_CONFIG 7
+#define THREE_AXES               3
+#define NINE_ELEM                (THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT           16
+#define DMP_DIVIDER              (BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define MAX_5_BIT_VALUE          0x1F
+#define BAD_COMPASS_DATA         0x7FFF
+#define BAD_CAL_COMPASS_DATA     0x7FFF0000
+#define DEFAULT_BATCH_RATE       400
+#define DEFAULT_BATCH_TIME    (MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+#define NINEQ_DEFAULT_COMPASS_RATE 25
+#define DMP_2G_VALUE             0x2000000
+
+#define DATA_AKM_99_BYTES_DMP  10
+#define DATA_AKM_89_BYTES_DMP  9
+#define DATA_ALS_BYTES_DMP     8
+#define APDS9900_AILTL_REG      0x04
+#define BMP280_DIG_T1_LSB_REG                0x88
+#define TEMPERATURE_SCALE  3340827L
+#define TEMPERATURE_OFFSET 1376256L
+#define SECONDARY_INIT_WAIT 100
+#define AK99XX_SHIFT                    23
+#define AK89XX_SHIFT                    22
+
+/* this is derived from 1000 divided by 55, which is the pedometer
+   running frequency */
+#define MS_PER_PED_TICKS         18
+
+/* data limit definitions */
+#define MIN_FIFO_RATE            4
+#define MAX_FIFO_RATE            MPU_DEFAULT_DMP_FREQ
+#define MAX_DMP_OUTPUT_RATE      MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM              8192
+#define MAX_PRS_RATE             281
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+#endif
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_init_20608.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_init_20608.c
new file mode 100644
index 000000000000..2215640afdf0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_init_20608.c
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_set_dmp(struct inv_mpu_state *st)
+{
+	int result = 0;
+
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH,
+				st->dmp_start_address >> 8);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH + 1,
+				st->dmp_start_address & 0xff);
+
+	return result;
+}
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+
+	inv_plat_single_write(st, REG_CONFIG, 3);
+
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(0);
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+				st->chip_config.fsr << SHIFT_GYRO_FS_SEL);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+				st->chip_config.accel_fs << SHIFT_ACCEL_FS);
+	return result;
+}
+
+// dummy for 20602
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = ACCEL_DATA_SZ;
+	st->sensor[SENSOR_GYRO].sample_size = GYRO_DATA_SZ;
+	st->sensor[SENSOR_SIXQ].sample_size = QUAT6_DATA_SZ;
+	st->sensor[SENSOR_THREEQ].sample_size = LPQ_DATA_SZ;
+	st->sensor[SENSOR_PEDQ].sample_size = PQUAT6_DATA_SZ;
+
+	st->sensor[SENSOR_ACCEL].odr_addr = ODR_ACCEL;
+	st->sensor[SENSOR_GYRO].odr_addr = ODR_GYRO;
+	st->sensor[SENSOR_SIXQ].odr_addr = ODR_QUAT6;
+	st->sensor[SENSOR_THREEQ].odr_addr = ODR_LPQ;
+	st->sensor[SENSOR_PEDQ].odr_addr = ODR_PQUAT6;
+
+	st->sensor[SENSOR_ACCEL].counter_addr = ODR_CNTR_ACCEL;
+	st->sensor[SENSOR_GYRO].counter_addr = ODR_CNTR_GYRO;
+	st->sensor[SENSOR_SIXQ].counter_addr = ODR_CNTR_QUAT6;
+	st->sensor[SENSOR_THREEQ].counter_addr = ODR_CNTR_LPQ;
+	st->sensor[SENSOR_PEDQ].counter_addr = ODR_CNTR_PQUAT6;
+
+	st->sensor[SENSOR_ACCEL].output = ACCEL_SET;
+	st->sensor[SENSOR_GYRO].output = GYRO_SET;
+	st->sensor[SENSOR_SIXQ].output = QUAT6_SET;
+	st->sensor[SENSOR_THREEQ].output = LPQ_SET;
+	st->sensor[SENSOR_PEDQ].output = PQUAT6_SET;
+
+	st->sensor[SENSOR_SIXQ].a_en = true;
+	st->sensor[SENSOR_PEDQ].a_en = true;
+
+	st->sensor[SENSOR_SIXQ].g_en = true;
+	st->sensor[SENSOR_THREEQ].g_en = true;
+	st->sensor[SENSOR_PEDQ].g_en = true;
+
+	st->sensor[SENSOR_SIXQ].c_en = false;
+	st->sensor[SENSOR_PEDQ].c_en = false;
+
+	st->sensor[SENSOR_SIXQ].p_en = false;
+	st->sensor[SENSOR_PEDQ].p_en = false;
+
+	st->sensor[SENSOR_SIXQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_THREEQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_PEDQ].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_THREEQ].base = SENSOR_THREEQ;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_PEDQ;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_PEDQ;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].sample_size =
+			ACCEL_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].sample_size =
+			GYRO_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].sample_size =
+			CPASS_ACCURACY_SZ;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].output = ACCEL_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].output = GYRO_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].output =
+			CPASS_ACCURACY_SET;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].header = ACCEL_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].header = GYRO_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].header =
+			COMPASS_ACCURACY_HDR;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = BYTE_MODE;
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+	res = inv_set_dmp(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	/* enable i2c bypass mode for icm20789 */
+	if (st->chip_type == ICM20789) {
+		result = inv_plat_read(st, REG_INT_PIN_CFG, 1, &v);
+		if (result)
+			return result;
+		v |= BIT_BYPASS_EN;
+		result = inv_plat_single_write(st, REG_INT_PIN_CFG, v);
+		if (result)
+			return result;
+	}
+
+	result = inv_read_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 1;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_load_dmp.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_load_dmp.c
new file mode 100644
index 000000000000..9866eb61b34d
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_load_dmp.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "../inv_mpu_iio.h"
+
+static int inv_load_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size;
+	int result, size;
+	u16 memaddr;
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_w(memaddr, write_size, data);
+		if (result) {
+			pr_err("error writing firmware:%d\n", bank);
+			pr_info("%s: error writing firmware %d\n", __func__,
+				bank);
+			return result;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+
+	pr_info("%s: DMP load firmware successed DMP_Size %d\n",
+		__func__, st->dmp_image_size);
+	return 0;
+}
+
+static int inv_verify_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size, size;
+	int result;
+	u16 memaddr;
+	u8 firmware[MPU_MEM_BANK_SIZE];
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_r(memaddr, write_size, firmware);
+		if (result)
+			return result;
+		if (0 != memcmp(firmware, data, write_size)) {
+			pr_err("load data error, bank=%d\n", bank);
+			pr_info("%s: varification, load data error bank %d\n",
+				__func__, bank);
+			return -EINVAL;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+	return 0;
+}
+
+/*
+ * inv_firmware_load() -  calling this function will load the firmware.
+ */
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		pr_info("%s: load firmware set power error\n", __func__);
+		pr_err("load firmware set power error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_stop_dmp(st);
+	if (result) {
+		pr_info("%s: load firmware : stop dmp error\n", __func__);
+		pr_err("load firmware:stop dmp error\n");
+		goto firmware_write_fail;
+	}
+	usleep_range(10 * 1000, 20 * 1000); /* to ensure DMP stops */
+	result = inv_load_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:load firmware error\n", __func__);
+		pr_err("load firmware:load firmware eror\n");
+		goto firmware_write_fail;
+	}
+	result = inv_verify_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:verify firmware error\n", __func__);
+		pr_err("load firmware:verify firmware error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_setup_dmp_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:setup dmp error\n", __func__);
+		pr_err("load firmware:setup dmp error\n");
+	}
+firmware_write_fail:
+	result |= inv_set_power(st, false);
+	if (result) {
+		pr_info("%s: load firmware:shuting down power error\n",
+			__func__);
+		pr_err("load firmware:shuting down power error\n");
+		return result;
+	}
+
+	st->chip_config.firmware_loaded = 1;
+
+	pr_info("%s: load firmware successed\n", __func__);
+	return 0;
+}
+
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	int read_size, i, result;
+	u16 addr;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+
+	addr = off;
+	i = 0;
+	while (size > 0) {
+		if (addr % MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE
+				- (addr % MAX_DMP_READ_SIZE);
+		else if (size > MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE;
+		else
+			read_size = size;
+
+		result = mem_r(addr, read_size, &buf[i]);
+		if (result)
+			return result;
+
+		addr += read_size;
+		i += read_size;
+		size -= read_size;
+	}
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_parsing_20608.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_parsing_20608.c
new file mode 100644
index 000000000000..327372e83ee0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_parsing_20608.c
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static char iden[] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };
+static char fsync_delay[] = {4, 5, 1, 2, 3};
+
+static int inv_push_accuracy(struct iio_dev *indio_dev, int ind, u16 accur)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 buf[IIO_BUFFER_BYTES];
+	u16 hdr;
+
+	hdr = st->sensor_accuracy[ind].header;
+	if (st->sensor_acurracy_flag[ind]) {
+		if (!accur)
+			accur = DEFAULT_ACCURACY;
+		else
+			st->sensor_acurracy_flag[ind] = 0;
+	}
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(buf + sizeof(hdr), &accur, sizeof(accur));
+	iio_push_to_buffers(indio_dev, buf);
+
+	pr_debug("Accuracy for sensor [%d] is [%d]\n", ind, accur);
+
+	return 0;
+}
+
+static int inv_process_gyro(struct iio_dev *indio_dev, u8 *d, u64 t)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	s32 raw[3];
+	s32 bias[3];
+	s32 scaled_bias[3];
+	s32 calib[3];
+	int i;
+#define BIAS_UNIT 2859
+
+	for (i = 0; i < 3; i++)
+		raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+
+	for (i = 0; i < 3; i++)
+		bias[i] = be32_to_int(d + 6 + i * 4);
+
+	for (i = 0; i < 3; i++) {
+		scaled_bias[i] = ((bias[i] << 10) / BIAS_UNIT) << 5;
+		calib[i] = (raw[i] << 15) - scaled_bias[i];
+	}
+
+	if ((scaled_bias[0] != st->gyro_bias[0]) && scaled_bias[0]) {
+		for (i = 0; i < 3; i++)
+			st->gyro_bias[i] = scaled_bias[i];
+		inv_push_accuracy(indio_dev, SENSOR_GYRO_ACCURACY, 3);
+	}
+
+	inv_push_gyro_data(indio_dev, raw, calib, t);
+
+	return 0;
+}
+
+static int inv_check_fsync(struct inv_mpu_state *st, u8 fsync_status)
+{
+	if (!st->chip_config.eis_enable)
+		return 0;
+	if ((fsync_status & INV_FSYNC_TEMP_BIT) && (st->eis.prev_state == 0)) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	} else if (fsync_status & INV_FSYNC_TEMP_BIT) {
+		st->eis.prev_state = 1;
+	} else {
+		st->eis.prev_state = 0;
+	}
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i;
+	s32 raw[3];
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st, d[1]);
+		break;
+	case SENSOR_GYRO:
+		inv_process_gyro(indio_dev, d, t);
+		break;
+	case SENSOR_SIXQ:
+		inv_convert_and_push_16bytes(indio_dev, ind, d + 2, t, iden);
+		break;
+	case SENSOR_THREEQ:
+                inv_convert_and_push_16bytes(indio_dev, ind, d + 2, t, iden);
+                break;
+	case SENSOR_PEDQ:
+		inv_convert_and_push_8bytes(indio_dev, ind, d, t, iden);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+int inv_get_packet_size(struct inv_mpu_state *st, u16 hdr,
+			       u32 *pk_size, u8 *dptr)
+{
+	int i, size;
+
+	size = HEADER_SZ;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if ((hdr & ~PED_STEPIND_SET) == st->sensor[i].output) {
+			if (st->sensor[i].on)
+				size += st->sensor[i].sample_size;
+			else
+				return -EINVAL;
+		}
+	}
+
+	if (hdr == PED_STEPDET_SET) {
+		if (st->chip_config.step_detector_on) {
+			size += HEADER_SZ;
+			size += PED_STEPDET_TIMESTAMP_SZ;
+		} else {
+			pr_err("ERROR: step detector should not be here\n");
+			return -EINVAL;
+		}
+	}
+	if (hdr == FSYNC_HDR) {
+		if (st->chip_config.eis_enable) {
+			size += FSYNC_PK_SZ;
+		} else {
+			pr_err("ERROR: eis packet should not be here\n");
+			return -EINVAL;
+		}
+	}
+
+	*pk_size = size;
+
+	return 0;
+}
+
+int inv_parse_packet(struct iio_dev *indio_dev, u16 hdr, u8 *dptr)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i;
+	u64 t;
+	bool data_header;
+	u16 delay;
+
+	t = 0;
+	pr_debug("hdr= %x\n", hdr);
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if ((hdr & ~PED_STEPIND_SET) == st->sensor[i].output) {
+			inv_get_dmp_ts(st, i);
+			st->sensor[i].sample_calib++;
+			inv_push_sensor(indio_dev, i, st->sensor[i].ts, dptr);
+			dptr += st->sensor[i].sample_size;
+			t = st->sensor[i].ts;
+			data_header = true;
+		}
+	}
+	if (data_header)
+		st->header_count--;
+	if (hdr == PED_STEPDET_SET) {
+		dptr += HEADER_SZ;
+		inv_process_step_det(indio_dev, dptr);
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+		st->step_det_count--;
+	}
+
+	if (hdr == FSYNC_HDR) {
+		st->eis.current_sync = true;
+		st->eis.eis_triggered = true;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+		delay = be16_to_cpup((__be16 *) (dptr));
+		delay ^= 0x7bcf;
+		if (delay > 4) {
+			pr_info("ERROR FSYNC value= %d\n", delay);
+			delay = 4;
+		}
+		st->eis.fsync_delay = fsync_delay[delay];
+		dptr += FSYNC_PK_SZ;
+	}
+
+	return 0;
+}
+
+int inv_pre_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr)
+{
+	int i;
+	bool data_header;
+
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if ((hdr & ~PED_STEPIND_SET) == st->sensor[i].output) {
+			st->sensor[i].count++;
+			dptr += st->sensor[i].sample_size;
+			data_header = true;
+		}
+	}
+	if (data_header)
+		st->header_count++;
+	if (hdr == PED_STEPDET_SET) {
+		st->step_det_count++;
+		dptr += HEADER_SZ;
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+	}
+	if (hdr == FSYNC_HDR)
+		dptr += FSYNC_PK_SZ;
+
+	return 0;
+}
+
+static int inv_process_dmp_interrupt(struct iio_dev *indio_dev, u8 dmp_int_status)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, step;
+
+#define DMP_INT_SMD		0x04
+#define DMP_INT_PED		0x08
+
+	if ((!st->smd.on) && (!st->ped.on))
+		return 0;
+
+	if (dmp_int_status & DMP_INT_SMD) {
+		pr_info("Sinificant motion detected\n");
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_smd");
+		st->smd.on = false;
+		st->trigger_state = EVENT_TRIGGER;
+		inv_check_sensor_on(st);
+		set_inv_enable(indio_dev);
+		st->wake_sensor_received = true;
+	}
+
+	if (st->ped.int_on) {
+		if (dmp_int_status & DMP_INT_PED) {
+			if (st->ped.int_mode) {
+				result = inv_get_pedometer_steps(st, &step);
+				if (result) {
+					pr_info("Failed to read step count\n");
+					return result;
+				}
+				inv_send_steps(indio_dev, step, st->ts_algo.last_run_time);
+				st->prev_steps = step;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int i;
+	u8 d[1];
+
+#define DMP_INT_FIFO	0x01
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+
+	if (st->chip_config.is_asleep)
+		goto end_read_fifo;
+
+	result = inv_plat_read(st, REG_DMP_INT_STATUS, 1, d);
+	if (result) {
+		pr_info("REG_DMP_INT_STATUS result [%d]\n", result);
+		goto end_read_fifo;
+	}
+
+	st->ts_algo.last_run_time = get_time_ns();
+	st->wake_sensor_received = false;
+	st->activity_size = 0;
+
+	/* 20608 is operating under non low power mode, no need to switch */
+	result = inv_process_dmp_interrupt(indio_dev, d[0]);
+	if (result)
+		goto end_read_fifo;
+
+	if (!(d[0] & DMP_INT_FIFO))
+		goto end_read_fifo;
+
+	result = inv_process_dmp_data(indio_dev);
+
+	/* enforce clock source switch after read FIFO */
+	result |= inv_plat_read(st, REG_PWR_MGMT_1, 1, d);
+	result |= inv_plat_single_write(st, REG_PWR_MGMT_1, d[0]);
+
+	if (st->activity_size > 0)
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_activity");
+	if (result)
+		goto err_reset_fifo;
+
+end_read_fifo:
+	mutex_unlock(&st->lock);
+
+	/* set wake_sensor_received flag when streaming is enabled along with
+	 * any wakeup gesture sensor which is reported as FIFO data packet
+	 */
+	if (st->step_detector_wake_l_on) {
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on) {
+				st->wake_sensor_received = true;
+				break;
+			}
+		}
+	}
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		st->wake_sensor_received = false;
+		if (inv_process_dmp_data(indio_dev))
+			pr_err("error on batch.. need reset fifo\n");
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_selftest_20608.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_selftest_20608.c
new file mode 100644
index 000000000000..2ce62aa2dcae
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_selftest_20608.c
@@ -0,0 +1,767 @@
+/*
+ * Copyright (C) 2017-2018 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* register settings */
+#define DEF_SELFTEST_GYRO_SENS		(32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS			20
+#define SELFTEST_WAIT_TIME		(MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME		20
+#define DEF_GYRO_SCALE			131
+#define DEF_ST_PRECISION		1000
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ST_SCALE			32768
+#define DEF_ST_TRY_TIMES		2
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define DEF_ST_SAMPLES			200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN	500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX	1500
+#define DEF_GYRO_CT_SHIFT_DELTA		500
+
+#define SENSOR_UP_TIME			30
+#define REG_UP_TIME			2
+
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ACCEL_ST_SHIFT_DELTA	500
+#define ACCEL_ST_AL_MIN			((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+					/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX			((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+					/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+#define THREE_AXIS			3
+#define DEF_ST_MPU6500_ACCEL_LPF	2
+#define DEF_SELFTEST_SAMPLE_RATE	0 /* 1000Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_LP	3 /* 250Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_ACC_LP	10 /* 250Hz LPOSC_CLKSEL */
+#define INV_MPU_SAMPLE_RATE_CHANGE_STABLE	50
+#define DEF_SELFTEST_6500_ACCEL_FS	(0 << 3)
+#define DEF_SELFTEST_GYRO_FS		(0 << 3)
+#define DEF_ST_6500_STABLE_TIME		20
+#define BIT_ACCEL_OUT			0x08
+#define BITS_GYRO_OUT			0x70
+#define THREE_AXIS			3
+#define DEF_GYRO_WAIT_TIME		10
+#define DEF_GYRO_WAIT_TIME_LP		50
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX		20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL			60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN		225
+#define DEF_ACCEL_ST_AL_MAX		675
+
+struct recover_regs {
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 config;		/* REG_CONFIG */
+	u8 gyro_config;		/* REG_GYRO_CONFIG */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+	u8 smplrt_div;		/* REG_SAMPLE_RATE_DIV */
+	u8 lp_mode;		/* REG_LP_MODE_CFG */
+	u8 pwr_mgmt_1;		/* REG_PWR_MGMT_1 */
+	u8 pwr_mgmt_2;		/* REG_PWR_MGMT_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_INT_ENABLE      : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_FIFO_EN         : 0x%02X\n", saved_regs.fifo_en);
+	pr_debug(" REG_USER_CTRL       : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_CONFIG          : 0x%02X\n", saved_regs.config);
+	pr_debug(" REG_GYRO_CONFIG     : 0x%02X\n", saved_regs.gyro_config);
+	pr_debug(" REG_ACCEL_CONFIG    : 0x%02X\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2  : 0x%02X\n", saved_regs.accel_config_2);
+	pr_debug(" REG_SAMPLE_RATE_DIV : 0x%02X\n", saved_regs.smplrt_div);
+	pr_debug(" REG_LP_MODE_CFG     : 0x%02X\n", saved_regs.lp_mode);
+	pr_debug(" REG_PWR_MGMT_1      : 0x%02X\n", saved_regs.pwr_mgmt_1);
+	pr_debug(" REG_PWR_MGMT_2      : 0x%02X\n", saved_regs.pwr_mgmt_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_read(st, REG_PWR_MGMT_1, 1,
+			&saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	/* wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+
+	result = inv_plat_read(st, REG_INT_ENABLE, 1,
+			&saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1,
+			&saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1,
+			&saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1,
+			&saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG, 1,
+			&saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SAMPLE_RATE_DIV, 1,
+			&saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_MODE_CFG, 1,
+			&saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1,
+			&saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN,
+			saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_CONFIG,
+			saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+			saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+			saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_MODE_CFG,
+			saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_switch_engine(struct inv_mpu_state *st, bool en, u32 mask)
+{
+	u8 data, mgmt_1;
+	int result;
+
+	if (BIT_PWR_GYRO_STBY == mask) {
+		result = inv_plat_read(st, REG_PWR_MGMT_1, 1, &mgmt_1);
+		if (result)
+			return result;
+		mgmt_1 &= ~BIT_CLK_MASK;
+	}
+
+	if ((BIT_PWR_GYRO_STBY == mask) && (!en)) {
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1, &data);
+	if (result)
+		return result;
+	if (en)
+		data &= (~mask);
+	else
+		data |= mask;
+	data |= BIT_FIFO_LP_EN;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2, data);
+	if (result)
+		return result;
+
+	if ((BIT_PWR_GYRO_STBY == mask) && en) {
+		/* only gyro on needs sensor up time */
+		msleep(SENSOR_UP_TIME);
+		/* after gyro is on & stable, switch internal clock to PLL */
+		mgmt_1 |= BIT_CLK_PLL;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+	if ((BIT_PWR_ACCEL_STBY == mask) && en)
+		msleep(REG_UP_TIME);
+
+	return 0;
+}
+
+int inv_set_offset_reg(struct inv_mpu_state *st, int reg, int val)
+{
+	int result;
+	u8 d;
+
+	d = ((val >> 8) & 0xff);
+	result = inv_plat_single_write(st, reg, d);
+	if (result)
+		return result;
+
+	d = (val & 0xff);
+	result = inv_plat_single_write(st, reg + 1, d);
+
+	return result;
+}
+
+/**
+* inv_check_gyro_self_test() - check gyro self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_gyro_self_test(struct inv_mpu_state *st,
+		int *reg_avg, int *st_avg)
+{
+	u8 regs[3];
+	int ret_val, result;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XG_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test gyro shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA
+						* st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			/* Self Test Pass/Fail Criteria B */
+			if (st_shift_cust[i] < DEF_GYRO_ST_AL *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	if (ret_val == 0) {
+		/* Self Test Pass/Fail Criteria C */
+		for (i = 0; i < 3; i++)
+			if (abs(reg_avg[i]) > DEF_GYRO_OFFSET_MAX *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/**
+* inv_check_accel_self_test() - check 6500 accel self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_accel_self_test(struct inv_mpu_state *st,
+		int *reg_avg, int *st_avg)
+{
+	int ret_val, result;
+	int st_shift_prod[3], st_shift_cust[3], st_shift_ratio[3], i;
+	u8 regs[3];
+	int otp_value_zero = 0;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XA_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test accel shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			st_shift_ratio[i] = abs(st_shift_cust[i] /
+					st_shift_prod[i] - DEF_ST_PRECISION);
+			if (st_shift_ratio[i] > DEF_ACCEL_ST_SHIFT_DELTA)
+				ret_val = 1;
+		}
+	} else {
+		/* Self Test Pass/Fail Criteria B */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = abs(st_avg[i] - reg_avg[i]);
+			if (st_shift_cust[i] < ACCEL_ST_AL_MIN ||
+					st_shift_cust[i] > ACCEL_ST_AL_MAX)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+int inv_do_test(struct inv_mpu_state *st, int self_test_flag,
+			int *gyro_result, int *accel_result, int lp_mode)
+{
+	int result, i, j, packet_size;
+	u8 data[BYTES_PER_SENSOR * 2], d, dd;
+	int fifo_count, packet_count, ind, s;
+
+	packet_size = BYTES_PER_SENSOR * 2;
+
+	/* disable interrupt */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+	/* disable the sensor output to FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (result)
+		return result;
+	/* disable fifo reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+	if (result)
+		return result;
+	/* clear FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (result)
+		return result;
+	/* setup parameters */
+	result = inv_plat_single_write(st, REG_CONFIG, INV_FILTER_98HZ);
+	if (result)
+		return result;
+
+	/* gyro lp mode */
+	if (lp_mode == 1)
+		d = BIT_GYRO_CYCLE;
+	else if (lp_mode == 2)
+		d = DEF_SELFTEST_SAMPLE_RATE_ACC_LP;
+	else
+		d = 0;
+	result = inv_plat_single_write(st, REG_LP_MODE_CFG, d);
+	if (result)
+		return result;
+
+	/* config accel LPF register */
+	if (lp_mode == 2)
+		d = BIT_ACCEL_FCHOCIE_B;
+	else
+		d = DEF_ST_MPU6500_ACCEL_LPF;
+	result = inv_plat_single_write(st, REG_6500_ACCEL_CONFIG2, d);
+	if (result)
+		return result;
+
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE_LP);
+	} else {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE);
+	}
+	if (result)
+		return result;
+	/* wait for the sampling rate change to stabilize */
+	mdelay(INV_MPU_SAMPLE_RATE_CHANGE_STABLE);
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+		self_test_flag | DEF_SELFTEST_GYRO_FS);
+	if (result)
+		return result;
+
+	d = DEF_SELFTEST_6500_ACCEL_FS;
+	d |= self_test_flag;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, d);
+	if (result)
+		return result;
+
+	/* wait for the output to get stable */
+	msleep(DEF_ST_6500_STABLE_TIME);
+
+	/* enable FIFO reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+	if (result)
+		return result;
+	/* enable sensor output to FIFO */
+	d = BITS_GYRO_OUT | BIT_ACCEL_OUT;
+	for (i = 0; i < THREE_AXIS; i++) {
+		gyro_result[i] = 0;
+		accel_result[i] = 0;
+	}
+	s = 0;
+	while (s < 200 /*st->self_test.samples*/) {
+		/* Stop FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+		if (result)
+			return result;
+		/* clear FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+		if (result)
+			return result;
+		/* enable FIFO reading */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+		if (result)
+			return result;
+
+		/* accel lp mode */
+		dd = BIT_CLK_PLL;
+		if (lp_mode == 2)
+			dd |= BIT_LP_EN;
+		else
+			dd &= ~BIT_LP_EN;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, dd);
+		if (result)
+			return result;
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, d);
+		if (result)
+			return result;
+		if (lp_mode)
+			mdelay(DEF_GYRO_WAIT_TIME_LP);
+		else
+			mdelay(DEF_GYRO_WAIT_TIME);
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+		if (result)
+			return result;
+
+		result = inv_plat_read(st, REG_FIFO_COUNT_H,
+					FIFO_COUNT_BYTE, data);
+		if (result)
+			return result;
+		fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+		pr_debug("%s self_test fifo_count - %d\n",
+			 st->hw->name, fifo_count);
+		packet_count = fifo_count / packet_size;
+		i = 0;
+		while ((i < packet_count) && (s < 200 /*st->self_test.samples*/)) {
+			short vals[3];
+
+			result = inv_plat_read(st, REG_FIFO_R_W,
+				packet_size, data);
+			if (result)
+				return result;
+			ind = 0;
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				accel_result[j] += vals[j];
+			}
+			ind += BYTES_PER_SENSOR;
+			pr_debug(
+				"%s self_test accel data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				gyro_result[j] += vals[j];
+			}
+			pr_debug("%s self_test gyro data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			s++;
+			i++;
+		}
+	}
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXIS; j++) {
+		accel_result[j] = accel_result[j] / s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+	for (j = 0; j < THREE_AXIS; j++) {
+		gyro_result[j] = gyro_result[j] / s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	return 0;
+}
+
+int inv_power_up_self_test(struct inv_mpu_state *st)
+{
+	int result;
+
+	/* make sure no interrupts */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_ACCEL_STBY);
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXIS], gyro_bias_regular[THREE_AXIS];
+	int accel_bias_st[THREE_AXIS], accel_bias_regular[THREE_AXIS];
+#ifndef USE_GYRO_LN_MODE
+	int gyro_bias_regular_lp[THREE_AXIS];
+#endif
+#if 0
+	int accel_bias_regular_lp[THREE_AXIS];
+#endif
+	int test_times, i;
+	char accel_result, gyro_result;
+
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	result = inv_power_up_self_test(st);
+	if (result)
+		return result;
+	accel_result = 0;
+	gyro_result = 0;
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular,
+			accel_bias_regular, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("%s self_test gyro bias_regular - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular[0], gyro_bias_regular[1],
+		gyro_bias_regular[2]);
+
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, BITS_SELF_TEST_EN, gyro_bias_st,
+					accel_bias_st, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_st - %+d %+d %+d\n",
+		st->hw->name, accel_bias_st[0], accel_bias_st[1],
+		accel_bias_st[2]);
+	pr_debug("%s self_test gyro bias_st - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_st[0], gyro_bias_st[1],
+		gyro_bias_st[2]);
+
+#ifndef USE_GYRO_LN_MODE
+	/* lp gyro mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		int dummy_bias_regular[THREE_AXIS];
+
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			dummy_bias_regular, 1);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test gyro bias_regular lp - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular_lp[0], gyro_bias_regular_lp[1],
+		gyro_bias_regular_lp[2]);
+#endif
+
+#if 0
+	/* lp accel mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		int dummy_bias_regular[THREE_AXIS];
+
+		result = inv_do_test(st, 0, dummy_bias_regular,
+			accel_bias_regular_lp, 2);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular lp - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular_lp[0],
+		accel_bias_regular_lp[1], accel_bias_regular_lp[2]);
+#endif
+
+	/* copy bias */
+	for (i = 0; i < 3; i++) {
+#ifdef USE_GYRO_LN_MODE
+		/* gyro : LN bias */
+		st->gyro_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+#else
+		/* gyro : LP bias */
+		st->gyro_st_bias[i] = gyro_bias_regular_lp[i] / DEF_ST_PRECISION;
+#endif
+		/* accel : LN bias as LN is default mode */
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	/* Check is done on continuous mode data */
+	accel_result = !inv_check_accel_self_test(st,
+		accel_bias_regular, accel_bias_st);
+	gyro_result = !inv_check_gyro_self_test(st,
+		gyro_bias_regular, gyro_bias_st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_setup_20608D.c b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_setup_20608D.c
new file mode 100644
index 000000000000..ce669f084305
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20608d/inv_mpu_setup_20608D.c
@@ -0,0 +1,1222 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_enable_fifo_int(struct inv_mpu_state *st, bool enable);
+
+static int inv_set_batchmode(struct inv_mpu_state *st, bool enable)
+{
+	if (enable)
+		st->cntl2 |= BATCH_MODE_EN;
+
+	return 0;
+}
+
+static int inv_calc_engine_dur(struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_batchmode_calc(struct inv_mpu_state *st)
+{
+	int b, timeout;
+	int i, bps;
+	enum INV_ENGINE eng;
+
+	bps = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			bps += (st->sensor[i].sample_size + 2) *
+				st->sensor[i].rate;
+		}
+	}
+
+	/* give fifo space for step detector */
+	if (st->chip_config.step_detector_on)
+		bps += (PED_STEPDET_TIMESTAMP_SZ + HEADER_SZ) * 10; // 10Hz should be enough
+
+	if (bps) {
+		b = st->batch.timeout * bps;
+		if ((b > (FIFO_SIZE * MSEC_PER_SEC)) &&
+			(!st->batch.overflow_on))
+			timeout = FIFO_SIZE * MSEC_PER_SEC / bps;
+		else
+			timeout = st->batch.timeout;
+	} else {
+		return -EINVAL;
+	}
+
+	if (st->chip_config.gyro_enable)
+		eng = ENGINE_GYRO;
+	else
+		eng = ENGINE_ACCEL;
+	b = st->eng_info[eng].dur / USEC_PER_MSEC;
+	st->batch.engine_base = eng;
+	st->batch.counter = timeout * USEC_PER_MSEC / b;
+
+	if (st->batch.counter)
+		st->batch.on = true;
+
+	return 0;
+}
+
+static int inv_set_default_batch(struct inv_mpu_state *st)
+{
+	if (st->batch.max_rate > DEFAULT_BATCH_RATE) {
+		st->batch.default_on = true;
+		st->batch.counter = DEFAULT_BATCH_TIME * NSEC_PER_MSEC /
+			st->eng_info[ENGINE_GYRO].dur;
+	}
+
+	return 0;
+}
+
+int inv_batchmode_setup(struct inv_mpu_state *st)
+{
+	int r;
+	bool on;
+
+	st->batch.default_on = false;
+	if (st->batch.timeout > 0) {
+		r = inv_batchmode_calc(st);
+		if (r)
+			return r;
+	} else {
+		r = inv_set_default_batch(st);
+		if (r)
+			return r;
+	}
+
+	on = (st->batch.on || st->batch.default_on);
+
+	if (on) {
+		r = write_be32_to_mem(st, 0, BM_BATCH_CNTR);
+		if (r)
+			return r;
+		r = write_be32_to_mem(st, st->batch.counter, BM_BATCH_THLD);
+		if (r)
+			return r;
+	}
+
+	r = inv_set_batchmode(st, on);
+
+	return r;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 w, x;
+	int r;
+
+	r = inv_plat_single_write(st, REG_USER_CTRL,
+						(BIT_FIFO_RST | BIT_DMP_RST));
+	if (r)
+		return r;
+	w = 0;
+	x = 0;
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+
+	/* turn on user ctrl register */
+	w = BIT_DMP_RST;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+	if (r)
+		return r;
+	msleep(DMP_RESET_TIME);
+
+	w = BIT_DMP_INT_EN;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, w);
+	if (r)
+		return r;
+
+	w = BIT_FIFO_EN;
+	w |= BIT_DMP_EN;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 w, v;
+	int r;
+
+	if (st->chip_config.gyro_enable | st->chip_config.accel_enable) {
+		w = BIT_FIFO_LP_EN;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY);
+	}
+	r = inv_plat_read(st, REG_PWR_MGMT_2, 1, &v);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	pr_debug("turn on engine REG %X\n", w);
+	if (r)
+		return r;
+
+	if (st->chip_config.gyro_enable && (v & BIT_PWR_GYRO_STBY))
+		msleep(INV_ICM20608_GYRO_START_TIME);
+	if (st->chip_config.accel_enable && (v & BIT_PWR_ACCEL_STBY))
+		msleep(INV_ICM20608_ACCEL_START_TIME);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_als) {
+		if (st->chip_config.als_enable)
+			r = st->slave_als->resume(st);
+		else
+			r = st->slave_als->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_pressure) {
+		if (st->chip_config.pressure_enable)
+			r = st->slave_pressure->resume(st);
+		else
+			r = st->slave_pressure->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i, result;
+	int div[SENSOR_NUM_MAX];
+	bool d_flag;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (!st->sensor[i].rate) {
+				pr_err("sensor %d rate is zero\n", i);
+				return -EINVAL;
+			}
+			pr_debug(
+			"[Before]sensor %d rate [%d], running_rate %d\n",
+				i, st->sensor[i].rate,
+				st->eng_info[st->sensor[i].engine_base].running_rate);
+
+			div[i] =
+				st->eng_info[st->sensor[i].engine_base].
+				running_rate / st->sensor[i].rate;
+			if (!div[i])
+				div[i] = 1;
+			st->sensor[i].rate = st->eng_info
+				[st->sensor[i].engine_base].running_rate / div[i];
+
+			pr_debug(
+			"sensor %d rate [%d] div [%d] running_rate [%d]\n",
+				i, st->sensor[i].rate, div[i],
+			st->eng_info[st->sensor[i].engine_base].running_rate);
+		}
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur *
+				div[i];
+			st->sensor[i].div = div[i];
+			result = inv_write_2bytes(st,
+					st->sensor[i].odr_addr, div[i] - 1);
+
+			if (result)
+				return result;
+			result = inv_write_2bytes(st,
+					st->sensor[i].counter_addr, 0);
+			if (result)
+				return result;
+		}
+	}
+
+	d_flag = 0;
+	for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+		if (st->sensor_accuracy[i].on)
+			st->cntl2 |= st->sensor_accuracy[i].output;
+		d_flag |= st->sensor_accuracy[i].on;
+	}
+	d_flag |= st->chip_config.pick_up_enable;
+	d_flag |= st->chip_config.eis_enable;
+	if (d_flag)
+		st->cntl |= HEADER2_SET;
+
+	if (st->chip_config.step_indicator_on)
+		st->cntl |= PED_STEPIND_SET;
+	if (st->chip_config.step_detector_on)
+		st->cntl |= PED_STEPDET_SET;
+	if (st->chip_config.pick_up_enable)
+		st->cntl2 |= FLIP_PICKUP_SET;
+
+	if (st->chip_config.eis_enable)
+		st->cntl2 |= FSYNC_SET;
+
+	st->batch.on = false;
+	if (!st->chip_config.dmp_event_int_on) {
+		result = inv_batchmode_setup(st);
+		if (result)
+			return result;
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+#ifndef USE_GYRO_LN_MODE
+static int inv_set_lp_config(struct inv_mpu_state *st, int rate)
+{
+	const short accel_rate[] = {0, 0, 0, 1, 3, 7, 15, 31, 62, 125, 250, 500};
+	const short gyro_rate[] = {7, 14, 27, 54, 108, 211, 391, 622};
+	int i, h, result, data = 0;
+
+	h =  rate;
+
+	if (st->chip_config.gyro_enable && !st->chip_config.eis_enable) {
+		data |= BIT_GYRO_CYCLE;
+		i = 0;
+		while ((h > gyro_rate[i]) && (i < ARRAY_SIZE(gyro_rate) - 1))
+			i++;
+		data |= (7 - i) << 4; // G_AVGCFG
+	}
+
+	i = 0;
+	while ((h > accel_rate[i]) && (i < ARRAY_SIZE(accel_rate) - 1))
+		i++;
+	data |= i; // LPOSC_CLKSEL
+
+	pr_debug("lp_mode_cfg = %d\n", data);
+
+	result = inv_plat_single_write(st, REG_LP_MODE_CFG, data);
+	if (result)
+		return result;
+
+	return 0;
+}
+#endif
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st, int rate)
+{
+	const short hz[] = {176, 92, 41, 20, 10, 5};
+	const int   d[] = {INV_FILTER_188HZ, INV_FILTER_98HZ,
+			INV_FILTER_42HZ, INV_FILTER_20HZ,
+			INV_FILTER_10HZ, INV_FILTER_5HZ};
+	int i, h, data, result;
+
+	h = rate >> 1;
+	i = 0;
+	while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+		i++;
+	data = d[i];
+	if (st->chip_config.eis_enable)
+		data |= EXT_SYNC_SET;
+
+	pr_debug("lpf = %d\n", data);
+
+	result = inv_plat_single_write(st, REG_CONFIG, data);
+	if (result)
+		return result;
+
+#ifndef USE_GYRO_LN_MODE
+	result = inv_set_lp_config(st, rate);
+#endif
+
+	st->chip_config.lpf = data;
+	return 0;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result, div;
+
+	if (st->chip_config.gyro_enable)
+		div = g_d;
+	else
+		div = a_d;
+	if (st->chip_config.eis_enable)
+		div = 0;
+
+	pr_debug("div= %d\n", div);
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV, div);
+
+	return result;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st, st->eng_info[ENGINE_GYRO].running_rate);
+
+	return result;
+}
+
+static int inv_set_fifo_size(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static void inv_enable_accel_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (ACCEL_CAL_EN);
+}
+
+static void inv_enable_gyro_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (GYRO_CAL_EN);
+}
+
+static int inv_set_wom(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static void inv_setup_events(struct inv_mpu_state *st)
+{
+	if (st->ped.engine_on)
+		st->motion_event_cntl |= (PEDOMETER_EN);
+	if (st->smd.on)
+		st->motion_event_cntl |= (SMD_EN);
+	if (st->ped.int_on)
+		st->motion_event_cntl |= (PEDOMETER_INT_EN);
+	if (st->chip_config.pick_up_enable)
+		st->motion_event_cntl |= (FLIP_PICKUP_EN);
+	if (st->chip_config.geomag_enable)
+		st->motion_event_cntl |= GEOMAG_RV_EN;
+}
+
+static int inv_mpu_reset_pickup(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static int inv_setup_dmp(struct inv_mpu_state *st)
+{
+	int result;
+
+	inv_enable_accel_cal_V3(st, st->accel_cal_enable);
+	inv_enable_gyro_cal_V3(st, st->gyro_cal_enable);
+
+	if (st->ped.engine_on) {
+		result = write_be32_to_mem(st, 0, DMPRATE_CNTR);
+		if (result)
+			return result;
+		result = write_be16_to_mem(st, 0, PEDSTEP_IND);
+		if (result)
+			return result;
+	}
+
+	if (st->chip_config.pick_up_enable) {
+		result = inv_mpu_reset_pickup(st);
+		if (result)
+			return result;
+	}
+
+	inv_setup_events(st);
+
+	result = inv_set_wom(st);
+	if (result)
+		return result;
+
+	/* set accel scale */
+	result = write_be32_to_mem(st,
+			(DMP_2G_VALUE << st->chip_config.accel_fs),
+			D_ACC_SCALE);
+	if (result)
+		return result;
+	result = write_be32_to_mem(st,
+			(DMP_2G_VALUE << (st->chip_config.accel_fs + 1)),
+			D_ACC_DATA_SCALE);
+	if (result)
+		return result;
+
+	/* all set */
+	result = inv_dataout_control1(st, st->cntl);
+	if (result)
+		return result;
+	result = inv_dataout_control2(st, st->cntl2);
+	if (result)
+		return result;
+	result = inv_motion_interrupt_control(st, st->motion_event_cntl);
+	if (result)
+		return result;
+	result = inv_enable_fifo_int(st, true);
+	if (result)
+		return result;
+
+	pr_debug("setup DMP  cntl [%04X] cntl2 [%04X] motion_event [%04X]",
+				st->cntl, st->cntl2, st->motion_event_cntl);
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en, data_on, ped_on;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	ped_on = false;
+	data_on = false;
+
+	st->chip_config.geomag_enable = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			data_on = true;
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	st->chip_config.activity_eng_on = false; // not supported by 20608D
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on || (st->ped.on && st->batch.timeout && st->ped.int_mode))
+		st->chip_config.step_detector_on = true;
+	else
+		st->chip_config.step_detector_on = false;
+	if (st->chip_config.step_detector_on ||
+		st->chip_config.step_indicator_on) {
+		ped_on = true;
+		data_on = true;
+	}
+	if (st->smd.on)
+		ped_on = true;
+
+	/* pedometer interrupt is enabled when ped int mode */
+	if (st->ped.int_mode && st->ped.on)
+		st->ped.int_on = 1;
+	else
+		st->ped.int_on = 0;
+
+	if (st->ped.on || ped_on)
+		st->ped.engine_on = true;
+	else
+		st->ped.engine_on = false;
+	if (st->ped.engine_on)
+		a_en = true;
+
+	if (st->chip_config.pick_up_enable)
+		a_en = true;
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		gyro_rate = MPU_DEFAULT_DMP_FREQ;
+		st->eis.frame_count = 0;
+	} else {
+		st->eis.eis_triggered = false;
+	}
+
+	if (data_on)
+		st->chip_config.dmp_event_int_on = 0;
+	else
+		st->chip_config.dmp_event_int_on = 1;
+
+	if (st->chip_config.dmp_event_int_on)
+		st->chip_config.wom_on = 1;
+	else
+		st->chip_config.wom_on = 0;
+
+	accel_rate = MPU_DEFAULT_DMP_FREQ;
+	gyro_rate = MPU_DEFAULT_DMP_FREQ;
+
+	if (g_en)
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	else
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	if (st->chip_config.eis_enable) {
+		st->eng_info[ENGINE_GYRO].running_rate = BASE_SAMPLE_RATE;
+		st->eng_info[ENGINE_ACCEL].running_rate = BASE_SAMPLE_RATE;
+		/* engine divider for pressure and compass is set later */
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+	} else {
+		st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+		st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+		/* engine divider for pressure and compass is set later */
+		st->eng_info[ENGINE_GYRO].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_GYRO].running_rate);
+		st->eng_info[ENGINE_ACCEL].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_ACCEL].running_rate);
+	}
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(&st->eng_info[ENGINE_ACCEL]);
+
+	if (st->debug_determine_engine_on)
+		return 0;
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	pr_debug("to= %d inton= %d pon= %d\n", st->batch.timeout,
+		st->ped.int_on, st->ped.on);
+
+	st->chip_config.gyro_enable = g_en;
+	st->gyro_cal_enable = g_en;
+
+	st->chip_config.accel_enable = a_en;
+	st->accel_cal_enable = a_en;
+
+	st->chip_config.dmp_on = 1;
+
+	/* setting up accuracy output */
+	if (st->sensor[SENSOR_ACCEL].on || st->sensor[SENSOR_SIXQ].on)
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = false;
+
+	if (st->sensor[SENSOR_SIXQ].on || st->sensor[SENSOR_THREEQ].on)
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = false;
+
+	st->cntl = 0;
+	st->cntl2 = 0;
+	st->motion_event_cntl = 0;
+	st->send_raw_gyro = false;
+
+	return 0;
+}
+
+int inv_enable_gyro_cal(struct inv_mpu_state *st, bool en)
+{
+	u8 reg[3] = {0xc2, 0xc5, 0xc7};
+	int result;
+
+	if (!en) {
+		reg[0] = 0xf1;
+		reg[1] = 0xf1;
+		reg[2] = 0xf1;
+	}
+
+	result = mem_w(CFG_EXT_GYRO_BIAS, 3, &reg[0]);
+
+	return result;
+}
+
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	u8 reg[3];
+
+	if (en) {
+		reg[0] = 0xf4;
+		reg[1] = 0x44;
+		reg[2] = 0xf1;
+
+	} else {
+		reg[0] = 0xf1;
+		reg[1] = 0xf1;
+		reg[2] = 0xf1;
+	}
+
+	return mem_w(CFG_PED_INT, ARRAY_SIZE(reg), reg);
+}
+
+int inv_enable_pedometer(struct inv_mpu_state *st, bool en)
+{
+	u8 d[1];
+
+	if (en)
+		d[0] = 0xf1;
+	else
+		d[0] = 0xff;
+
+	return mem_w(CFG_PED_ENABLE, ARRAY_SIZE(d), d);
+}
+
+int inv_send_stepdet_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off step detect jumps to STEPDET_END */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (STEPDET_END >> 8) & 0xff;
+		reg[2] = STEPDET_END & 0xff;
+	}
+
+	result = mem_w(CFG_OUT_STEPDET, 3, &reg[0]);
+
+	return result;
+}
+
+
+int inv_add_step_indicator(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xf3, 0xf3, 0xf3};
+	int result;
+
+	/* turning off step indicator jumps to PED_STEP_COUNT2_DETECTED */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (PED_STEP_COUNT2_DETECTED >> 8) & 0xff;
+		reg[2] = PED_STEP_COUNT2_DETECTED & 0xff;
+	}
+
+	result = mem_w(CFG_PEDSTEP_DET, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_enable_smd(struct inv_mpu_state *st, bool en)
+{
+	u8 d[1];
+
+	if (en)
+		d[0] = 1;
+	else
+		d[0] = 0;
+
+	return mem_w(D_SMD_ENABLE, ARRAY_SIZE(d), d);
+}
+
+
+int inv_send_gyro_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off gyro jumps to PREV_PQUAT */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (PREV_PQUAT >> 8) & 0xff;
+		reg[2] = PREV_PQUAT & 0xff;
+	}
+	result = mem_w(CFG_OUT_GYRO, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+static int inv_out_fsync(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xf3, 0xf3, 0xf3};
+	int result;
+
+	/* turning off fsync jumps to FSYNC_END */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (FSYNC_END >> 8) & 0xff;
+		reg[2] = FSYNC_END & 0xff;
+	}
+
+	result = mem_w(CFG_OUT_FSYNC, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+static int inv_enable_eis(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[2] = {0};
+	int result;
+
+	if (enable)
+		reg[1] = 0x1;
+	result = mem_w(D_EIS_ENABLE, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_send_accel_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off accel jumps to GYRO_FIFO_RATE */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (GYRO_FIFO_RATE >> 8) & 0xff;
+		reg[2] = GYRO_FIFO_RATE & 0xff;
+	}
+	result = mem_w(CFG_OUT_ACCL, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_send_six_q_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off 6-axis jumps to PQUAT_FIFO_RATE */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (PQUAT_FIFO_RATE >> 8) & 0xff;
+		reg[2] = PQUAT_FIFO_RATE & 0xff;
+	}
+	result = mem_w(CFG_OUT_6QUAT, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_send_three_q_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off LPQ jumps to QUAT6_FIFO_RATE */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (QUAT6_FIFO_RATE >> 8) & 0xff;
+		reg[2] = QUAT6_FIFO_RATE & 0xff;
+	}
+	result = mem_w(CFG_OUT_3QUAT, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_send_ped_q_data(struct inv_mpu_state *st, bool enable)
+{
+	u8 reg[3] = {0xa3, 0xa3, 0xa3};
+	int result;
+
+	/* turning off pquat jumps to ACCEL_FIFO_RATE */
+	if (!enable) {
+		reg[0] = 0xf4;
+		reg[1] = (ACCEL_FIFO_RATE >> 8) & 0xff;
+		reg[2] = ACCEL_FIFO_RATE & 0xff;
+	}
+	result = mem_w(CFG_OUT_PQUAT, ARRAY_SIZE(reg), reg);
+
+	return result;
+}
+
+int inv_enable_batch(struct inv_mpu_state *st, bool on)
+{
+	u8 d[] = {0};
+	int result;
+
+	d[0] = on;
+	result = mem_w(D_BM_ENABLE, ARRAY_SIZE(d), d);
+
+	return result;
+}
+
+static int inv_enable_fifo_int(struct inv_mpu_state *st, bool enable)
+{
+	u8 d[1];
+
+	if (enable)
+		d[0] = 0xfe;
+	else
+		d[0] = 0xf1;
+
+	return mem_w(CFG_FIFO_INT, ARRAY_SIZE(d), d);
+}
+
+int inv_dataout_control1(struct inv_mpu_state *st, u16 cntl1)
+{
+	int result = 0;
+
+	if (cntl1 & ACCEL_SET)
+		result = inv_send_accel_data(st, true);
+	else
+		result = inv_send_accel_data(st, false);
+
+	if (cntl1 & GYRO_SET)
+		result |= inv_send_gyro_data(st, true);
+	else
+		result |= inv_send_gyro_data(st, false);
+
+	if (cntl1 & QUAT6_SET)
+		result |= inv_send_six_q_data(st, true);
+	else
+		result |= inv_send_six_q_data(st, false);
+
+	if (cntl1 & LPQ_SET)
+		result |= inv_send_three_q_data(st, true);
+	else
+		result |= inv_send_three_q_data(st, false);
+
+	if (cntl1 & PQUAT6_SET)
+		result |= inv_send_ped_q_data(st, true);
+	else
+		result |= inv_send_ped_q_data(st, false);
+
+	if ((cntl1 & PED_STEPDET_SET))
+		result |= inv_send_stepdet_data(st, true);
+	else
+		result |= inv_send_stepdet_data(st, false);
+
+	return result;
+}
+
+int inv_dataout_control2(struct inv_mpu_state *st, u16 cntl2)
+{
+	int result = 0;
+	bool en;
+
+	if (cntl2 & BATCH_MODE_EN)
+		en = true;
+	else
+		en = false;
+	result = inv_enable_batch(st, en);
+	if (result)
+		return result;
+
+	if (cntl2 & FSYNC_SET)
+		en = true;
+	else
+		en = false;
+	result = inv_enable_eis(st, en);
+	if (result)
+		return result;
+
+	result = inv_out_fsync(st, en);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_motion_interrupt_control(struct inv_mpu_state *st,
+			u16 motion_event_cntl)
+{
+	int result = 0;
+
+	if (motion_event_cntl & PEDOMETER_EN)
+		result = inv_enable_pedometer(st, true);
+	else
+		result = inv_enable_pedometer(st, false);
+
+	if (motion_event_cntl & PEDOMETER_INT_EN)
+		result = inv_enable_pedometer_interrupt(st, true);
+	else
+		result = inv_enable_pedometer_interrupt(st, false);
+
+	if (motion_event_cntl & SMD_EN)
+		result = inv_enable_smd(st, true);
+	else
+		result = inv_enable_smd(st, false);
+
+	if (motion_event_cntl & GYRO_CAL_EN)
+		result = inv_enable_gyro_cal(st, true);
+	else
+		result = inv_enable_gyro_cal(st, false);
+
+	return result;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = inv_stop_dmp(st);
+	if (result)
+		return result;
+	inv_determine_engine(st);
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	result = inv_setup_dmp(st);
+	if (result) {
+		pr_err("setup dmp error\n");
+		return result;
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	result = inv_set_fifo_size(st);
+	if (result) {
+		pr_err("inv_set_fifo_size error\n");
+		return result;
+	}
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) && (!st->chip_config.accel_enable)) {
+		inv_set_power(st, false);
+		return 0;
+	}
+	return result;
+}
+
+int inv_setup_dmp_firmware(struct inv_mpu_state *st)
+{
+	int result = 0;
+
+	result = inv_dataout_control1(st, 0);
+	if (result)
+		return result;
+	result = inv_dataout_control2(st, 0);
+	if (result)
+		return result;
+	result = inv_motion_interrupt_control(st, 0);
+
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	/* keep streaming if any gesture reported by FIFO data is enabled */
+	if (st->step_detector_l_on || st->step_detector_wake_l_on)
+		return 0;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_enable_fifo_int(st, false);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	/* skip as did nothing in inv_stop_stream_interrupt() */
+	if (st->step_detector_l_on || st->step_detector_wake_l_on)
+		return 0;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_enable_fifo_int(st, true);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_read_offset_regs(struct inv_mpu_state *st, s16 accel[3], s16 gyro[3])
+{
+	int res;
+	u8 data[2];
+
+	/* accel */
+	res = inv_plat_read(st, REG_XA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[2] = (data[0] << 8) | data[1];
+
+	pr_info("read accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_plat_read(st, REG_XG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[2] = (data[0] << 8) | data[1];
+
+	pr_info("read gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+	return 0;
+}
+
+int inv_write_offset_regs(struct inv_mpu_state *st, const s16 accel[3], const s16 gyro[3])
+{
+	int res;
+
+	/* accel */
+	res = inv_plat_single_write(st, REG_XA_OFFS_H,
+			(accel[0] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_XA_OFFS_H + 1,
+			accel[0] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H,
+			(accel[1] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H + 1,
+			accel[1] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H,
+			(accel[2] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H + 1,
+			accel[2] & 0xff);
+	if (res)
+		return res;
+
+	pr_info("write accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H,
+			(gyro[0] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H + 1,
+			gyro[0] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H,
+			(gyro[1] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H + 1,
+			gyro[1] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H,
+			(gyro[2] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H + 1,
+			gyro[2] & 0xff);
+	if (res)
+		return res;
+
+	pr_info("write gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+	return 0;
+}
+
diff --git a/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h b/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h
new file mode 100644
index 000000000000..d5c1a7547a4d
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define CFG_FIFO_SIZE                   (4184)
+
+/* data output control */
+#define DATA_OUT_CTL1			(4 * 16)
+#define DATA_OUT_CTL2			(4 * 16 + 2)
+#define DATA_INTR_CTL			(4 * 16 + 12)
+#define FIFO_WATERMARK			(31 * 16 + 14)
+
+/* motion event control */
+#define MOTION_EVENT_CTL		(4 * 16 + 14)
+
+/* indicates to DMP which sensors are available */
+/*	1: gyro samples available
+	2: accel samples available
+	8: secondary samples available	*/
+#define DATA_RDY_STATUS			(8 * 16 + 10)
+
+/* batch mode */
+#define BM_BATCH_CNTR			(27 * 16)
+#define BM_BATCH_THLD			(19 * 16 + 12)
+#define BM_BATCH_MASK			(21 * 16 + 14)
+
+/* sensor output data rate */
+#define ODR_ACCEL				(11 * 16 + 14)
+#define ODR_GYRO				(11 * 16 + 10)
+#define ODR_CPASS				(11 * 16 +  6)
+#define ODR_ALS					(11 * 16 +  2)
+#define ODR_QUAT6				(10 * 16 + 12)
+#define ODR_QUAT9				(10 * 16 +  8)
+#define ODR_PQUAT6				(10 * 16 +  4)
+#define ODR_GEOMAG				(10 * 16 +  0)
+#define ODR_PRESSURE			(11 * 16 + 12)
+#define ODR_GYRO_CALIBR			(11 * 16 +  8)
+#define ODR_CPASS_CALIBR		(11 * 16 +  4)
+
+/* sensor output data rate counter */
+#define ODR_CNTR_ACCEL			(9 * 16 + 14)
+#define ODR_CNTR_GYRO			(9 * 16 + 10)
+#define ODR_CNTR_CPASS			(9 * 16 +  6)
+#define ODR_CNTR_ALS			(9 * 16 +  2)
+#define ODR_CNTR_QUAT6			(8 * 16 + 12)
+#define ODR_CNTR_QUAT9			(8 * 16 +  8)
+#define ODR_CNTR_PQUAT6			(8 * 16 +  4)
+#define ODR_CNTR_GEOMAG			(8 * 16 +  0)
+#define ODR_CNTR_PRESSURE		(9 * 16 + 12)
+#define ODR_CNTR_GYRO_CALIBR	(9 * 16 +  8)
+#define ODR_CNTR_CPASS_CALIBR	(9 * 16 +  4)
+
+/* mounting matrix */
+#define CPASS_MTX_00            (23 * 16)
+#define CPASS_MTX_01            (23 * 16 + 4)
+#define CPASS_MTX_02            (23 * 16 + 8)
+#define CPASS_MTX_10            (23 * 16 + 12)
+#define CPASS_MTX_11            (24 * 16)
+#define CPASS_MTX_12            (24 * 16 + 4)
+#define CPASS_MTX_20            (24 * 16 + 8)
+#define CPASS_MTX_21            (24 * 16 + 12)
+#define CPASS_MTX_22            (25 * 16)
+
+#define GYRO_SF					(19 * 16)
+#define ACCEL_FB_GAIN			(34 * 16)
+#define ACCEL_ONLY_GAIN			(16 * 16 + 12)
+
+/* bias calibration */
+#define GYRO_BIAS_X				(139 * 16 +  4)
+#define GYRO_BIAS_Y				(139 * 16 +  8)
+#define GYRO_BIAS_Z				(139 * 16 + 12)
+#define GYRO_ACCURACY			(138 * 16 +  2)
+#define GYRO_BIAS_SET			(138 * 16 +  6)
+#define GYRO_LAST_TEMPR			(134 * 16)
+#define GYRO_SLOPE_X			(78 * 16 +  4)
+#define GYRO_SLOPE_Y			(78 * 16 +  8)
+#define GYRO_SLOPE_Z			(78 * 16 + 12)
+
+#define ACCEL_BIAS_X            (110 * 16 +  4)
+#define ACCEL_BIAS_Y            (110 * 16 +  8)
+#define ACCEL_BIAS_Z            (110 * 16 + 12)
+#define ACCEL_ACCURACY			(97 * 16)
+#define ACCEL_CAL_RESET			(77 * 16)
+#define ACCEL_VARIANCE_THRESH	(93 * 16)
+#define ACCEL_CAL_RATE			(94 * 16 + 4)
+#define ACCEL_PRE_SENSOR_DATA	(97 * 16 + 4)
+#define ACCEL_COVARIANCE		(101 * 16 + 8)
+#define ACCEL_ALPHA_VAR			(91 * 16)
+#define ACCEL_A_VAR				(92 * 16)
+#define ACCEL_CAL_INIT			(94 * 16 + 2)
+
+#define CPASS_BIAS_X            (126 * 16 +  4)
+#define CPASS_BIAS_Y            (126 * 16 +  8)
+#define CPASS_BIAS_Z            (126 * 16 + 12)
+#define CPASS_ACCURACY			(37 * 16)
+#define CPASS_BIAS_SET			(34 * 16 + 14)
+#define MAR_MODE				(37 * 16 + 2)
+#define CPASS_COVARIANCE		(115 * 16)
+#define CPASS_COVARIANCE_CUR	(118 * 16 +  8)
+#define CPASS_REF_MAG_3D		(122 * 16)
+#define CPASS_CAL_INIT			(114 * 16)
+#define CPASS_EST_FIRST_BIAS	(113 * 16)
+#define MAG_DISTURB_STATE		(113 * 16 + 2)
+#define CPASS_VAR_COUNT			(112 * 16 + 6)
+#define CPASS_COUNT_7			(87 * 16 + 2)
+#define CPASS_MAX_INNO			(124 * 16)
+#define CPASS_BIAS_OFFSET		(113 * 16 + 4)
+#define CPASS_CUR_BIAS_OFFSET	(114 * 16 + 4)
+#define CPASS_PRE_SENSOR_DATA	(87 * 16 + 4)
+
+/* Compass Cal params to be adjusted according to sampling rate */
+#define CPASS_TIME_BUFFER		(112 * 16 + 14)
+#define CPASS_RADIUS_3D_THRESH_ANOMALY	(112 * 16 + 8)
+
+#define CPASS_STATUS_CHK		(25 * 16 + 12)
+
+/* 9-axis */
+#define MAGN_THR_9X				(80 * 16)
+#define MAGN_LPF_THR_9X			(80 * 16 +  8)
+#define QFB_THR_9X				(80 * 16 + 12)
+
+/* DMP running counter */
+#define DMPRATE_CNTR			(18 * 16 + 4)
+
+/* pedometer */
+#define PEDSTD_BP_B				(49 * 16 + 12)
+#define PEDSTD_BP_A4			(52 * 16)
+#define PEDSTD_BP_A3			(52 * 16 +  4)
+#define PEDSTD_BP_A2			(52 * 16 +  8)
+#define PEDSTD_BP_A1			(52 * 16 + 12)
+#define PEDSTD_SB				(50 * 16 +  8)
+#define PEDSTD_SB_TIME			(50 * 16 + 12)
+#define PEDSTD_PEAKTHRSH		(57 * 16 +  8)
+#define PEDSTD_TIML				(50 * 16 + 10)
+#define PEDSTD_TIMH				(50 * 16 + 14)
+#define PEDSTD_PEAK				(57 * 16 +  4)
+#define PEDSTD_STEPCTR			(54 * 16)
+#define PEDSTD_STEPCTR2			(58 * 16 +  8)
+#define PEDSTD_TIMECTR			(60 * 16 +  4)
+#define PEDSTD_DECI				(58 * 16)
+#define PEDSTD_SB2				(60 * 16 + 14)
+#define STPDET_TIMESTAMP		(18 * 16 +  8)
+#define PEDSTEP_IND				(19 * 16 +  4)
+
+/* SMD */
+#define SMD_VAR_TH              (141 * 16 + 12)
+#define SMD_VAR_TH_DRIVE        (143 * 16 + 12)
+#define SMD_DRIVE_TIMER_TH      (143 * 16 +  8)
+#define SMD_TILT_ANGLE_TH       (179 * 16 + 12)
+#define BAC_SMD_ST_TH           (179 * 16 +  8)
+#define BAC_ST_ALPHA4           (180 * 16 + 12)
+#define BAC_ST_ALPHA4A          (176 * 16 + 12)
+
+/* Wake on Motion */
+#define WOM_ENABLE              (64 * 16 + 14)
+#define WOM_STATUS              (64 * 16 + 6)
+#define WOM_THRESHOLD           (64 * 16)
+#define WOM_CNTR_TH             (64 * 16 + 12)
+
+/* Activity Recognition */
+#define BAC_RATE                (48  * 16 + 10)
+#define BAC_STATE               (179 * 16 +  0)
+#define BAC_STATE_PREV          (179 * 16 +  4)
+#define BAC_ACT_ON              (182 * 16 +  0)
+#define BAC_ACT_OFF             (183 * 16 +  0)
+#define BAC_STILL_S_F           (177 * 16 +  0)
+#define BAC_RUN_S_F             (177 * 16 +  4)
+#define BAC_DRIVE_S_F           (178 * 16 +  0)
+#define BAC_WALK_S_F            (178 * 16 +  4)
+#define BAC_SMD_S_F             (178 * 16 +  8)
+#define BAC_BIKE_S_F            (178 * 16 + 12)
+#define BAC_E1_SHORT            (146 * 16 +  0)
+#define BAC_E2_SHORT            (146 * 16 +  4)
+#define BAC_E3_SHORT            (146 * 16 +  8)
+#define BAC_VAR_RUN             (148 * 16 + 12)
+#define BAC_TILT_INIT           (181 * 16 +  0)
+#define BAC_MAG_ON              (225 * 16 +  0)
+#define BAC_PS_ON               (74  * 16 +  0)
+#define BAC_BIKE_PREFERENCE     (173 * 16 +  8)
+#define BAC_MAG_I2C_ADDR        (229 * 16 +  8)
+#define BAC_PS_I2C_ADDR         (75  * 16 +  4)
+#define BAC_DRIVE_CONFIDENCE    (144 * 16 +  0)
+#define BAC_WALK_CONFIDENCE     (144 * 16 +  4)
+#define BAC_SMD_CONFIDENCE      (144 * 16 +  8)
+#define BAC_BIKE_CONFIDENCE     (144 * 16 + 12)
+#define BAC_STILL_CONFIDENCE    (145 * 16 +  0)
+#define BAC_RUN_CONFIDENCE      (145 * 16 +  4)
+
+/* Flip/Pick-up */
+#define FP_VAR_ALPHA            (245 * 16 +  8)
+#define FP_STILL_TH             (246 * 16 +  4)
+#define FP_MID_STILL_TH         (244 * 16 +  8)
+#define FP_NOT_STILL_TH         (246 * 16 +  8)
+#define FP_VIB_REJ_TH           (241 * 16 +  8)
+#define FP_MAX_PICKUP_T_TH      (244 * 16 + 12)
+#define FP_PICKUP_TIMEOUT_TH    (248 * 16 +  8)
+#define FP_STILL_CONST_TH       (246 * 16 + 12)
+#define FP_MOTION_CONST_TH      (240 * 16 +  8)
+#define FP_VIB_COUNT_TH         (242 * 16 +  8)
+#define FP_STEADY_TILT_TH       (247 * 16 +  8)
+#define FP_STEADY_TILT_UP_TH    (242 * 16 + 12)
+#define FP_Z_FLAT_TH_MINUS      (243 * 16 +  8)
+#define FP_Z_FLAT_TH_PLUS       (243 * 16 + 12)
+#define FP_DEV_IN_POCKET_TH     (76  * 16 + 12)
+#define FP_PICKUP_CNTR          (247 * 16 +  4)
+#define FP_RATE                 (240 * 16 + 12)
+
+/* Accel FSR */
+#define ACC_SCALE               (30 * 16 + 0)
+#define ACC_SCALE2              (79 * 16 + 4)
+
+/* S-Health keys */
+#define S_HEALTH_WALK_RUN_1		(213 * 16 +  12)
+#define S_HEALTH_WALK_RUN_2		(213 * 16 +   8)
+#define S_HEALTH_WALK_RUN_3		(213 * 16 +   4)
+#define S_HEALTH_WALK_RUN_4		(213 * 16 +   0)
+#define S_HEALTH_WALK_RUN_5		(212 * 16 +  12)
+#define S_HEALTH_WALK_RUN_6		(212 * 16 +   8)
+#define S_HEALTH_WALK_RUN_7		(212 * 16 +   4)
+#define S_HEALTH_WALK_RUN_8		(212 * 16 +   0)
+#define S_HEALTH_WALK_RUN_9		(211 * 16 +  12)
+#define S_HEALTH_WALK_RUN_10	(211 * 16 +   8)
+#define S_HEALTH_WALK_RUN_11	(211 * 16 +   4)
+#define S_HEALTH_WALK_RUN_12	(211 * 16 +   0)
+#define S_HEALTH_WALK_RUN_13	(210 * 16 +  12)
+#define S_HEALTH_WALK_RUN_14	(210 * 16 +   8)
+#define S_HEALTH_WALK_RUN_15	(210 * 16 +   4)
+#define S_HEALTH_WALK_RUN_16	(210 * 16 +   0)
+#define S_HEALTH_WALK_RUN_17	(209 * 16 +  12)
+#define S_HEALTH_WALK_RUN_18	(209 * 16 +   8)
+#define S_HEALTH_WALK_RUN_19	(209 * 16 +   4)
+#define S_HEALTH_WALK_RUN_20	(209 * 16 +   0)
+#define S_HEALTH_CADENCE1		(213 * 16 +  14)
+#define S_HEALTH_CADENCE2		(213 * 16 +  10)
+#define S_HEALTH_CADENCE3		(213 * 16 +   6)
+#define S_HEALTH_CADENCE4		(213 * 16 +   2)
+#define S_HEALTH_CADENCE5		(212 * 16 +  14)
+#define S_HEALTH_CADENCE6		(212 * 16 +  10)
+#define S_HEALTH_CADENCE7		(212 * 16 +   6)
+#define S_HEALTH_CADENCE8		(212 * 16 +   2)
+#define S_HEALTH_CADENCE9		(211 * 16 +  14)
+#define S_HEALTH_CADENCE10		(211 * 16 +  10)
+#define S_HEALTH_CADENCE11		(211 * 16 +   6)
+#define S_HEALTH_CADENCE12		(211 * 16 +   2)
+#define S_HEALTH_CADENCE13		(210 * 16 +  14)
+#define S_HEALTH_CADENCE14		(210 * 16 +  10)
+#define S_HEALTH_CADENCE15		(210 * 16 +   6)
+#define S_HEALTH_CADENCE16		(210 * 16 +   2)
+#define S_HEALTH_CADENCE17		(209 * 16 +  14)
+#define S_HEALTH_CADENCE18		(209 * 16 +  10)
+#define S_HEALTH_CADENCE19		(209 * 16 +   6)
+#define S_HEALTH_CADENCE20		(209 * 16 +   2)
+#define S_HEALTH_INT_PERIOD		(214 * 16 +   6)
+#define S_HEALTH_INT_PERIOD2	(214 * 16 +  10)
+#define S_HEALTH_BACKUP1		(214 * 16 +   0)
+#define S_HEALTH_BACKUP2		(214 * 16 +   2)
+#define S_HEALTH_RATE           (208 * 16 +  14)
+
+/* EIS authentication */
+#define EIS_AUTH_INPUT			(160 * 16 +   4)
+#define EIS_AUTH_OUTPUT			(160 * 16 +   0)
+
+#define ACCEL_SET		0x8000
+#define GYRO_SET		0x4000
+#define CPASS_SET		0x2000
+#define ALS_SET			0x1000
+#define QUAT6_SET		0x0800
+#define QUAT9_SET		0x0400
+#define PQUAT6_SET		0x0200
+#define GEOMAG_SET		0x0100
+#define PRESSURE_SET	0x0080
+#define CPASS_CALIBR_SET 0x0020
+#define PED_STEPDET_SET	0x0010
+#define HEADER2_SET		0x0008
+#define PED_STEPIND_SET 0x0007
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET  0x4000
+#define GYRO_ACCURACY_SET   0x2000
+#define CPASS_ACCURACY_SET  0x1000
+#define FSYNC_SET           0x0800
+#define FLIP_PICKUP_SET     0x0400
+#define BATCH_MODE_EN       0x0100
+#define ACT_RECOG_SET       0x0080
+#define SECOND_SEN_OFF_SET  0x0040
+
+/* motion event control reg
+ high byte of motion event control */
+#define PEDOMETER_EN        0x4000
+#define PEDOMETER_INT_EN    0x2000
+#define TILT_INT_EN         0x1000
+#define SMD_EN              0x0800
+#define SECOND_SENSOR_AUTO  0x0400
+#define ACCEL_CAL_EN        0x0200
+#define GYRO_CAL_EN         0x0100
+/* low byte of motion event control */
+#define COMPASS_CAL_EN      0x0080
+#define NINE_AXIS_EN        0x0040
+#define S_HEALTH_EN         0x0020
+#define FLIP_PICKUP_EN      0x0010
+#define GEOMAG_RV_EN        0x0008
+#define BRING_LOOK_SEE_EN   0x0004
+#define BAC_ACCEL_ONLY_EN   0x0002
+
+/* data packet size reg 1 */
+#define HEADER_SZ		2
+#define ACCEL_DATA_SZ	6
+#define GYRO_DATA_SZ	12
+#define CPASS_DATA_SZ	6
+#define ALS_DATA_SZ		8
+#define QUAT6_DATA_SZ	12
+#define QUAT9_DATA_SZ	14
+#define PQUAT6_DATA_SZ	6
+#define GEOMAG_DATA_SZ	14
+#define PRESSURE_DATA_SZ		6
+#define CPASS_CALIBR_DATA_SZ	12
+#define PED_STEPDET_TIMESTAMP_SZ	4
+#define FOOTER_SZ		2
+
+/* data packet size reg 2 */
+#define HEADER2_SZ			2
+#define ACCEL_ACCURACY_SZ	2
+#define GYRO_ACCURACY_SZ	2
+#define CPASS_ACCURACY_SZ	2
+#define FSYNC_SZ			2
+#define FLIP_PICKUP_SZ      2
+#define ACT_RECOG_SZ        6
+#define SECOND_AUTO_OFF_SZ    2
+
+#define DMP_START_ADDRESS   ((unsigned short)0x1000)
+#define DMP_MEM_BANK_SIZE   256
+#define DMP_LOAD_START      0x90
+
+#define DMP_CODE_SIZE 13463
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c
new file mode 100644
index 000000000000..3730cdad8ad2
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c
@@ -0,0 +1,2871 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM20648] = {128, "icm20648"},
+};
+
+static int debug_mem_read_addr = 0x900;
+static char debug_reg_addr = 0x6;
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+/*
+ * inv_firmware_loaded_store() -  calling this function will change
+ *                        firmware load
+ */
+static ssize_t inv_firmware_loaded_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+
+	if (data)
+		return -EINVAL;
+	st->chip_config.firmware_loaded = 0;
+
+	return count;
+
+}
+static int inv_setup_poke_mode(struct inv_mpu_state *st, bool data)
+{
+	int result;
+
+	if (data)
+		result = inv_plat_single_write(st, REG_DMP_START_MODE,
+							BIT_DMP_START_MODE);
+	else
+		result = inv_plat_single_write(st, REG_DMP_START_MODE, 0);
+
+	return result;
+}
+static ssize_t inv_poke_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+
+	if (st->poke_mode_on == data)
+		return count;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	st->poke_mode_on = data;
+	result = inv_setup_poke_mode(st, data);
+
+	if (result)
+		return result;
+
+	set_inv_enable(indio_dev);
+
+	return count;
+}
+
+static int inv_dry_run_dmp(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	st->smd.on = 1;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+	msleep(DRY_RUN_TIME);
+	st->smd.on = 0;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+
+	return 0;
+}
+
+static int _dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data, output;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto dmp_bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_ACCEL_ACCURACY] = true;
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_GYRO_ACCURACY] = true;
+		result = write_be32_to_mem(st, data, GYRO_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, GYRO_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, GYRO_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		result = write_be32_to_mem(st, data, EIS_AUTH_INPUT);
+		if (result)
+			goto dmp_bias_store_fail;
+		inv_dry_run_dmp(indio_dev);
+		result = inv_switch_power_in_lp(st, true);
+		if (result)
+			goto dmp_bias_store_fail;
+		result = read_be32_from_mem(st, &output, EIS_AUTH_OUTPUT);
+		if (result)
+			goto dmp_bias_store_fail;
+		inv_push_marker_to_buffer(indio_dev, EIS_CALIB_HDR, output);
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_COMPASS_ACCURACY] =
+							true;
+		result = write_be32_to_mem(st, data, CPASS_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, CPASS_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, CPASS_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_MISC_GYRO_RECALIBRATION:
+		result = write_be32_to_mem(st, 0, GYRO_LAST_TEMPR);
+		if (result)
+			goto dmp_bias_store_fail;
+		break;
+	case ATTR_DMP_MISC_ACCEL_RECALIBRATION:
+		{
+			u8 d[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+			int i;
+			u32 d1[] = { 0, 0, 0, 0,
+				0, 0, 0, 0, 0, 0,
+				3276800, 3276800, 3276800, 3276800
+			};
+			u32 *w_d;
+
+			if (data) {
+				result =
+					inv_write_2bytes(st, ACCEL_CAL_RESET, 1);
+				if (result)
+					goto dmp_bias_store_fail;
+				result =
+					mem_w(ACCEL_PRE_SENSOR_DATA, ARRAY_SIZE(d),
+					d);
+				w_d = d1;
+			} else {
+				w_d = st->accel_covariance;
+			}
+			for (i = 0; i < ARRAY_SIZE(d1); i++) {
+				result = write_be32_to_mem(st, w_d[i],
+					ACCEL_COVARIANCE +
+					i * sizeof(int));
+				if (result)
+					goto dmp_bias_store_fail;
+			}
+
+			break;
+		}
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		result = write_be32_to_mem(st, data, ACCEL_VARIANCE_THRESH);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->accel_calib_threshold = data;
+		break;
+	/* this serves as a divider of calibration rate, 0->225, 3->55 */
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		if (data < 0)
+			data = 0;
+		result = inv_write_2bytes(st, ACCEL_CAL_RATE, data);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->accel_calib_rate = data;
+		break;
+	case ATTR_DMP_DEBUG_MEM_READ:
+		debug_mem_read_addr = data;
+		break;
+	case ATTR_DMP_DEBUG_MEM_WRITE:
+		inv_write_2bytes(st, debug_mem_read_addr, data);
+		break;
+	default:
+		break;
+	}
+
+dmp_bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[0];
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[1];
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[2];
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0 */
+	inv_set_bank(st, BANK_SEL_1);
+
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	inv_set_bank(st, BANK_SEL_0);
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	inv_set_bank(st, BANK_SEL_2);
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	inv_set_bank(st, BANK_SEL_0);
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _dmp_bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	case ATTR_DEBUG_WRITE_CFG:
+		break;
+	}
+	return count;
+}
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		st->chip_config.low_power_gyro_on = !!data;
+		break;
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		st->debug_determine_engine_on = !!data;
+		break;
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		if (result)
+			return result;
+		result = inv_write_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_INT_ON:
+		result = inv_write_cntl(st, PEDOMETER_INT_EN, !!data,
+					MOTION_EVENT_CTL);
+		if (result)
+			return result;
+		st->ped.int_on = !!data;
+		return 0;
+	case ATTR_DMP_PED_STEP_THRESH:
+		result = inv_write_2bytes(st, PEDSTD_SB, data);
+		if (result)
+			return result;
+		st->ped.step_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_THRESH:
+		result = inv_write_2bytes(st, PEDSTD_SB2, data);
+		if (result)
+			return result;
+		st->ped.int_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_MODE:
+		st->ped.int_mode = !!data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int _debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (!st->debug_determine_engine_on)
+		return -EINVAL;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		st->accel_cal_enable = !!data;
+		break;
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		st->gyro_cal_enable = !!data;
+		break;
+	case ATTR_DMP_EVENT_INT_ON:
+		st->chip_config.dmp_event_int_on = !!data;
+		break;
+	case ATTR_DMP_ON:
+		st->chip_config.dmp_on = !!data;
+		break;
+	case ATTR_GYRO_ENABLE:
+		st->chip_config.gyro_enable = !!data;
+		break;
+	case ATTR_ACCEL_ENABLE:
+		st->chip_config.accel_enable = !!data;
+		break;
+	case ATTR_COMPASS_ENABLE:
+		st->chip_config.compass_enable = !!data;
+		break;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = DEBUG_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_debug_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _debug_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	if (!st->chip_config.firmware_loaded) {
+		pr_err("sensor_rate_store: firmware not loaded\n");
+		return -EINVAL;
+	}
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	if (st->sensor_l[ind].on) {
+		result = set_inv_enable(indio_dev);
+		if (result) {
+			mutex_unlock(&st->lock);
+			return result;
+		}
+	}
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	if (!st->chip_config.firmware_loaded) {
+		pr_err("sensor_on store: firmware not loaded\n");
+		return -EINVAL;
+	}
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	if (on && (!st->sensor_l[ind].rate)) {
+		mutex_unlock(&st->lock);
+		pr_info("rate error for [%s]\n", sensor_l_info[ind]);
+		return count;
+	}
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int step;
+
+	result = inv_get_pedometer_steps(st, &step);
+	if (result) {
+		pr_info("Failed to read step count\n");
+		return result;
+	}
+	inv_send_steps(indio_dev, step, get_time_ns());
+	st->prev_steps = step;
+
+	return 0;
+}
+
+static int inv_send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	inv_switch_power_in_lp(st, true);
+	_send_pedo_steps(indio_dev);
+	inv_switch_power_in_lp(st, false);
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		if ((!!data) == st->smd.on) {
+			pr_info("SMD is %s\n  Same", st->smd.on ? "On" : "Off");
+			return count;
+		}
+		st->smd.on = !!data;
+		pr_info("SMD is %s\n", st->smd.on ? "On" : "Off");
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_ACTIVITY_ON:
+		if ((!!data) == st->chip_config.activity_on)
+			return count;
+		st->chip_config.activity_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		if (st->step_counter_l_on)
+			inv_send_pedo_steps(indio_dev);
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		if (st->step_counter_wake_l_on)
+			inv_send_pedo_steps(indio_dev);
+		break;
+	case ATTR_DMP_STEP_COUNTER_SEND:
+		if (st->step_counter_l_on || st->step_counter_wake_l_on)
+			inv_send_pedo_steps(indio_dev);
+		return count;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store() -  calling this function will store current
+ *                        non-dmp parameter settings
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_bias_show() -  calling this function will show current
+ *                        dmp gyro/accel bias.
+ */
+static int _attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int axes, addr, result, dmp_bias;
+	int sensor_type;
+
+	switch (this_attr->address) {
+	case ATTR_ANGLVEL_X_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[0]);
+	case ATTR_ANGLVEL_Y_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[1]);
+	case ATTR_ANGLVEL_Z_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[2]);
+	case ATTR_ACCEL_X_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[0]);
+	case ATTR_ACCEL_Y_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[1]);
+	case ATTR_ACCEL_Z_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[2]);
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		axes = 0;
+		addr = ACCEL_BIAS_X;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		axes = 1;
+		addr = ACCEL_BIAS_Y;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		axes = 2;
+		addr = ACCEL_BIAS_Z;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		axes = 0;
+		addr = GYRO_BIAS_X;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		axes = 1;
+		addr = GYRO_BIAS_Y;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		axes = 2;
+		addr = GYRO_BIAS_Z;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		axes = 0;
+		addr = CPASS_BIAS_X;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		axes = 1;
+		addr = CPASS_BIAS_Y;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		axes = 2;
+		addr = CPASS_BIAS_Z;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		axes = 0;
+		addr = EIS_AUTH_OUTPUT;
+		sensor_type = -1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = read_be32_from_mem(st, &dmp_bias, addr);
+	if (result)
+		return result;
+	inv_switch_power_in_lp(st, false);
+	if (SENSOR_GYRO == sensor_type)
+		st->input_gyro_dmp_bias[axes] = dmp_bias;
+	else if (SENSOR_ACCEL == sensor_type)
+		st->input_accel_dmp_bias[axes] = dmp_bias;
+	else if (SENSOR_COMPASS == sensor_type)
+		st->input_compass_dmp_bias[axes] = dmp_bias;
+	else if (sensor_type != -1)
+		return -EINVAL;
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", dmp_bias);
+}
+
+static ssize_t inv_attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _attr_bias_show(dev, attr, buf);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show() -  calling this function will show current
+ *                        dmp parameters.
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_COMPASS_SCALE:
+		st->slave_compass->get_scale(st, &result);
+
+		return snprintf(buf, MAX_WR_SZ, "%d\n", result);
+	case ATTR_COMPASS_SENSITIVITY_X:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[0]);
+	case ATTR_COMPASS_SENSITIVITY_Y:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[1]);
+	case ATTR_COMPASS_SENSITIVITY_Z:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[2]);
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.accel_enable);
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_cal_enable);
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_cal_enable);
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->debug_determine_engine_on);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_calib_threshold);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_calib_rate);
+	case ATTR_FIRMWARE_LOADED:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.firmware_loaded);
+	case ATTR_POKE_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->poke_mode_on);
+	case ATTR_DMP_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.dmp_on);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_EVENT_INT_ON:
+		return snprintf(buf, MAX_WR_SZ,
+			"%d\n", st->chip_config.dmp_event_int_on);
+	case ATTR_DMP_PED_INT_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_on);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_STEP_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.step_thresh);
+	case ATTR_DMP_PED_INT_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_thresh);
+	case ATTR_DMP_PED_INT_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_mode);
+	case ATTR_DMP_SMD_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->smd.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.low_power_gyro_on);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_COMPASS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.compass_enable);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_wake_l_on);
+	case ATTR_DMP_ACTIVITY_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.activity_on);
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on);
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_COMPASS_MATRIX:
+		if (st->plat_data.sec_slave_type ==
+			SECONDARY_SLAVE_TYPE_COMPASS)
+			m = st->plat_data.secondary_orientation;
+		else
+			return -ENODEV;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_SECONDARY_NAME:
+		{
+			const char *n[] = { "NULL", "AK8975", "AK8972",
+				"AK8963", "MLX90399", "AK09911", "AK09912", "AK09916"};
+
+			switch (st->plat_data.sec_slave_id) {
+			case COMPASS_ID_AK8975:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[1]);
+			case COMPASS_ID_AK8972:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[2]);
+			case COMPASS_ID_AK8963:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[3]);
+			case COMPASS_ID_MLX90399:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[4]);
+			case COMPASS_ID_AK09911:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[5]);
+			case COMPASS_ID_AK09912:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[6]);
+			case COMPASS_ID_AK09916:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[7]);
+			default:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[0]);
+			}
+		}
+	case ATTR_DMP_DEBUG_MEM_READ:
+		{
+			int out;
+
+			inv_switch_power_in_lp(st, true);
+			result =
+				read_be32_from_mem(st, &out, debug_mem_read_addr);
+			if (result)
+				return result;
+			inv_switch_power_in_lp(st, false);
+			return snprintf(buf, MAX_WR_SZ, "0x%x\n", out);
+		}
+	case ATTR_DMP_MAGN_ACCURACY:
+		{
+			int out;
+
+			inv_switch_power_in_lp(st, true);
+			result = read_be32_from_mem(st, &out, CPASS_ACCURACY);
+			inv_switch_power_in_lp(st, false);
+			inv_switch_power_in_lp(st, false);
+
+			if (result)
+				return result;
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", out);
+		}
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[2]);
+	case ATTR_BAC_DRIVE_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_drive_conf);
+	case ATTR_BAC_WALK_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_walk_conf);
+	case ATTR_BAC_SMD_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_smd_conf);
+	case ATTR_BAC_BIKE_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_bike_conf);
+	case ATTR_BAC_STILL_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_still_conf);
+	case ATTR_BAC_RUN_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_run_conf);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_attr64_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u64 tmp;
+	u32 ped;
+
+	mutex_lock(&st->lock);
+	result = 0;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_steps(st, &ped);
+		result |= inv_read_pedometer_counter(st);
+		tmp = (u64) st->ped.step + (u64) ped;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_time(st, &ped);
+		tmp = (u64) st->ped.time + ((u64) ped) * MS_PER_PED_TICKS;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_COUNTER:
+		tmp = st->ped.last_step_time;
+		break;
+	default:
+		tmp = 0;
+		result = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&st->lock);
+	if (result)
+		return -EINVAL;
+	return snprintf(buf, MAX_WR_SZ, "%lld\n", tmp);
+}
+
+static ssize_t inv_attr64_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u8 d[4] = { 0, 0, 0, 0 };
+	u64 data;
+
+	mutex_lock(&st->lock);
+	if (!st->chip_config.firmware_loaded) {
+		mutex_unlock(&st->lock);
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		mutex_unlock(&st->lock);
+		return result;
+	}
+	result = kstrtoull(buf, 10, &data);
+	if (result)
+		goto attr64_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		result = mem_w(PEDSTD_STEPCTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.step = data;
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		result = mem_w(PEDSTD_TIMECTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.time = data;
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+attr64_store_fail:
+	mutex_unlock(&st->lock);
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+	int test_res = 0;
+	s16 accel_offset_reg[3];
+	s16 gyro_offset_reg[3];
+
+	mutex_lock(&st->lock);
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+
+	/* save the current offset registers */
+	res = inv_read_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+	if (res)
+		goto err_out;
+	/* write initial offset register values */
+	res = inv_write_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (res)
+		goto restore_regs;
+
+	res = inv_switch_power_in_lp(st, false);
+	if (res)
+		goto restore_regs;
+
+	test_res = inv_hw_self_test(st);
+
+restore_regs:
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+	/* restore offset register values */
+	inv_write_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+
+err_out:
+	inv_switch_power_in_lp(st, false);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", test_res);
+}
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, scale_t;
+	short temp;
+	u8 data[2];
+
+	mutex_lock(&st->lock);
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		mutex_unlock(&st->lock);
+		return result;
+	}
+
+	result = inv_plat_read(st, REG_TEMPERATURE, 2, data);
+	mutex_unlock(&st->lock);
+	if (result) {
+		pr_err("Could not read temperature register.\n");
+		return result;
+	}
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+	temp = (s16) (be16_to_cpup((short *)&data[0]));
+	/* convert from LSB to degC in Q16 format */
+	scale_t = TEMPERATURE_OFFSET +
+		inv_q30_mult((int)temp << MPU_TEMP_SHIFT, TEMPERATURE_SCALE);
+
+	return snprintf(buf, MAX_WR_SZ, "%d %lld\n", scale_t, get_time_ns());
+}
+
+/*
+ * inv_smd_show() -  calling this function showes smd interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_smd_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_activity_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", st->activity_size);
+}
+
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_pick_up_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+	inv_set_bank(st, BANK_SEL_0);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 0\n");
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_1);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 1\n");
+	for (ii = 0; ii < 0x2A; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_2);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 2\n");
+	for (ii = 0; ii < 0x55; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_3);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 3\n");
+	for (ii = 0; ii < 0x18; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_0);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_raw_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int res, i, mag[3];
+	u8 d[DATA_AKM_99_BYTES_DMP];
+	u8 *sens;
+
+	switch (this_attr->address) {
+	case SENSOR_L_ACCEL:
+		{
+		res = inv_plat_read(st, REG_ACCEL_XOUT_H_SH,
+						INV_RAW_DATA_BYTES, d);
+		if (res)
+			return res;
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+				(s16) (be16_to_cpup((short *)&d[0])),
+				(s16) (be16_to_cpup((short *)&d[2])),
+				(s16) (be16_to_cpup((short *)&d[4])));
+		}
+
+	case SENSOR_L_GYRO:
+		{
+		res = inv_plat_read(st, REG_GYRO_XOUT_H_SH,
+						INV_RAW_DATA_BYTES, d);
+		if (res)
+			return res;
+
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+				(s16) (be16_to_cpup((short *)&d[0])),
+				(s16) (be16_to_cpup((short *)&d[2])),
+				(s16) (be16_to_cpup((short *)&d[4])));
+
+		}
+	case SENSOR_L_MAG:
+		{
+		res = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00,
+						DATA_AKM_99_BYTES_DMP, d);
+		if (res)
+			return res;
+		sens = st->chip_info.compass_sens;
+		for (i = 0; i < 3; i++) {
+			mag[i] = (s16) (be16_to_cpup((short *)&d[i * 2 + 2]));
+			mag[i] *= (sens[i] + 128);
+			mag[i] >>= 7;
+		}
+
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+							mag[0], mag[1], mag[2]);
+		}
+	default:
+		break;
+	}
+	return 0;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+static DEVICE_ATTR(poll_smd, S_IRUGO, inv_smd_show, NULL);
+static DEVICE_ATTR(poll_pedometer, S_IRUGO, inv_ped_show, NULL);
+static DEVICE_ATTR(poll_activity, S_IRUGO, inv_activity_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO, inv_tilt_show, NULL);
+static DEVICE_ATTR(poll_pick_up, S_IRUGO, inv_pick_up_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+static IIO_DEVICE_ATTR(info_magn_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_COMPASS_MATRIX);
+
+static IIO_DEVICE_ATTR(info_secondary_name, S_IRUGO, inv_attr_show, NULL,
+			ATTR_SECONDARY_NAME);
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_magn_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_calib_magn_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_CAL);
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_WAKE);
+static IIO_DEVICE_ATTR(in_calib_magn_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_9quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_NINEQ);
+static IIO_DEVICE_ATTR(in_9quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_NINEQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PEDQ_WAKE);
+static IIO_DEVICE_ATTR(in_geomag_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_GEOMAG);
+static IIO_DEVICE_ATTR(in_geomag_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GEOMAG_WAKE);
+static IIO_DEVICE_ATTR(in_pressure_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PRESSURE);
+static IIO_DEVICE_ATTR(in_pressure_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PRESSURE_WAKE);
+static IIO_DEVICE_ATTR(in_als_px_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_ALS);
+static IIO_DEVICE_ATTR(in_als_px_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ALS_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_magn_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_calib_magn_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_CAL);
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_WAKE);
+static IIO_DEVICE_ATTR(in_calib_magn_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_9quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_NINEQ);
+static IIO_DEVICE_ATTR(in_9quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_NINEQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PEDQ_WAKE);
+static IIO_DEVICE_ATTR(in_geomag_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GEOMAG);
+static IIO_DEVICE_ATTR(in_geomag_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GEOMAG_WAKE);
+static IIO_DEVICE_ATTR(in_pressure_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PRESSURE);
+static IIO_DEVICE_ATTR(in_pressure_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PRESSURE_WAKE);
+static IIO_DEVICE_ATTR(in_als_px_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_ALS);
+static IIO_DEVICE_ATTR(in_als_px_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ALS_WAKE);
+
+/* test related raw data reading sysfs entries */
+static IIO_DEVICE_ATTR(in_accel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_magn_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_MAG);
+
+/* debug determine engine related sysfs */
+static IIO_DEVICE_ATTR(debug_anglvel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_gyro_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_GYRO_CAL_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ACCEL_CAL_ENABLE);
+
+static IIO_DEVICE_ATTR(debug_gyro_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_GYRO_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_ACCEL_ENABLE);
+static IIO_DEVICE_ATTR(debug_compass_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_COMPASS_ENABLE);
+static IIO_DEVICE_ATTR(debug_dmp_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ON);
+static IIO_DEVICE_ATTR(debug_dmp_event_int_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_EVENT_INT_ON);
+static IIO_DEVICE_ATTR(debug_mem_read, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_READ);
+static IIO_DEVICE_ATTR(debug_mem_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_WRITE);
+static IIO_DEVICE_ATTR(debug_magn_accuracy, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_DMP_MAGN_ACCURACY);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+static IIO_DEVICE_ATTR(info_firmware_loaded, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_firmware_loaded_store, ATTR_FIRMWARE_LOADED);
+static IIO_DEVICE_ATTR(info_poke_mode, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_poke_mode_store, ATTR_POKE_MODE);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+static IIO_DEVICE_ATTR(in_magn_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SCALE);
+
+static IIO_DEVICE_ATTR(in_magn_sensitivity_x, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_X);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_y, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Y);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_z, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Z);
+
+static IIO_DEVICE_ATTR(debug_low_power_gyro_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_LOW_POWER_GYRO_ON);
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_cfg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_WRITE_CFG);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+
+static IIO_DEVICE_ATTR(in_accel_x_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_X_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_Y_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_Z_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_x_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_X_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_Y_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_Z_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_magn_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_magn_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_magn_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_sc_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_SC_AUTH);
+
+static IIO_DEVICE_ATTR(in_eis_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_EIS_AUTH);
+
+static IIO_DEVICE_ATTR(debug_determine_engine_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON);
+static IIO_DEVICE_ATTR(misc_gyro_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_GYRO_RECALIBRATION);
+static IIO_DEVICE_ATTR(misc_accel_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_ACCEL_RECALIBRATION);
+static IIO_DEVICE_ATTR(params_accel_calibration_threshold, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD);
+static IIO_DEVICE_ATTR(params_accel_calibration_rate, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE);
+
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_send, S_IRUGO | S_IWUSR, NULL,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_SEND);
+static IIO_DEVICE_ATTR(in_activity_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_ACTIVITY_ON);
+
+static IIO_DEVICE_ATTR(event_smd_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_SMD_ENABLE);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(params_pedometer_int_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_ON);
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+static IIO_DEVICE_ATTR(params_pedometer_step_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_STEP_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_INT_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_MODE);
+
+static IIO_DEVICE_ATTR(out_pedometer_steps, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_STEPS);
+static IIO_DEVICE_ATTR(out_pedometer_time, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_TIME);
+static IIO_DEVICE_ATTR(out_pedometer_counter, S_IRUGO | S_IWUSR,
+			inv_attr64_show, NULL, ATTR_DMP_PEDOMETER_COUNTER);
+
+static IIO_DEVICE_ATTR(bac_drive_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_DRIVE_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_walk_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_WALK_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_smd_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_SMD_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_bike_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_BIKE_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_still_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_STILL_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_run_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_RUN_CONFIDENCE);
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+	&iio_dev_attr_in_sc_auth.dev_attr.attr,
+	&iio_dev_attr_in_eis_auth.dev_attr.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_info_firmware_loaded.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_secondary_name.dev_attr.attr,
+	&iio_dev_attr_info_poke_mode.dev_attr.attr,
+	&iio_dev_attr_debug_mem_read.dev_attr.attr,
+	&iio_dev_attr_debug_mem_write.dev_attr.attr,
+	&iio_dev_attr_debug_magn_accuracy.dev_attr.attr,
+	&iio_dev_attr_in_accel_raw.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_raw.dev_attr.attr,
+	&iio_dev_attr_in_magn_raw.dev_attr.attr,
+};
+
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_accel_enable.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_event_int_on.dev_attr.attr,
+	&iio_dev_attr_debug_low_power_gyro_on.dev_attr.attr,
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+	&iio_dev_attr_debug_cfg_write.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_on.dev_attr.attr,
+	&iio_dev_attr_debug_accel_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_accel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_determine_engine_on.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_enable.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_anglvel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_compass_enable.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_step_thresh.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_thresh.dev_attr.attr,
+	&iio_dev_attr_misc_gyro_recalibration.dev_attr.attr,
+	&iio_dev_attr_misc_accel_recalibration.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_threshold.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_9quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_9quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_9quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_9quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_calibbias.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_bias_attributes[] = {
+	&iio_dev_attr_in_anglvel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_calibbias.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_st_attributes[] = {
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+};
+
+static const struct attribute *inv_compass_attributes[] = {
+	&iio_dev_attr_in_magn_sensitivity_x.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_y.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_z.dev_attr.attr,
+	&iio_dev_attr_in_magn_scale.dev_attr.attr,
+	&iio_dev_attr_info_magn_matrix.dev_attr.attr,
+	&iio_dev_attr_in_magn_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_rate.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_geomag_enable.dev_attr.attr,
+	&iio_dev_attr_in_geomag_rate.dev_attr.attr,
+	&iio_dev_attr_in_geomag_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_geomag_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_activity.attr,
+	&dev_attr_poll_tilt.attr,
+	&dev_attr_poll_pick_up.attr,
+	&iio_dev_attr_params_pedometer_int_on.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_mode.dev_attr.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_send.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_activity_enable.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_steps.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_time.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_counter.dev_attr.attr,
+};
+
+static const struct attribute *inv_smd_attributes[] = {
+	&dev_attr_poll_smd.attr,
+	&iio_dev_attr_event_smd_enable.dev_attr.attr,
+};
+
+static const struct attribute *inv_pressure_attributes[] = {
+	&iio_dev_attr_in_pressure_enable.dev_attr.attr,
+	&iio_dev_attr_in_pressure_rate.dev_attr.attr,
+	&iio_dev_attr_in_pressure_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_pressure_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_als_attributes[] = {
+	&iio_dev_attr_in_als_px_enable.dev_attr.attr,
+	&iio_dev_attr_in_als_px_rate.dev_attr.attr,
+	&iio_dev_attr_in_als_px_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_als_px_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_bac_confidence_attributes[] = {
+	&iio_dev_attr_bac_drive_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_walk_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_smd_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_bike_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_still_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_run_confidence.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+					ARRAY_SIZE(inv_pedometer_attributes) +
+					ARRAY_SIZE(inv_smd_attributes) +
+					ARRAY_SIZE(inv_compass_attributes) +
+					ARRAY_SIZE(inv_pressure_attributes) +
+					ARRAY_SIZE(inv_als_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_gyro_bias_attributes) +
+					ARRAY_SIZE(inv_bac_confidence_attributes) +
+					ARRAY_SIZE(inv_debug_attributes) + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm20648"))
+		st->chip_type = ICM20648;
+	else
+		return -EPERM;
+
+	st->dmp_image_size = DMP_IMAGE_SIZE_20648;
+	st->dmp_start_address = DMP_START_ADDR_20648;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_smd_attributes,
+				sizeof(inv_smd_attributes));
+	t_ind += ARRAY_SIZE(inv_smd_attributes);
+
+	if (st->chip_config.has_compass) {
+		memcpy(&inv_attributes[t_ind], inv_compass_attributes,
+					sizeof(inv_compass_attributes));
+		t_ind += ARRAY_SIZE(inv_compass_attributes);
+	}
+	if (st->chip_config.has_pressure) {
+		memcpy(&inv_attributes[t_ind], inv_pressure_attributes,
+					sizeof(inv_pressure_attributes));
+		t_ind += ARRAY_SIZE(inv_pressure_attributes);
+	}
+	if (st->chip_config.has_als) {
+		memcpy(&inv_attributes[t_ind], inv_als_attributes,
+					sizeof(inv_als_attributes));
+		t_ind += ARRAY_SIZE(inv_als_attributes);
+	}
+	if (ICM20648 == st->chip_type) {
+		memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+					sizeof(inv_bias_attributes));
+		t_ind += ARRAY_SIZE(inv_bias_attributes);
+	}
+	if (st->chip_config.has_gyro) {
+		memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+					sizeof(inv_gyro_attributes));
+		t_ind += ARRAY_SIZE(inv_gyro_attributes);
+	}
+	if (ICM20648 == st->chip_type && st->chip_config.has_gyro) {
+		memcpy(&inv_attributes[t_ind], inv_gyro_bias_attributes,
+					sizeof(inv_gyro_bias_attributes));
+		t_ind += ARRAY_SIZE(inv_gyro_bias_attributes);
+	}
+
+	memcpy(&inv_attributes[t_ind], inv_bias_st_attributes,
+				sizeof(inv_bias_st_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_st_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bac_confidence_attributes,
+				sizeof(inv_bac_confidence_attributes));
+	t_ind += ARRAY_SIZE(inv_bac_confidence_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+	INIT_KFIFO(st->kf);
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+/*
+ * inv_dmp_firmware_write() -  calling this function will load the firmware.
+ */
+static ssize_t inv_dmp_firmware_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	u32 crc_value;
+
+	/*	New DMP Image - 0.2.09 -  */
+/* /system/vendor/firmware/inv_dmpfirmware.bin */
+/* from vanadium-host-hal/sources/vendor/invensense/hammerhead/proprietary */
+#define FIRMWARE_CRC_20648           0x84dcfdda
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->firmware) {
+		st->firmware = kmalloc(st->dmp_image_size, GFP_KERNEL);
+		if (!st->firmware) {
+			pr_err("no memory while loading firmware\n");
+			return -ENOMEM;
+		}
+	}
+	offset = pos;
+	memcpy(st->firmware + pos, buf, size);
+	if ((!size) && (st->dmp_image_size != pos)) {
+		pr_err("wrong size for DMP firmware 0x%08x vs 0x%08x\n",
+			offset, st->dmp_image_size);
+		kfree(st->firmware);
+		st->firmware = 0;
+		return -EINVAL;
+	}
+	if (st->dmp_image_size == (pos + size)) {
+		result = ~crc32(~0, st->firmware, st->dmp_image_size);
+		crc_value = FIRMWARE_CRC_20648;
+		pr_info("%s: firmware CRC actual:0x%08x expected:0x%08x\n",
+			__func__, result, crc_value);
+		if (crc_value != result) {
+			pr_err("%s: firmware CRC error\n", __func__);
+			return -EINVAL;
+		} else
+			pr_info("%s: CRC matched\n", __func__);
+
+		mutex_lock(&st->lock);
+		result = inv_firmware_load(st);
+		kfree(st->firmware);
+		st->firmware = 0;
+		mutex_unlock(&st->lock);
+		if (result) {
+			pr_err("firmware load failed\n");
+			return result;
+		}
+	}
+
+	return size;
+}
+
+static ssize_t inv_dmp_firmware_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&st->lock);
+	offset = off;
+	result = inv_dmp_read(st, offset, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+ssize_t inv_soft_iron_matrix_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int m[NINE_ELEM], *n, *r;
+	int i, j, k;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (size != SOFT_IRON_MATRIX_SIZE) {
+		pr_err("wrong size for soft iron matrix 0x%08x vs 0x%08x\n",
+			(u8)size, SOFT_IRON_MATRIX_SIZE);
+		return -EINVAL;
+	}
+	n = st->current_compass_matrix;
+	r = st->final_compass_matrix;
+	for (i = 0; i < NINE_ELEM; i++)
+		memcpy((u8 *) &m[i], &buf[i * sizeof(int)], sizeof(int));
+
+	for (i = 0; i < THREE_AXES; i++) {
+		for (j = 0; j < THREE_AXES; j++) {
+			r[i * THREE_AXES + j] = 0;
+			for (k = 0; k < THREE_AXES; k++)
+				r[i * THREE_AXES + j] +=
+				inv_q30_mult(m[i * THREE_AXES + k],
+						 n[j + k * THREE_AXES]);
+		}
+	}
+
+	return size;
+}
+
+ssize_t inv_accel_covariance_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int i;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (size != ACCEL_COVARIANCE_SIZE)
+		return -EINVAL;
+
+	for (i = 0; i < COVARIANCE_SIZE; i++)
+		memcpy((u8 *) &st->accel_covariance[i],
+			&buf[i * sizeof(int)], sizeof(int));
+
+	return size;
+}
+
+static int inv_handle_poke(struct inv_mpu_state *st, char *buf,
+			int addr, int size)
+{
+	int result, wait_times;
+	u8 dd[1];
+
+	if (!st->poke_mode_on)
+		return -EINVAL;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	wait_times  = 0;
+	result = inv_plat_read(st, REG_DMP_START_MODE, 1, dd);
+	while ((dd[0] != 1) && (wait_times < 5)) {
+		usleep_range(1000, 1000);
+		result = inv_plat_read(st, REG_DMP_START_MODE, 1, dd);
+		wait_times++;
+	}
+	if (dd[0] != 1)
+		return -EINVAL;
+
+	mem_w(addr, size, buf);
+	result = inv_plat_single_write(st, REG_DMP_START_MODE,
+			BIT_DMP_POKE | BIT_DMP_START_MODE);
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static ssize_t inv_poke_write_accel(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, scale, i;
+	short accel_data[3];
+	int input_accel[3];
+	short input_buf[3];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+	scale = 2;
+	switch (st->chip_config.accel_fs) {
+	case 0:
+		scale = 2;
+		break;
+	case 1:
+		scale = 4;
+		break;
+	case 2:
+		scale = 8;
+		break;
+	case 3:
+		scale = 16;
+		break;
+	default:
+		break;
+	}
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_accel[i], buf + i * 4,
+				sizeof(input_accel[i]));
+		accel_data[i] = (short)(input_accel[i] * 2 / scale);
+		input_buf[i] = cpu_to_be16(accel_data[i]);
+	}
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_ACCEL_OFFSET_TO_TS,
+			sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, (char *)&input_buf[0],
+			INV_DMP_ACCEL_START_ADDR, BYTES_PER_SENSOR);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static ssize_t inv_poke_write_gyro(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, scale, i;
+	short gyro_data[3];
+	int input_gyro[3];
+	short input_buf[3];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+	scale = 250;
+	switch (st->chip_config.fsr) {
+	case 0:
+		scale = 250;
+		break;
+	case 1:
+		scale = 500;
+		break;
+	case 2:
+		scale = 1000;
+		break;
+	case 3:
+		scale = 2000;
+		break;
+	default:
+		break;
+	}
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_gyro[i], buf + i * 4,
+				sizeof(input_gyro[i]));
+		gyro_data[i] = (short)(input_gyro[i] * 250 / scale);
+		input_buf[i] = cpu_to_be16(gyro_data[i]);
+	}
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_GYRO_OFFSET_TO_TS,
+			sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, (char *)&input_buf[0],
+			INV_DMP_GYRO_START_ADDR, BYTES_PER_SENSOR);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static ssize_t inv_poke_write_mag(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, i;
+	short mag_data[3];
+	int input_mag[3];
+	short input_buf[3];
+	char buf_data[DATA_AKM_99_BYTES_DMP];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+	for (i = 0; i < DATA_AKM_99_BYTES_DMP; i++)
+		buf_data[i] = 0;
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_mag[i], buf + i * 4,
+					sizeof(input_mag[i]));
+		mag_data[i] = (short)(input_mag[i]);
+		input_buf[i] = cpu_to_be16(mag_data[i]);
+		memcpy(buf_data + 2 + i * 2, &input_buf[i],
+							sizeof(input_buf[i]));
+	}
+	buf_data[0] = 1;
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_ACCEL_OFFSET_TO_TS,
+						sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, buf_data, INV_DMP_MAG_START_ADDR,
+							DATA_AKM_99_BYTES_DMP);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static int inv_dmp_covar_read(struct inv_mpu_state *st,
+			int off, int size, u8 *buf)
+{
+	int data, result, i;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+	for (i = 0; i < COVARIANCE_SIZE * sizeof(int); i += sizeof(int)) {
+		result = read_be32_from_mem(st, (u32 *) &data, off + i);
+		if (result)
+			return result;
+		memcpy(buf + i, (u8 *) &data, sizeof(int));
+	}
+
+	return 0;
+}
+
+int inv_accel_covariance_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&st->lock);
+	result = inv_dmp_covar_read(st, ACCEL_COVARIANCE, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_activity_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int copied;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	u8 ddd[128];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+	copied = kfifo_out(&st->kf, ddd, count);
+	memcpy(buf, ddd, copied);
+	mutex_unlock(&st->lock);
+
+	return copied;
+}
+
+/*
+ *  inv_create_dmp_sysfs() - create binary sysfs dmp entry.
+ */
+static struct bin_attribute dmp_firmware = {
+	.attr = {
+		.name = "misc_bin_dmp_firmware",
+		.mode = S_IRUGO | S_IWUGO},
+	.read = inv_dmp_firmware_read,
+	.write = inv_dmp_firmware_write,
+};
+
+#if 0
+static const struct bin_attribute soft_iron_matrix = {
+	.attr = {
+		.name = "misc_bin_soft_iron_matrix",
+		.mode = S_IRUGO | S_IWUGO},
+	.size = SOFT_IRON_MATRIX_SIZE,
+	.write = inv_soft_iron_matrix_write,
+};
+
+static const struct bin_attribute accel_covariance = {
+	.attr = {
+		.name = "misc_bin_accel_covariance",
+		.mode = S_IRUGO | S_IWUGO},
+	.size = ACCEL_COVARIANCE_SIZE,
+	.write = inv_accel_covariance_write,
+	.read = inv_accel_covariance_read,
+};
+#endif
+
+static const struct bin_attribute input_poke_gyro = {
+	.attr = {
+		.name = "misc_bin_poke_gyro",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_GYRO,
+	.write = inv_poke_write_gyro,
+};
+
+static const struct bin_attribute input_poke_accel = {
+	.attr = {
+		.name = "misc_bin_poke_accel",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_ACCEL,
+	.write = inv_poke_write_accel,
+};
+
+static const struct bin_attribute input_poke_mag = {
+	.attr = {
+		.name = "misc_bin_poke_mag",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_MAG,
+	.write = inv_poke_write_mag,
+};
+
+static const struct bin_attribute activity_bin = {
+	.attr = {
+		.name = "misc_bin_activity_out",
+		.mode = S_IRUGO},
+	.size = HARDWARE_FIFO_SIZE,
+	.read = inv_activity_read,
+};
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	int result = 0;
+	struct inv_mpu_state *st = iio_priv(ind);
+
+	dmp_firmware.size = st->dmp_image_size;
+
+	result = sysfs_create_bin_file(&ind->dev.kobj, &dmp_firmware);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &activity_bin);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_gyro);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_accel);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_mag);
+	if (result)
+		return result;
+
+#if 0
+	result = sysfs_create_bin_file(&ind->dev.kobj, &soft_iron_matrix);
+	if (result)
+		return result;
+
+	result = sysfs_create_bin_file(&ind->dev.kobj, &accel_covariance);
+	if (result)
+		return result;
+#endif
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c
new file mode 100644
index 000000000000..b405ff6874a5
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2017-2018 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_get_step_params(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	st->prev_steps = st->curr_steps;
+	result |= read_be32_from_mem(st, &st->curr_steps, PEDSTD_STEPCTR);
+	result |= read_be32_from_mem(st, &st->ts_algo.start_dmp_counter,
+								DMPRATE_CNTR);
+	result |= inv_switch_power_in_lp(st, false);
+
+	return result;
+}
+/**
+  * static int inv_prescan_data(struct inv_mpu_state *st, u8 * dptr, int len)
+  *  prescan data to know what type of data and how many samples of data
+  *  in current FIFO reading.
+*/
+static int inv_prescan_data(struct inv_mpu_state *st, u8 *dptr, int len)
+{
+	int res, pk_size, i;
+	bool done_flag;
+	u16 hdr;
+
+	done_flag = false;
+	st->header_count = 0;
+	st->step_det_count = 0;
+	st->ts_algo.calib_counter++;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].count = 0;
+	while (!done_flag) {
+		if (len > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			if (!hdr) {
+				pr_err("error header zero\n");
+				st->left_over_size = 0;
+				return -EINVAL;
+			}
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				if (!st->chip_config.is_asleep)
+					pr_err
+				("prescan error in header parsing=%x size=%d\n",
+				hdr, len);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (len >= pk_size) {
+				inv_pre_parse_packet(st, hdr, dptr + HEADER_SZ);
+				len -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	if (st->step_det_count)
+		inv_get_step_params(st);
+	inv_bound_timestamp(st);
+
+	return 0;
+}
+
+int inv_process_dmp_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size;
+	u8 *dptr, *d;
+	u16 hdr;
+	u8 data[2];
+	bool done_flag;
+
+	st->ts_algo.last_run_time = get_time_ns();
+	res = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, data);
+	if (res) {
+		pr_debug("read REG_FIFO_COUNT_H failed\n");
+		return res;
+	}
+	fifo_count = be16_to_cpup((__be16 *) (data));
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+
+	if (fifo_count >= HARDWARE_FIFO_SIZE) {
+		pr_warn("fifo overflow fifo_count=%d\n", fifo_count);
+		return -EOVERFLOW;
+	}
+
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		pr_debug("left over size error\n");
+		return -EINVAL;
+	}
+
+	if (st->left_over_size > 0)
+		memcpy(d, st->left_over, st->left_over_size);
+
+	dptr = d + st->left_over_size;
+	total_bytes = fifo_count;
+	while (total_bytes > 0) {
+		if (total_bytes < MAX_FIFO_READ_SIZE)
+			tmp = total_bytes;
+		else
+			tmp = MAX_FIFO_READ_SIZE;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_debug("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+	dptr = d;
+	total_bytes = fifo_count + st->left_over_size;
+	res = inv_prescan_data(st, dptr, total_bytes);
+	if (res) {
+		pr_info("prescan failed\n");
+		return -EINVAL;
+	}
+	dptr = d;
+	done_flag = false;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n", d[0], d[1], d[2],
+						d[3], d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n", d[8], d[9], d[10],
+					d[11], d[12], d[13], d[14], d[15]);
+	while (!done_flag) {
+		if (total_bytes > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				pr_err
+		("processing error in header parsing=%x fifo_count= %d\n",
+		hdr, fifo_count);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (total_bytes >= pk_size) {
+				inv_parse_packet(indio_dev, hdr, dptr + HEADER_SZ);
+				total_bytes -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	st->left_over_size = total_bytes;
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		return -EINVAL;
+	}
+
+	if (st->left_over_size)
+		memcpy(st->left_over, dptr, st->left_over_size);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h
new file mode 100644
index 000000000000..7a075406721b
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_20648_H_
+#define _INV_MPU_IIO_20648_H_
+
+/* #define DEBUG */
+
+/* #define BIAS_CONFIDENCE_HIGH 1 */
+
+/* register and associated bit definition */
+/* bank 0 register map */
+#define REG_WHO_AM_I            0x00
+
+#define REG_USER_CTRL           0x03
+#define BIT_DMP_EN                      0x80
+#define BIT_FIFO_EN                     0x40
+#define BIT_I2C_MST_EN                  0x20
+#define BIT_I2C_IF_DIS                  0x10
+#define BIT_DMP_RST                     0x08
+
+#define REG_LP_CONFIG           0x05
+#define BIT_I2C_MST_CYCLE               0x40
+#define BIT_ACCEL_CYCLE                 0x20
+#define BIT_GYRO_CYCLE                  0x10
+
+#define REG_PWR_MGMT_1          0x06
+#define BIT_H_RESET                     0x80
+#define BIT_SLEEP                       0x40
+#define BIT_LP_EN                       0x20
+#define BIT_CLK_PLL                     0x01
+
+#define REG_PWR_MGMT_2          0x07
+#define BIT_PWR_PRESSURE_STBY           0x40
+#define BIT_PWR_ACCEL_STBY              0x38
+#define BIT_PWR_GYRO_STBY               0x07
+#define BIT_PWR_ALL_OFF                 0x7f
+
+#define REG_INT_PIN_CFG         0x0F
+#define BIT_BYPASS_EN                   0x2
+
+#define REG_INT_ENABLE          0x10
+#define BIT_DMP_INT_EN                  0x02
+#define BIT_WOM_INT_EN                  0x08
+
+#define REG_INT_ENABLE_1        0x11
+#define BIT_DATA_RDY_3_EN               0x08
+#define BIT_DATA_RDY_2_EN               0x04
+#define BIT_DATA_RDY_1_EN               0x02
+#define BIT_DATA_RDY_0_EN               0x01
+
+#define REG_INT_ENABLE_2        0x12
+#define BIT_FIFO_OVERFLOW_EN_0          0x1
+
+#define REG_INT_ENABLE_3        0x13
+#define REG_DMP_INT_STATUS      0x18
+#define REG_INT_STATUS          0x19
+#define REG_INT_STATUS_1        0x1A
+
+#define REG_ACCEL_XOUT_H_SH     0x2D
+
+#define REG_GYRO_XOUT_H_SH      0x33
+
+#define REG_DMP_START_MODE      0x27
+#define BIT_DMP_POKE                   0x2
+#define BIT_DMP_START_MODE             0x1
+
+#define REG_TEMPERATURE         0x39
+
+#define REG_EXT_SLV_SENS_DATA_00 0x3B
+#define REG_EXT_SLV_SENS_DATA_08 0x43
+#define REG_EXT_SLV_SENS_DATA_09 0x44
+#define REG_EXT_SLV_SENS_DATA_10 0x45
+
+#define REG_FIFO_EN             0x66
+#define BIT_SLV_0_FIFO_EN               1
+
+#define REG_FIFO_EN_2           0x67
+#define BIT_PRS_FIFO_EN                 0x20
+#define BIT_ACCEL_FIFO_EN               0x10
+#define BITS_GYRO_FIFO_EN               0x0E
+
+#define REG_FIFO_RST            0x68
+
+#define REG_FIFO_SIZE_0         0x6E
+#define BIT_ACCEL_FIFO_SIZE_128         0x00
+#define BIT_ACCEL_FIFO_SIZE_256         0x04
+#define BIT_ACCEL_FIFO_SIZE_512         0x08
+#define BIT_ACCEL_FIFO_SIZE_1024        0x0C
+#define BIT_GYRO_FIFO_SIZE_128          0x00
+#define BIT_GYRO_FIFO_SIZE_256          0x01
+#define BIT_GYRO_FIFO_SIZE_512          0x02
+#define BIT_GYRO_FIFO_SIZE_1024         0x03
+#define BIT_FIFO_SIZE_1024              0x01
+#define BIT_FIFO_SIZE_512               0x00
+#define BIT_FIFO_3_SIZE_256             0x40
+#define BIT_FIFO_3_SIZE_64              0x00
+
+#define REG_FIFO_COUNT_H        0x70
+#define REG_FIFO_R_W            0x72
+
+#define REG_FIFO_CFG            0x76
+#define BIT_MULTI_FIFO_CFG              0x01
+#define BIT_SINGLE_FIFO_CFG             0x00
+#define BIT_GYRO_FIFO_NUM               (0 << 2)
+#define BIT_ACCEL_FIFO_NUM              (1 << 2)
+#define BIT_PRS_FIFO_NUM                2
+#define BIT_EXT_FIFO_NUM                3
+
+#define REG_MEM_START_ADDR      0x7C
+#define REG_MEM_R_W             0x7D
+#define REG_MEM_BANK_SEL        0x7E
+
+/* bank 1 register map */
+#define REG_XA_OFFS_H           0x14
+#define REG_YA_OFFS_H           0x17
+#define REG_ZA_OFFS_H           0x1A
+
+#define REG_TIMEBASE_CORRECTION_PLL 0x28
+#define REG_TIMEBASE_CORRECTION_RCOSC 0x29
+#define REG_SELF_TEST1                0x02
+#define REG_SELF_TEST2                0x03
+#define REG_SELF_TEST3                0x04
+#define REG_SELF_TEST4                0x0E
+#define REG_SELF_TEST5                0x0F
+#define REG_SELF_TEST6                0x10
+
+/* bank 2 register map */
+#define REG_GYRO_SMPLRT_DIV     0x00
+
+#define REG_GYRO_CONFIG_1       0x01
+#define SHIFT_GYRO_FS_SEL               1
+#define BIT_GYRO_DLPCFG_184Hz           (1 << 3)
+#define BIT_GYRO_FCHOICE                1
+
+#define REG_GYRO_CONFIG_2       0x02
+#define BIT_GYRO_CTEN                   0x38
+
+#define REG_XG_OFFS_USR_H       0x03
+#define REG_YG_OFFS_USR_H       0x05
+#define REG_ZG_OFFS_USR_H       0x07
+
+#define REG_ODR_ALIGN_EN        0x09
+#define BIT_ODR_ALIGN_EN                   1
+
+#define REG_ACCEL_SMPLRT_DIV_1  0x10
+#define REG_ACCEL_SMPLRT_DIV_2  0x11
+
+#define REG_ACCEL_WOM_THR       0x13
+
+#define REG_ACCEL_CONFIG        0x14
+#define BIT_ACCEL_FCHOICE               1
+#define SHIFT_ACCEL_FS                  1
+#define SHIFT_ACCEL_DLPCFG              3
+#define ACCEL_CONFIG_LOW_POWER_SET      7
+
+#define REG_ACCEL_CONFIG_2       0x15
+#define BIT_ACCEL_CTEN                  0x1C
+
+#define REG_PRS_ODR_CONFIG      0x20
+#define REG_PRGM_START_ADDRH    0x50
+
+#define REG_FSYNC_CONFIG        0x52
+#define BIT_TRIGGER_EIS                 0x91
+
+#define REG_MOD_CTRL_USR        0x54
+#define BIT_ODR_SYNC                    0x7
+
+/* bank 3 register map */
+#define REG_I2C_MST_ODR_CONFIG  0
+
+#define REG_I2C_MST_CTRL         1
+#define BIT_I2C_MST_P_NSR       0x10
+
+#define REG_I2C_MST_DELAY_CTRL  0x02
+#define BIT_DELAY_ES_SHADOW     0x80
+#define BIT_SLV0_DLY_EN                 0x01
+#define BIT_SLV1_DLY_EN                 0x02
+#define BIT_SLV2_DLY_EN                 0x04
+#define BIT_SLV3_DLY_EN                 0x08
+
+#define REG_I2C_SLV0_ADDR       0x03
+#define REG_I2C_SLV0_REG        0x04
+#define REG_I2C_SLV0_CTRL       0x05
+#define REG_I2C_SLV0_DO         0x06
+
+#define REG_I2C_SLV1_ADDR       0x07
+#define REG_I2C_SLV1_REG        0x08
+#define REG_I2C_SLV1_CTRL       0x09
+#define REG_I2C_SLV1_DO         0x0A
+
+#define REG_I2C_SLV2_ADDR       0x0B
+#define REG_I2C_SLV2_REG        0x0C
+#define REG_I2C_SLV2_CTRL       0x0D
+#define REG_I2C_SLV2_DO         0x0E
+
+#define REG_I2C_SLV3_ADDR       0x0F
+#define REG_I2C_SLV3_REG        0x10
+#define REG_I2C_SLV3_CTRL       0x11
+#define REG_I2C_SLV3_DO         0x12
+
+#define REG_I2C_SLV4_CTRL       0x15
+
+#define INV_MPU_BIT_SLV_EN      0x80
+#define INV_MPU_BIT_BYTE_SW     0x40
+#define INV_MPU_BIT_REG_DIS     0x20
+#define INV_MPU_BIT_GRP         0x10
+#define INV_MPU_BIT_I2C_READ    0x80
+
+/* register for all banks */
+#define REG_BANK_SEL            0x7F
+#define BANK_SEL_0                      0x00
+#define BANK_SEL_1                      0x10
+#define BANK_SEL_2                      0x20
+#define BANK_SEL_3                      0x30
+
+/* data definitions */
+#define BYTES_PER_SENSOR         6
+#define FIFO_COUNT_BYTE          2
+#define HARDWARE_FIFO_SIZE       1024
+#define FIFO_SIZE                (HARDWARE_FIFO_SIZE * 7 / 8)
+#define POWER_UP_TIME            100
+#define REG_UP_TIME_USEC         100
+#define DMP_RESET_TIME           20
+#define GYRO_ENGINE_UP_TIME      50
+#define MPU_MEM_BANK_SIZE        256
+#define IIO_BUFFER_BYTES         8
+#define HEADERED_NORMAL_BYTES    8
+#define HEADERED_Q_BYTES         16
+#define LEFT_OVER_BYTES          128
+#define BASE_SAMPLE_RATE         1125
+#define DRY_RUN_TIME             50
+/* initial rate is important. For DMP mode, it is set as 1 since DMP decimate*/
+#define MPU_INIT_SENSOR_RATE     1
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY         3
+#else
+#define DEFAULT_ACCURACY         1
+#endif
+
+#define FREQ_225
+
+#ifdef FREQ_225
+#define MPU_DEFAULT_DMP_FREQ     225
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 2)
+#define PED_ACCEL_GAIN           67108864L
+#define DEFAULT_ACCEL_GAIN       (33554432L * 5 / 11)
+#define DEFAULT_ACCEL_GAIN_112       (33554432L * 10 / 11)
+#define ALPHA_FILL_FULL          1020054733
+#define A_FILL_FULL              53687091
+#else
+#define MPU_DEFAULT_DMP_FREQ     102
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 1)
+#define PED_ACCEL_GAIN           67108864L
+#define DEFAULT_ACCEL_GAIN       33554432L
+#define ALPHA_FILL_FULL          966367642
+#define A_FILL_FULL              107374182
+#endif
+#define ALPHA_FILL_PED           858993459
+#define A_FILL_PED               214748365
+
+#define DMP_OFFSET               0x90
+#define DMP_IMAGE_SIZE_20648           (14250 + DMP_OFFSET)
+#define MIN_MST_ODR_CONFIG       4
+#define MAX_MST_ODR_CONFIG       5
+#define MAX_COMPASS_RATE    100
+#define MAX_MST_NON_COMPASS_ODR_CONFIG 7
+#define THREE_AXES               3
+#define NINE_ELEM                (THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT           16
+#define SOFT_IRON_MATRIX_SIZE    (4 * 9)
+#define DMP_DIVIDER              (BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define MAX_5_BIT_VALUE          0x1F
+#define BAD_COMPASS_DATA         0x7FFF
+#define BAD_CAL_COMPASS_DATA     0x7FFF0000
+#define DEFAULT_BATCH_RATE       400
+#define DEFAULT_BATCH_TIME    (MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+#define NINEQ_DEFAULT_COMPASS_RATE 25
+#define DMP_ACCEL_SCALE_2G       0x2000000 /* scale for Q25 */
+#define DMP_ACCEL_SCALE2_2G      0x80000   /* scale back to LSB */
+
+#define SENCONDARY_GYRO_OFF       0x01
+#define SENCONDARY_GYRO_ON        0x02
+#define SENCONDARY_COMPASS_OFF    0x04
+#define SENCONDARY_COMPASS_ON     0x08
+#define SENCONDARY_PROX_OFF       0x10
+#define SENCONDARY_PROX_ON        0x20
+
+#define NINEQ_MIN_COMPASS_RATE 35
+#define GEOMAG_MIN_COMPASS_RATE    70
+
+#define MAX_PRESSURE_RATE        30
+#define MAX_ALS_RATE             5
+#define DATA_AKM_99_BYTES_DMP  10
+#define DATA_AKM_89_BYTES_DMP  9
+#define DATA_ALS_BYTES_DMP     8
+#define APDS9900_AILTL_REG      0x04
+#define BMP280_DIG_T1_LSB_REG                0x88
+#define INV_RAW_DATA_BYTES             6
+/* poke feature related. */
+#define INV_POKE_SIZE_GYRO           20
+#define INV_POKE_GYRO_OFFSET_TO_TS  12
+#define INV_DMP_GYRO_START_ADDR      10
+#define INV_POKE_SIZE_ACCEL          20
+#define INV_POKE_ACCEL_OFFSET_TO_TS  12
+#define INV_DMP_ACCEL_START_ADDR     4
+#define INV_POKE_SIZE_MAG           20
+#define INV_POKE_MAG_OFFSET_TO_TS  12
+#define INV_DMP_MAG_START_ADDR     18
+
+#define TEMPERATURE_SCALE  3216048L	/* 2^30 / 333.87 */
+#define TEMPERATURE_OFFSET 1376256L	/* 21degC in Q16 */
+#define SECONDARY_INIT_WAIT 100
+#define SW_REV_NO_RUN_FLAG              8
+#define AK99XX_SHIFT                    23
+#define AK89XX_SHIFT                    22
+
+/* this is derived from 1000 divided by 55, which is the pedometer
+   running frequency */
+#define MS_PER_PED_TICKS         18
+
+/* data limit definitions */
+#define MIN_FIFO_RATE            4
+#define MAX_FIFO_RATE            MPU_DEFAULT_DMP_FREQ
+#define MAX_DMP_OUTPUT_RATE      MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM              8192
+#define MAX_PRS_RATE             281
+#define MIN_COMPASS_RATE         35
+
+/* enum for sensor
+   The sequence is important.
+   It represents the order of apperance from DMP */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_ALS,
+	SENSOR_SIXQ,
+	SENSOR_NINEQ,
+	SENSOR_PEDQ,
+	SENSOR_GEOMAG,
+	SENSOR_PRESSURE,
+	SENSOR_COMPASS_CAL,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_devices {
+	ICM20648,
+	INV_NUM_PARTS
+};
+#endif /* #ifndef _INV_MPU_IIO_20648_H_ */
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c
new file mode 100644
index 000000000000..70c4dfb869fe
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c
@@ -0,0 +1,562 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	{128, "ICM20648"},
+};
+
+static int inv_set_dmp(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH,
+				st->dmp_start_address >> 8);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH + 1,
+				st->dmp_start_address & 0xff);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+	int result;
+	u8 d;
+	s8 t;
+
+/* ((20 * 1270 * NSEC_PER_SEC)/(27 * 1000 * 768)) */
+#define INV_PRECISION_CONST 1224922
+
+
+	result = inv_set_bank(st, BANK_SEL_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_TIMEBASE_CORRECTION_PLL, 1, &d);
+	if (result)
+		return result;
+	t = abs(d & 0x7f);
+	if (d & 0x80)
+		t = -t;
+	st->eis.count_precision = INV_PRECISION_CONST / (1270 + t);
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = (NSEC_PER_SEC / (1270 + t)) * 1270;
+	st->eng_info[ENGINE_PRESSURE].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_PRESSURE].orig_rate = MAX_PRS_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(t);
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 averaging = 4;
+	u8 dec3_cfg;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				(st->chip_config.fsr
+				<< SHIFT_GYRO_FS_SEL) |
+				BIT_GYRO_FCHOICE);
+	if (result)
+		return result;
+	switch (averaging) {
+	case 1:
+		dec3_cfg = 0;
+		break;
+	case 2:
+		dec3_cfg = 1;
+		break;
+	case 4:
+		dec3_cfg = 2;
+		break;
+	case 8:
+		dec3_cfg = 3;
+		break;
+	case 16:
+		dec3_cfg = 4;
+		break;
+	case 32:
+		dec3_cfg = 5;
+		break;
+	case 64:
+		dec3_cfg = 6;
+		break;
+	case 128:
+		dec3_cfg = 7;
+		break;
+	default:
+		dec3_cfg = 0;
+		break;
+	}
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_2, dec3_cfg);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 averaging = 1;
+	u8 dec3_cfg;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* The FCHOICE is 1 even in cycle mode so that averaging is 4 */
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			(st->chip_config. accel_fs << SHIFT_ACCEL_FS) |
+			(ACCEL_CONFIG_LOW_POWER_SET << SHIFT_ACCEL_DLPCFG) |
+			BIT_ACCEL_FCHOICE);
+	if (result)
+		return result;
+	switch (averaging) {
+	case 4:
+		dec3_cfg = 0;
+		break;
+	case 8:
+		dec3_cfg = 1;
+		break;
+	case 16:
+		dec3_cfg = 2;
+		break;
+	case 32:
+		dec3_cfg = 3;
+		break;
+	default:
+		dec3_cfg = 0;
+		break;
+	}
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, dec3_cfg);
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_set_secondary(struct inv_mpu_state *st)
+{
+	int r;
+
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_CTRL, BIT_I2C_MST_P_NSR);
+	if (r)
+		return r;
+
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+					MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+
+	r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+					BIT_DELAY_ES_SHADOW);
+	if (r)
+		return r;
+
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	return r;
+}
+
+static int inv_init_secondary(struct inv_mpu_state *st)
+{
+	st->slv_reg[0].addr = REG_I2C_SLV0_ADDR;
+	st->slv_reg[0].reg = REG_I2C_SLV0_REG;
+	st->slv_reg[0].ctrl = REG_I2C_SLV0_CTRL;
+	st->slv_reg[0].d0 = REG_I2C_SLV0_DO;
+
+	st->slv_reg[1].addr = REG_I2C_SLV1_ADDR;
+	st->slv_reg[1].reg = REG_I2C_SLV1_REG;
+	st->slv_reg[1].ctrl = REG_I2C_SLV1_CTRL;
+	st->slv_reg[1].d0 = REG_I2C_SLV1_DO;
+
+	st->slv_reg[2].addr = REG_I2C_SLV2_ADDR;
+	st->slv_reg[2].reg = REG_I2C_SLV2_REG;
+	st->slv_reg[2].ctrl = REG_I2C_SLV2_CTRL;
+	st->slv_reg[2].d0 = REG_I2C_SLV2_DO;
+
+	st->slv_reg[3].addr = REG_I2C_SLV3_ADDR;
+	st->slv_reg[3].reg = REG_I2C_SLV3_REG;
+	st->slv_reg[3].ctrl = REG_I2C_SLV3_CTRL;
+	st->slv_reg[3].d0 = REG_I2C_SLV3_DO;
+
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = ACCEL_DATA_SZ;
+	st->sensor[SENSOR_GYRO].sample_size = GYRO_DATA_SZ;
+	st->sensor[SENSOR_COMPASS].sample_size = CPASS_DATA_SZ;
+	st->sensor[SENSOR_COMPASS_CAL].sample_size = CPASS_CALIBR_DATA_SZ;
+	st->sensor[SENSOR_ALS].sample_size = ALS_DATA_SZ;
+	st->sensor[SENSOR_PRESSURE].sample_size = PRESSURE_DATA_SZ;
+	st->sensor[SENSOR_SIXQ].sample_size = QUAT6_DATA_SZ;
+	st->sensor[SENSOR_NINEQ].sample_size = QUAT9_DATA_SZ;
+	st->sensor[SENSOR_PEDQ].sample_size = PQUAT6_DATA_SZ;
+	st->sensor[SENSOR_GEOMAG].sample_size = GEOMAG_DATA_SZ;
+
+	st->sensor[SENSOR_ACCEL].odr_addr = ODR_ACCEL;
+	st->sensor[SENSOR_GYRO].odr_addr = ODR_GYRO;
+	st->sensor[SENSOR_COMPASS].odr_addr = ODR_CPASS;
+	st->sensor[SENSOR_COMPASS_CAL].odr_addr = ODR_CPASS_CALIBR;
+	st->sensor[SENSOR_ALS].odr_addr = ODR_ALS;
+	st->sensor[SENSOR_PRESSURE].odr_addr = ODR_PRESSURE;
+	st->sensor[SENSOR_SIXQ].odr_addr = ODR_QUAT6;
+	st->sensor[SENSOR_NINEQ].odr_addr = ODR_QUAT9;
+	st->sensor[SENSOR_PEDQ].odr_addr = ODR_PQUAT6;
+	st->sensor[SENSOR_GEOMAG].odr_addr = ODR_GEOMAG;
+
+	st->sensor[SENSOR_ACCEL].counter_addr = ODR_CNTR_ACCEL;
+	st->sensor[SENSOR_GYRO].counter_addr = ODR_CNTR_GYRO;
+	st->sensor[SENSOR_COMPASS].counter_addr = ODR_CNTR_CPASS;
+	st->sensor[SENSOR_COMPASS_CAL].counter_addr = ODR_CNTR_CPASS_CALIBR;
+	st->sensor[SENSOR_ALS].counter_addr = ODR_CNTR_ALS;
+	st->sensor[SENSOR_PRESSURE].counter_addr = ODR_CNTR_PRESSURE;
+	st->sensor[SENSOR_SIXQ].counter_addr = ODR_CNTR_QUAT6;
+	st->sensor[SENSOR_NINEQ].counter_addr = ODR_CNTR_QUAT9;
+	st->sensor[SENSOR_PEDQ].counter_addr = ODR_CNTR_PQUAT6;
+	st->sensor[SENSOR_GEOMAG].counter_addr = ODR_CNTR_GEOMAG;
+
+	st->sensor[SENSOR_ACCEL].output = ACCEL_SET;
+	st->sensor[SENSOR_GYRO].output = GYRO_SET;
+	st->sensor[SENSOR_COMPASS].output = CPASS_SET;
+	st->sensor[SENSOR_COMPASS_CAL].output = CPASS_CALIBR_SET;
+	st->sensor[SENSOR_ALS].output = ALS_SET;
+	st->sensor[SENSOR_PRESSURE].output = PRESSURE_SET;
+	st->sensor[SENSOR_SIXQ].output = QUAT6_SET;
+	st->sensor[SENSOR_NINEQ].output = QUAT9_SET;
+	st->sensor[SENSOR_PEDQ].output = PQUAT6_SET;
+	st->sensor[SENSOR_GEOMAG].output = GEOMAG_SET;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+	st->sensor[SENSOR_COMPASS].a_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].a_en = false;
+	st->sensor[SENSOR_ALS].a_en = false;
+	st->sensor[SENSOR_PRESSURE].a_en = false;
+	st->sensor[SENSOR_SIXQ].a_en = true;
+	st->sensor[SENSOR_NINEQ].a_en = true;
+	st->sensor[SENSOR_PEDQ].a_en = true;
+	st->sensor[SENSOR_GEOMAG].a_en = true;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+	st->sensor[SENSOR_COMPASS].g_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].g_en = false;
+	st->sensor[SENSOR_ALS].g_en = false;
+	st->sensor[SENSOR_PRESSURE].g_en = false;
+	st->sensor[SENSOR_SIXQ].g_en = true;
+	st->sensor[SENSOR_NINEQ].g_en = true;
+	st->sensor[SENSOR_PEDQ].g_en = true;
+	st->sensor[SENSOR_GEOMAG].g_en = false;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+	st->sensor[SENSOR_COMPASS].c_en = true;
+	st->sensor[SENSOR_COMPASS_CAL].c_en = true;
+	st->sensor[SENSOR_ALS].c_en = false;
+	st->sensor[SENSOR_PRESSURE].c_en = false;
+	st->sensor[SENSOR_SIXQ].c_en = false;
+	st->sensor[SENSOR_NINEQ].c_en = true;
+	st->sensor[SENSOR_PEDQ].c_en = false;
+	st->sensor[SENSOR_GEOMAG].c_en = true;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+	st->sensor[SENSOR_COMPASS].p_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].p_en = false;
+	st->sensor[SENSOR_ALS].p_en = false;
+	st->sensor[SENSOR_PRESSURE].p_en = true;
+	st->sensor[SENSOR_SIXQ].p_en = false;
+	st->sensor[SENSOR_NINEQ].p_en = false;
+	st->sensor[SENSOR_PEDQ].p_en = false;
+	st->sensor[SENSOR_GEOMAG].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_COMPASS].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_ALS].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_PRESSURE].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_SIXQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_NINEQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_PEDQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_GEOMAG].engine_base = ENGINE_ACCEL;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_MAG_CAL].base = SENSOR_COMPASS_CAL;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_NINEQ].base = SENSOR_NINEQ;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_PEDQ;
+	st->sensor_l[SENSOR_L_PRESSURE].base = SENSOR_PRESSURE;
+	st->sensor_l[SENSOR_L_ALS].base = SENSOR_ALS;
+	st->sensor_l[SENSOR_L_GEOMAG].base = SENSOR_GEOMAG;
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG_WAKE].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_ALS_WAKE].base = SENSOR_ALS;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].base = SENSOR_NINEQ;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_PEDQ;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].base = SENSOR_GEOMAG;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].base = SENSOR_PRESSURE;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].base = SENSOR_COMPASS_CAL;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+	st->sensor_l[SENSOR_L_MAG].header = COMPASS_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL].header = COMPASS_CALIB_HDR;
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE].header = PRESSURE_HDR;
+	st->sensor_l[SENSOR_L_ALS].header = ALS_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG].header = GEOMAG_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].header = PRESSURE_WAKE_HDR;
+	st->sensor_l[SENSOR_L_ALS_WAKE].header = ALS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].header = GEOMAG_WAKE_HDR;
+
+	for (i = SENSOR_L_ACCEL; i <= SENSOR_L_EIS_GYRO; i++)
+		st->sensor_l[i].wake_on = false;
+
+	for (i = SENSOR_L_ACCEL_WAKE; i <= SENSOR_L_MAG_CAL_WAKE; i++)
+		st->sensor_l[i].wake_on = true;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].sample_size =
+			ACCEL_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].sample_size =
+			GYRO_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].sample_size =
+			CPASS_ACCURACY_SZ;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].output = ACCEL_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].output = GYRO_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].output =
+			CPASS_ACCURACY_SET;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].header = ACCEL_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].header = GYRO_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].header =
+			COMPASS_ACCURACY_HDR;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+	u8 reg = 0x0;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->firmware = 0;
+	st->secondary_switch = false;
+	st->fifo_count_mode = BYTE_MODE;
+
+	inv_init_secondary(st);
+	inv_init_sensor_struct(st);
+
+	/* Implemented for HW_FIX_DISABLE */
+	res = inv_plat_read(st, 0x75, 1, &reg);
+	if (res) {
+		pr_info("Error : cannot read 0x75 (HW_FIX_DIABLE) register\n");
+		return res;
+	}
+	reg |= 0x8;
+	res = inv_plat_single_write(st, 0x75, reg);
+	res = inv_plat_read(st, 0x75, 1, &reg);
+	pr_info("Write %04X to HW_FIX_DIABLE register\n", reg);
+	/* End of implemented for HW_FIX_DISABLE */
+
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+	res = inv_set_dmp(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res = inv_set_secondary(st);
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+
+	result = inv_read_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	if (SECONDARY_SLAVE_TYPE_COMPASS == plat->sec_slave_type)
+		st->chip_config.has_compass = 1;
+	else
+		st->chip_config.has_compass = 0;
+	if (SECONDARY_SLAVE_TYPE_PRESSURE == plat->aux_slave_type)
+		st->chip_config.has_pressure = 1;
+	else
+		st->chip_config.has_pressure = 0;
+	if (SECONDARY_SLAVE_TYPE_ALS == plat->read_only_slave_type)
+		st->chip_config.has_als = 1;
+	else
+		st->chip_config.has_als = 0;
+
+	if (st->chip_config.has_compass) {
+		result = inv_mpu_setup_compass_slave(st);
+		if (result)
+			pr_err("compass setup failed\n");
+	}
+	if (st->chip_config.has_pressure) {
+		result = inv_mpu_setup_pressure_slave(st);
+		if (result) {
+			pr_err("pressure setup failed\n");
+			st->chip_config.has_pressure = 0;
+			plat->aux_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		}
+	}
+	if (st->chip_config.has_als) {
+		result = inv_mpu_setup_als_slave(st);
+		if (result) {
+			pr_err("als setup failed\n");
+			st->chip_config.has_als = 0;
+			plat->read_only_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		}
+	}
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c
new file mode 100644
index 000000000000..c3325b8eb176
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "../inv_mpu_iio.h"
+
+static int inv_load_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size;
+	int result, size;
+	u16 memaddr;
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_w(memaddr, write_size, data);
+		if (result) {
+			pr_err("error writing firmware:%d\n", bank);
+			pr_info("%s: error writing firmware %d\n", __func__,
+				bank);
+			return result;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+
+	pr_info("%s: DMP load firmware successed DMP_Size %d\n",
+		__func__, st->dmp_image_size);
+	return 0;
+}
+
+static int inv_verify_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size, size;
+	int result;
+	u16 memaddr;
+	u8 firmware[MPU_MEM_BANK_SIZE];
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_r(memaddr, write_size, firmware);
+		if (result)
+			return result;
+		if (0 != memcmp(firmware, data, write_size)) {
+			pr_err("load data error, bank=%d\n", bank);
+			pr_info("%s: varification, load data error bank %d\n",
+				__func__, bank);
+			return -EINVAL;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+	return 0;
+}
+
+/*
+ * inv_firmware_load() -  calling this function will load the firmware.
+ */
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		pr_info("%s: load firmware set power error\n", __func__);
+		pr_err("load firmware set power error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_stop_dmp(st);
+	if (result) {
+		pr_info("%s: load firmware : stop dmp error\n", __func__);
+		pr_err("load firmware:stop dmp error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_load_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:load firmware error\n", __func__);
+		pr_err("load firmware:load firmware eror\n");
+		goto firmware_write_fail;
+	}
+	result = inv_verify_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:verify firmware error\n", __func__);
+		pr_err("load firmware:verify firmware error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_setup_dmp_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:setup dmp error\n", __func__);
+		pr_err("load firmware:setup dmp error\n");
+	}
+firmware_write_fail:
+	result |= inv_set_power(st, false);
+	if (result) {
+		pr_info("%s: load firmware:shuting down power error\n",
+			__func__);
+		pr_err("load firmware:shuting down power error\n");
+		return result;
+	}
+
+	st->chip_config.firmware_loaded = 1;
+
+	pr_info("%s: load firmware successed\n", __func__);
+	return 0;
+}
+
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	int read_size, i, result;
+	u16 addr;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+
+	addr = off;
+	i = 0;
+	while (size > 0) {
+		if (addr % MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE
+				- (addr % MAX_DMP_READ_SIZE);
+		else if (size > MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE;
+		else
+			read_size = size;
+
+		result = mem_r(addr, read_size, &buf[i]);
+		if (result)
+			return result;
+
+		addr += read_size;
+		i += read_size;
+		size -= read_size;
+	}
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c
new file mode 100644
index 000000000000..2630d856cbe7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c
@@ -0,0 +1,755 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static char iden[] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };
+
+static int inv_apply_soft_iron(struct inv_mpu_state *st, s16 *out_1, s32 *out_2)
+{
+	int *r, i, j;
+	s64 tmp;
+
+	r = st->final_compass_matrix;
+	for (i = 0; i < THREE_AXES; i++) {
+		tmp = 0;
+		for (j = 0; j < THREE_AXES; j++)
+			tmp  +=
+			(s64)r[i * THREE_AXES + j] * (((int)out_1[j]) << 16);
+		out_2[i] = (int)(tmp >> 30);
+	}
+
+	return 0;
+}
+
+static int inv_process_gyro(struct iio_dev *indio_dev, u8 *d, u64 t)
+{
+	s32 raw[3];
+	s16 bias[3];
+	s32 calib[3];
+	int i;
+
+	for (i = 0; i < 3; i++)
+		raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+	for (i = 0; i < 3; i++)
+		bias[i] = be16_to_cpup((__be16 *) (d + i * 2 + 6));
+	for (i = 0; i < 3; i++) {
+		calib[i] = raw[i];
+		calib[i] <<= 15;
+		calib[i] -= (bias[i] << 10);
+	}
+	inv_push_gyro_data(indio_dev, raw, calib, t);
+
+	return 0;
+}
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i, res;
+	s32 raw[3];
+	s16 out_1[3];
+	s32 out_2[3];
+	u16 accur;
+
+	res = 0;
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_GYRO:
+		inv_process_gyro(indio_dev, d, t);
+		break;
+	case SENSOR_COMPASS_CAL:
+		for (i = 0; i < 3; i++)
+			out_2[i] = be32_to_int(d + i * 4);
+
+		if ((out_2[0] == BAD_CAL_COMPASS_DATA) &&
+			(out_2[1] == BAD_CAL_COMPASS_DATA) &&
+			(out_2[2] == BAD_CAL_COMPASS_DATA)) {
+			pr_info("Bad cal compass\n");
+			return 0;
+		}
+		inv_convert_and_push_16bytes(indio_dev, ind, d, t,
+						st->plat_data.orientation);
+		/* raw sensor needs to be sent after calib sensor */
+		if (st->send_raw_compass) {
+			inv_push_16bytes_buffer(indio_dev, SENSOR_COMPASS,
+					st->sensor[SENSOR_COMPASS].ts,
+					st->raw_compass_data, 0);
+			st->send_raw_compass = false;
+		}
+		break;
+	case SENSOR_COMPASS:
+		st->send_raw_compass = true;
+		for (i = 0; i < 3; i++)
+			out_1[i] = be16_to_cpup((__be16 *) (d + i * 2));
+		/* bad compass handling */
+		if ((out_1[0] == BAD_COMPASS_DATA) &&
+			(out_1[1] == BAD_COMPASS_DATA) &&
+			(out_1[2] == BAD_COMPASS_DATA)) {
+			pr_info("Bad compass data\n");
+			return 0;
+		}
+		if (st->poke_mode_on) {
+			for (i = 0; i < 3; i++)
+				out_2[i] = out_1[i];
+			inv_push_16bytes_buffer(indio_dev, ind, t, out_2, 0);
+		} else {
+			inv_apply_soft_iron(st, out_1, out_2);
+			memcpy(st->raw_compass_data, out_2, 12);
+		}
+		break;
+	case SENSOR_ALS:
+		for (i = 0; i < 8; i++)
+			st->fifo_data[i] = d[i];
+		if (st->chip_config.has_als) {
+			res = st->slave_als->read_data(st, out_1);
+			inv_push_8bytes_buffer(indio_dev, ind, t, out_1);
+
+			return res;
+		}
+		break;
+	case SENSOR_SIXQ:
+		inv_convert_and_push_16bytes(indio_dev, ind, d, t, iden);
+		break;
+	case SENSOR_NINEQ:
+	case SENSOR_GEOMAG:
+		for (i = 0; i < 3; i++)
+			out_2[i] = be32_to_int(d + i * 4);
+		accur = be16_to_cpup((__be16 *)(d + 3 * 4));
+		inv_push_16bytes_buffer(indio_dev, ind, t, out_2, accur);
+		break;
+	case SENSOR_PEDQ:
+		inv_convert_and_push_8bytes(indio_dev, ind, d, t, iden);
+		break;
+	case SENSOR_PRESSURE:
+		for (i = 0; i < 6; i++)
+			st->fifo_data[i] = d[i];
+		if (st->chip_config.has_pressure) {
+			res = st->slave_pressure->read_data(st, out_1);
+			inv_push_8bytes_buffer(indio_dev, ind, t, out_1);
+		} else {
+			for (i = 0; i < 3; i++)
+				out_1[i] = be16_to_cpup((__be16 *) (d + i * 2));
+
+			inv_push_8bytes_buffer(indio_dev, ind, t, out_1);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return res;
+}
+
+int inv_get_packet_size(struct inv_mpu_state *st, u16 hdr,
+			u32 *pk_size, u8 *dptr)
+{
+	int i, size;
+	u16 hdr2;
+
+	size = HEADER_SZ;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output)
+			size += st->sensor[i].sample_size;
+	}
+	if (hdr & HEADER2_SET) {
+		size += HEADER2_SZ;
+		hdr2 = be16_to_cpup((__be16 *) (dptr + 2));
+
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output)
+				size += st->sensor_accuracy[i].sample_size;
+		}
+
+		if (hdr2 & ACT_RECOG_SET) {
+			if (st->chip_config.activity_eng_on) {
+				size += ACT_RECOG_SZ;
+			} else {
+				pr_err("ERROR: activity should not be here\n");
+				return -EINVAL;
+			}
+		}
+		if (hdr2 & SECOND_SEN_OFF_SET) {
+			if (st->chip_config.activity_eng_on) {
+				size += SECOND_AUTO_OFF_SZ;
+			} else {
+				pr_err("ERROR: activity should not be here\n");
+				return -EINVAL;
+			}
+		}
+
+		if (hdr2 & FLIP_PICKUP_SET) {
+			if (st->chip_config.pick_up_enable)
+				size += FLIP_PICKUP_SZ;
+			else
+				pr_err("ERROR: pick up should not be here\n");
+		}
+
+		if (hdr2 & FSYNC_SET) {
+			if (st->chip_config.eis_enable)
+				size += FSYNC_SZ;
+			else
+				pr_err("ERROR: eis should not be here\n");
+		}
+	}
+	if ((!st->chip_config.step_indicator_on) && (hdr & PED_STEPIND_SET)) {
+		pr_err("ERROR: step inditor should not be here=%x\n", hdr);
+		return -EINVAL;
+	}
+	if (hdr & PED_STEPDET_SET) {
+		if (st->chip_config.step_detector_on) {
+			size += PED_STEPDET_TIMESTAMP_SZ;
+		} else {
+			pr_err("ERROR: step detector should not be here\n");
+			return -EINVAL;
+		}
+	}
+	size += FOOTER_SZ;
+	*pk_size = size;
+
+	return 0;
+}
+
+static int inv_push_accuracy(struct iio_dev *indio_dev, int ind, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 buf[IIO_BUFFER_BYTES];
+	u16 hdr, accur;
+
+	hdr = st->sensor_accuracy[ind].header;
+	accur = be16_to_cpup((__be16 *)(d));
+	if (st->sensor_acurracy_flag[ind]) {
+		if (!accur)
+			accur = DEFAULT_ACCURACY;
+		else
+			st->sensor_acurracy_flag[ind] = 0;
+	}
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(buf + sizeof(hdr), &accur, sizeof(accur));
+	iio_push_to_buffers(indio_dev, buf);
+
+	pr_debug("Accuracy for sensor [%d] is [%d]\n", ind, accur);
+
+	return 0;
+}
+/* this function parse the FIFO information and set the sensor on/off */
+static int inv_switch_secondary(struct iio_dev *indio_dev, u8 *dptr)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u16 data;
+	bool run_setup = false;
+
+	data = be16_to_cpup((__be16 *) (dptr));
+	switch (data) {
+	case SENCONDARY_GYRO_OFF:
+		st->secondary_gyro_on = 0;
+		run_setup = true;
+		break;
+	case SENCONDARY_GYRO_ON:
+		st->secondary_gyro_on = 1;
+		run_setup = true;
+		break;
+	case SENCONDARY_COMPASS_OFF:
+		st->secondary_mag_on = 0;
+		break;
+	case SENCONDARY_COMPASS_ON:
+		st->secondary_mag_on = 0;
+		break;
+	case SENCONDARY_PROX_OFF:
+		st->secondary_prox_on = 0;
+		if (st->chip_config.has_als)
+			run_setup = true;
+		break;
+	case SENCONDARY_PROX_ON:
+		st->secondary_prox_on = 1;
+		if (st->chip_config.has_als)
+			run_setup = true;
+		break;
+	default:
+		break;
+	}
+	if (run_setup) {
+		st->secondary_switch = true;
+		st->secondary_switch_data = data;
+
+		set_inv_enable(indio_dev);
+
+		st->secondary_switch = false;
+	}
+
+	return 0;
+}
+/* static int inv_set_fsync_trigger(struct inv_mpu_state *st)
+	while receiving a FSYNC trigger for the first time, we set
+	cycle mode into continuous mode and set the correponding filter
+	parameters.
+*/
+static int inv_set_fsync_trigger(struct inv_mpu_state *st)
+{
+	int res;
+
+	if (st->eis.eis_triggered)
+		return 0;
+	st->eis.eis_triggered = true;
+		return 0;
+	res = inv_plat_single_write(st, REG_LP_CONFIG, BIT_I2C_MST_CYCLE);
+	if (res)
+		return res;
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+					BIT_GYRO_DLPCFG_184Hz |
+					(st->chip_config.fsr
+					<< SHIFT_GYRO_FS_SEL) |
+					BIT_GYRO_FCHOICE);
+	res = inv_set_bank(st, BANK_SEL_0);
+	if (res)
+		return res;
+	st->eis.eis_triggered = true;
+
+	return 0;
+}
+
+static void inv_calc_gyro_shift(struct inv_mpu_state *st, u16 tmp)
+{
+	int counter_1k[] = {3, 2, 1, 0, 4};
+	int gyro_9k_counter, gyro_1k_counter;
+
+#define GYRO_1K_DUR       (890 * 1000)
+#define GYRO_9K_DUR       (110 * 1000)
+
+	gyro_9k_counter = ((tmp >> 12) & 7);
+	gyro_1k_counter = (tmp & 0xfff);
+	if (gyro_1k_counter > 4)
+		gyro_1k_counter = 4;
+	st->ts_algo.gyro_ts_shift = counter_1k[gyro_1k_counter] * GYRO_1K_DUR +
+				gyro_9k_counter * GYRO_9K_DUR;
+	pr_debug("shif= %d, tmp= %x\n", st->ts_algo.gyro_ts_shift, tmp);
+}
+
+int inv_parse_packet(struct iio_dev *indio_dev, u16 hdr, u8 *dptr)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int i;
+	s16 s[3];
+	u64 t;
+	u16 hdr2 = 0;
+	bool data_header;
+	u8 *d_tmp;
+	u16 delay;
+	u16 tmp;
+
+	t = 0;
+	if (hdr & HEADER2_SET) {
+		hdr2 = be16_to_cpup((__be16 *) (dptr));
+		dptr += HEADER2_SZ;
+	}
+
+	st->eis.eis_frame = false;
+	if (hdr & GYRO_SET)
+		st->eis.gyro_counter++;
+	if (hdr2 & FSYNC_SET) {
+		d_tmp = dptr;
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (hdr & st->sensor[i].output)
+				dptr += st->sensor[i].sample_size;
+		}
+		inv_set_fsync_trigger(st);
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+		delay = be16_to_cpup((__be16 *) (dptr));
+		inv_process_eis(st, delay);
+
+		dptr = d_tmp;
+	}
+
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output) {
+			inv_get_dmp_ts(st, i);
+			if (!st->ts_algo.first_sample) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(indio_dev, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+			t = st->sensor[i].ts;
+			data_header = true;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+
+	if (data_header)
+		st->header_count--;
+	if (hdr & PED_STEPDET_SET) {
+		inv_process_step_det(indio_dev, dptr);
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+		st->step_det_count--;
+	}
+
+	if (hdr & PED_STEPIND_SET)
+		inv_push_step_indicator(indio_dev, t);
+	/* if hdr2 is not zero, it contains information and needs parsing */
+	if (hdr2) {
+		if (hdr2 & ACT_RECOG_SET) {
+			t = st->ts_algo.last_run_time;
+			s[0] = be16_to_cpup((__be16 *) (dptr));
+			s[1] = 0;
+			s[2] = 0;
+			inv_push_8bytes_kf(indio_dev, ACTIVITY_HDR, t, s);
+			dptr += ACT_RECOG_SZ;
+		}
+
+		if (hdr2 & SECOND_SEN_OFF_SET) {
+			inv_switch_secondary(indio_dev, dptr);
+			dptr += SECOND_AUTO_OFF_SZ;
+		}
+		if (hdr2 & FSYNC_SET)
+			dptr += FSYNC_SZ;
+
+		if (hdr2 & FLIP_PICKUP_SET) {
+			sysfs_notify(&indio_dev->dev.kobj, NULL,
+				     "poll_pick_up");
+			dptr += FLIP_PICKUP_SZ;
+			st->chip_config.pick_up_enable = 0;
+			inv_check_sensor_on(st);
+			set_inv_enable(indio_dev);
+			st->wake_sensor_received = true;
+			pr_debug("Pick up detected\n");
+		}
+
+		/* Implemented for Sensor accuracy */
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output) {
+				inv_push_accuracy(indio_dev, i, dptr);
+				dptr += st->sensor_accuracy[i].sample_size;
+			}
+		}
+	}
+	tmp = be16_to_cpup((__be16 *) (dptr));
+	inv_calc_gyro_shift(st, tmp);
+
+	return 0;
+}
+
+int inv_pre_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr)
+{
+	int i;
+	u16 hdr2 = 0;
+	bool data_header;
+
+	if (hdr & HEADER2_SET) {
+		hdr2 = be16_to_cpup((__be16 *) (dptr));
+		dptr += HEADER2_SZ;
+	}
+
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output) {
+			st->sensor[i].count++;
+			dptr += st->sensor[i].sample_size;
+			data_header = true;
+		}
+	}
+	if (data_header)
+		st->header_count++;
+	if (hdr & PED_STEPDET_SET) {
+		st->step_det_count++;
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+	}
+	if (hdr2) {
+		if (hdr2 & ACT_RECOG_SET)
+			dptr += ACT_RECOG_SZ;
+
+		if (hdr2 & SECOND_SEN_OFF_SET)
+			dptr += SECOND_AUTO_OFF_SZ;
+
+		if (hdr2 & FLIP_PICKUP_SET)
+			dptr += FLIP_PICKUP_SZ;
+		if (hdr2 & FSYNC_SET)
+			dptr += FSYNC_SZ;
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output)
+				dptr += st->sensor_accuracy[i].sample_size;
+		}
+	}
+
+	return 0;
+}
+
+static int inv_get_gyro_bias(struct inv_mpu_state *st, int *bias)
+{
+	int b_addr[] = { GYRO_BIAS_X, GYRO_BIAS_Y, GYRO_BIAS_Z };
+	int i, r;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		r = read_be32_from_mem(st, &bias[i], b_addr[i]);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_process_temp_comp(struct inv_mpu_state *st)
+{
+	u8 d[2];
+	int r, l1, scale_t, curr_temp, i;
+	s16 temp;
+	s64 tmp, recp;
+	bool update_slope;
+	struct inv_temp_comp *t_c;
+	int s_addr[] = { GYRO_SLOPE_X, GYRO_SLOPE_Y, GYRO_SLOPE_Z };
+
+#define TEMP_COMP_WIDTH  4
+#define TEMP_COMP_MID_L  (12 + TEMP_COMP_WIDTH)
+#define TEMP_COMP_MID_H  (32 + TEMP_COMP_WIDTH)
+
+	if (st->ts_algo.last_run_time - st->last_temp_comp_time < (NSEC_PER_SEC >> 1))
+		return 0;
+	st->last_temp_comp_time = st->ts_algo.last_run_time;
+	if ((!st->gyro_cal_enable) ||
+		(!st->chip_config.gyro_enable) || (!st->chip_config.accel_enable))
+		return 0;
+	r = inv_plat_read(st, REG_TEMPERATURE, 2, d);
+	if (r)
+		return r;
+	temp = (s16) (be16_to_cpup((short *)d));
+	scale_t = TEMPERATURE_OFFSET +
+		inv_q30_mult((int)temp << MPU_TEMP_SHIFT, TEMPERATURE_SCALE);
+	curr_temp = (scale_t >> MPU_TEMP_SHIFT);
+
+	update_slope = false;
+	/* check the lower part of the temperature */
+	l1 = abs(curr_temp - TEMP_COMP_MID_L);
+	l1 = l1 - TEMP_COMP_WIDTH;
+	l1 = l1 - TEMP_COMP_WIDTH;
+	t_c = &st->temp_comp;
+	if (l1 < 0) {
+		t_c->t_lo = temp;
+		r = inv_get_gyro_bias(st, t_c->b_lo);
+		if (r)
+			return r;
+		t_c->has_low = true;
+		update_slope = true;
+	}
+
+	l1 = abs(curr_temp - TEMP_COMP_MID_H);
+	l1 = l1 - TEMP_COMP_WIDTH;
+	l1 = l1 - TEMP_COMP_WIDTH;
+	if (l1 < 0) {
+		t_c->t_hi = temp;
+		r = inv_get_gyro_bias(st, t_c->b_hi);
+		if (r)
+			return r;
+		t_c->has_high = true;
+		update_slope = true;
+	}
+	if (t_c->has_high && t_c->has_low && update_slope) {
+		if (t_c->t_hi != t_c->t_lo) {
+			recp = (1 << 30) / (t_c->t_hi - t_c->t_lo);
+			for (i = 0; i < THREE_AXES; i++) {
+				tmp = recp * (t_c->b_hi[i] - t_c->b_lo[i]);
+				t_c->slope[i] = (tmp >> 15);
+				r = write_be32_to_mem(st,
+					t_c->slope[i], s_addr[i]);
+				if (r)
+					return r;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int inv_process_dmp_interrupt(struct iio_dev *indio_dev, u8 dmp_int_status)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, step;
+
+#define DMP_INT_SMD  0x02
+#define DMP_INT_PED  0x04
+
+	if ((!st->smd.on) && (!st->ped.on))
+		return 0;
+
+	if (dmp_int_status & DMP_INT_SMD) {
+		pr_debug("Sinificant motion detected\n");
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_smd");
+		st->smd.on = false;
+		st->trigger_state = EVENT_TRIGGER;
+		inv_check_sensor_on(st);
+		set_inv_enable(indio_dev);
+		st->wake_sensor_received = true;
+	}
+
+	if (st->ped.int_on) {
+		if (dmp_int_status & DMP_INT_PED) {
+			if (st->ped.int_mode) {
+				result = inv_get_pedometer_steps(st, &step);
+				if (result) {
+					pr_info("Failed to read step count\n");
+					return result;
+				}
+				inv_send_steps(indio_dev, step, st->ts_algo.last_run_time);
+				st->prev_steps = step;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int i;
+	u8 d[1];
+
+#define DMP_INT_FIFO	0x01
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+
+	if (st->chip_config.is_asleep)
+		goto end_read_fifo;
+
+	inv_switch_power_in_lp(st, true);
+
+	result = inv_plat_read(st, REG_DMP_INT_STATUS, 1, d);
+	if (result) {
+		pr_info("REG_DMP_INT_STATUS result [%d]\n", result);
+		goto end_read_fifo;
+	}
+
+	st->ts_algo.last_run_time = get_time_ns();
+	st->wake_sensor_received = false;
+	st->activity_size = 0;
+
+	result = inv_process_dmp_interrupt(indio_dev, d[0]);
+	if (result)
+		goto end_read_fifo;
+
+	if (!(d[0] & DMP_INT_FIFO))
+		goto end_read_fifo;
+
+	result = inv_process_temp_comp(st);
+	if (result)
+		goto end_read_fifo;
+
+	result = inv_process_dmp_data(indio_dev);
+
+	if (st->activity_size > 0)
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_activity");
+	if (result)
+		goto err_reset_fifo;
+
+end_read_fifo:
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+
+	/* set wake_sensor_received flag when streaming is enabled along with
+	 * any wakeup gesture sensor which is reported as FIFO data packet
+	 */
+	if (st->chip_config.tilt_enable || st->chip_config.pick_up_enable ||
+			st->step_detector_wake_l_on) {
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on) {
+				st->wake_sensor_received = true;
+				break;
+			}
+		}
+	}
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_switch_power_in_lp(st, false);
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result = 0;
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		inv_switch_power_in_lp(st, true);
+		st->wake_sensor_received = false;
+		if (inv_process_dmp_data(indio_dev))
+			pr_err("error on batch.. need reset fifo\n");
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+		inv_switch_power_in_lp(st, false);
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c
new file mode 100644
index 000000000000..294628859707
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c
@@ -0,0 +1,791 @@
+/*
+* Copyright (C) 2017-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* full scale and LPF setting */
+#define SELFTEST_GYRO_FS            ((0 << 3) | 1)
+#define SELFTEST_ACCEL_FS           ((7 << 3) | 1)
+
+/* register settings */
+#define SELFTEST_GYRO_SMPLRT_DIV        10
+#define SELFTEST_GYRO_AVGCFG            3
+#define SELFTEST_ACCEL_SMPLRT_DIV       10
+#define SELFTEST_ACCEL_DEC3_CFG         2
+
+#define DEF_SELFTEST_GYRO_SENS          (32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS                     20
+#define SELFTEST_WAIT_TIME              (MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME              20
+#define DEF_GYRO_SCALE                  131
+#define DEF_ST_PRECISION                1000
+#define DEF_ST_ACCEL_FS_MG              2000UL
+#define DEF_ST_SCALE                    32768
+#define DEF_ST_TRY_TIMES                2
+#define DEF_ST_ACCEL_RESULT_SHIFT       1
+#define DEF_ST_COMPASS_RESULT_SHIFT     2
+#define DEF_ST_SAMPLES                  200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN    500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX    1500
+#define DEF_GYRO_CT_SHIFT_DELTA         500
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX             20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL                  60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN             225
+#define DEF_ACCEL_ST_AL_MAX             675
+
+struct recover_regs {
+	/* Bank#0 */
+	u8 fifo_cfg;		/* REG_FIFO_CFG */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 lp_config;		/* REG_LP_CONFIG */
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 int_enable_1;	/* REG_INT_ENABLE_1 */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 fifo_en_2;		/* REG_FIFO_EN_2 */
+	u8 fifo_rst;		/* REG_FIFO_RST */
+
+	/* Bank#2 */
+	u8 gyro_smplrt_div;	/* REG_GYRO_SMPLRT_DIV */
+	u8 gyro_config_1;	/* REG_GYRO_CONFIG_1 */
+	u8 gyro_config_2;	/* REG_GYRO_CONFIG_2 */
+	u8 accel_smplrt_div_1;	/* REG_ACCEL_SMPLRT_DIV_1 */
+	u8 accel_smplrt_div_2;	/* REG_ACCEL_SMPLRT_DIV_2 */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_FIFO_CFG : 0x%02X\n", saved_regs.fifo_cfg);
+	pr_debug(" REG_USER_CTRL : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_LP_CONFIG : 0x%02X\n", saved_regs.lp_config);
+	pr_debug(" REG_INT_ENABLE : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_INT_ENABLE_1 : 0x%02X\n", saved_regs.int_enable_1);
+	pr_debug(" REG_FIFO_EN : 0x%02x\n", saved_regs.fifo_en);
+	pr_debug(" REG_FIFO_EN_2 : 0x%02x\n", saved_regs.fifo_en_2);
+	pr_debug(" REG_FIFO_RST : 0x%02x\n", saved_regs.fifo_rst);
+	if (st->chip_config.has_gyro) {
+		pr_debug(" REG_GYRO_SMPLRT_DIV : 0x%02x\n",
+			saved_regs.gyro_smplrt_div);
+		pr_debug(" REG_GYRO_CONFIG_1 : 0x%02x\n",
+			saved_regs.gyro_config_1);
+		pr_debug(" REG_GYRO_CONFIG_2 : 0x%02x\n",
+			saved_regs.gyro_config_2);
+	}
+	pr_debug(" REG_ACCEL_SMPLRT_DIV_1 : 0x%02x\n",
+		saved_regs.accel_smplrt_div_1);
+	pr_debug(" REG_ACCEL_SMPLRT_DIV_2 : 0x%02x\n",
+		saved_regs.accel_smplrt_div_2);
+	pr_debug(" REG_ACCEL_CONFIG : 0x%02x\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2 : 0x%02x\n", saved_regs.accel_config_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_FIFO_CFG, 1, &saved_regs.fifo_cfg);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1, &saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_CONFIG, 1, &saved_regs.lp_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_INT_ENABLE, 1, &saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_INT_ENABLE_1, 1,
+			       &saved_regs.int_enable_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1, &saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN_2, 1, &saved_regs.fifo_en_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_RST, 1, &saved_regs.fifo_rst);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_read(st, REG_GYRO_SMPLRT_DIV, 1,
+				&saved_regs.gyro_smplrt_div);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GYRO_CONFIG_1, 1,
+				&saved_regs.gyro_config_1);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GYRO_CONFIG_2, 1,
+				&saved_regs.gyro_config_2);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_ACCEL_SMPLRT_DIV_1, 1,
+			&saved_regs.accel_smplrt_div_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_SMPLRT_DIV_2, 1,
+			&saved_regs.accel_smplrt_div_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV,
+				saved_regs.gyro_smplrt_div);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				saved_regs.gyro_config_1);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_2,
+				saved_regs.gyro_config_2);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_1,
+			saved_regs.accel_smplrt_div_1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2,
+			saved_regs.accel_smplrt_div_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Restore FIFO configurations */
+	result = inv_plat_single_write(st, REG_FIFO_CFG, saved_regs.fifo_cfg);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_CONFIG, saved_regs.lp_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_ENABLE_1,
+			saved_regs.int_enable_1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN, saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN_2, saved_regs.fifo_en_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_RST, saved_regs.fifo_rst);
+	if (result)
+		return result;
+
+	/* Reset DMP */
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			(saved_regs.
+			user_ctrl & (~BIT_FIFO_EN)) |
+			BIT_DMP_RST);
+	if (result)
+		return result;
+	usleep_range(DMP_RESET_TIME, DMP_RESET_TIME + 100);
+
+	result = inv_set_power(st, false);
+	return result;
+}
+
+/**
+* inv_check_gyro_self_test() - check gyro self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+static int inv_check_gyro_self_test(struct inv_mpu_state *st,
+			int *reg_avg, int *st_avg)
+{
+	u8 *regs;
+	int ret_val;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	regs = st->gyro_st_data;
+	pr_debug("self_test gyro shift_code - %02x %02x %02x\n",
+		regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st_shift_prod[0], st_shift_prod[1], st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA
+				* st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			ret_val = 1;
+		}
+	}
+	pr_debug("self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st_shift_cust[0], st_shift_cust[1], st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/**
+* inv_check_accel_self_test() - check accel self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+static int inv_check_accel_self_test(struct inv_mpu_state *st,
+			int *reg_avg, int *st_avg)
+{
+	int ret_val;
+	int st_shift_prod[3], st_shift_cust[3], i;
+	u8 *regs;
+	int otp_value_zero = 0;
+
+#define ACCEL_ST_AL_MIN ((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+			/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX ((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+			/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+	ret_val = 0;
+	regs = st->accel_st_data;
+	pr_debug("self_test accel shift_code - %02x %02x %02x\n",
+		 regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("self_test accel st_shift_prod - %+d %+d %+d\n",
+		st_shift_prod[0], st_shift_prod[1], st_shift_prod[2]);
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			if (st_shift_cust[i] < DEF_ACCEL_ST_SHIFT_DELTA_MIN
+				* st_shift_prod[i])
+				ret_val = 1;
+			if (st_shift_cust[i] > DEF_ACCEL_ST_SHIFT_DELTA_MAX
+				* st_shift_prod[i])
+				ret_val = 1;
+		}
+	} else {
+		ret_val = 1;
+	}
+	pr_debug("self_test accel st_shift_cust - %+d %+d %+d\n",
+		st_shift_cust[0], st_shift_cust[1], st_shift_cust[2]);
+
+	return ret_val;
+}
+
+static int inv_setup_selftest(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+
+	/* Save the current settings */
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Enable FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			BIT_FIFO_EN | st->i2c_dis);
+	if (result)
+		return result;
+
+	/* Set cycle mode */
+	result = inv_plat_single_write(st, REG_LP_CONFIG,
+			BIT_I2C_MST_CYCLE | BIT_ACCEL_CYCLE |
+			BIT_GYRO_CYCLE);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* Configure FSR and DLPF */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV,
+				SELFTEST_GYRO_SMPLRT_DIV);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				SELFTEST_GYRO_FS);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_2,
+				SELFTEST_GYRO_AVGCFG);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_1, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2,
+			SELFTEST_ACCEL_SMPLRT_DIV);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, SELFTEST_ACCEL_FS);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			SELFTEST_ACCEL_DEC3_CFG);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_1);
+	if (result)
+		return result;
+
+	/* Read selftest values */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_read(st, REG_SELF_TEST1, 1,
+			&st->gyro_st_data[0]);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_SELF_TEST2, 1,
+			&st->gyro_st_data[1]);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_SELF_TEST3, 1,
+			&st->gyro_st_data[2]);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_SELF_TEST4, 1, &st->accel_st_data[0]);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SELF_TEST5, 1, &st->accel_st_data[1]);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SELF_TEST6, 1, &st->accel_st_data[2]);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	/* Restart sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY);
+	if (result)
+		return result;
+	msleep(GYRO_ENGINE_UP_TIME);
+
+	return result;
+}
+
+static int inv_selftest_read_samples(struct inv_mpu_state *st, enum INV_SENSORS
+			type, int *sum_result, int *s)
+{
+	u8 w;
+	u16 fifo_count;
+	s16 vals[3];
+	u8 d[MAX_PACKETS * BYTES_PER_SENSOR];
+	int r, i, j, t, packet_count;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+	if (r)
+		return r;
+
+	/* Reset FIFO */
+	r = inv_plat_single_write(st, REG_FIFO_RST, 0x1F);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_RST, 0x1E);
+	if (r)
+		return r;
+
+	if (SENSOR_GYRO == type)
+		w = BITS_GYRO_FIFO_EN;
+	else
+		w = BIT_ACCEL_FIFO_EN;
+
+	while (*s < DEF_ST_SAMPLES) {
+		r = inv_plat_single_write(st, REG_FIFO_EN_2, w);
+		if (r)
+			return r;
+
+		msleep(SELFTEST_WAIT_TIME);
+
+		r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+		if (r)
+			return r;
+
+		r = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, d);
+		if (r)
+			return r;
+		fifo_count = be16_to_cpup((__be16 *) (&d[0]));
+		pr_debug("self_test fifo_count - %d\n", fifo_count);
+		if (MAX_PACKETS * BYTES_PER_SENSOR < fifo_count) {
+			r = inv_plat_read(st, REG_FIFO_R_W,
+				MAX_PACKETS * BYTES_PER_SENSOR, d);
+			packet_count = MAX_PACKETS;
+		} else {
+			r = inv_plat_read(st, REG_FIFO_R_W, fifo_count, d);
+			packet_count = fifo_count / BYTES_PER_SENSOR;
+		}
+		if (r)
+			return r;
+
+		i = 0;
+		while (i < packet_count) {
+			for (j = 0; j < THREE_AXES; j++) {
+				t = 2 * j + i * BYTES_PER_SENSOR;
+				vals[j] =
+					(s16) be16_to_cpup((__be16 *) (&d[t]));
+				sum_result[j] += vals[j];
+			}
+			pr_debug("self_test data - %d %+d %+d %+d",
+				*s, vals[0], vals[1], vals[2]);
+			(*s)++;
+			i++;
+		}
+	}
+	return 0;
+}
+
+/*
+ *  inv_do_test_accel() - do the actual test of self testing
+ */
+static int inv_do_test_accel(struct inv_mpu_state *st, int *accel_result,
+			int *accel_st_result)
+{
+	int result, i, j;
+	int accel_s;
+	u8 w;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		accel_result[i] = 0;
+		accel_st_result[i] = 0;
+	}
+
+	accel_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_ACCEL,
+			accel_result, &accel_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		accel_result[j] = accel_result[j] / accel_s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+
+	/* Set Self-Test Bit */
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	w = BIT_ACCEL_CTEN | SELFTEST_ACCEL_DEC3_CFG;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, w);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	msleep(DEF_ST_STABLE_TIME);
+
+	accel_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_ACCEL,
+			accel_st_result, &accel_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		accel_st_result[j] = accel_st_result[j] / accel_s;
+		accel_st_result[j] *= DEF_ST_PRECISION;
+	}
+
+	pr_debug("accel=%d, %d, %d\n", accel_result[0], accel_result[1],
+		accel_result[2]);
+
+	return 0;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+static int inv_do_test_gyro(struct inv_mpu_state *st, int *gyro_result,
+			    int *gyro_st_result)
+{
+	int result, i, j;
+	int gyro_s;
+	u8 w;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		gyro_result[i] = 0;
+		gyro_st_result[i] = 0;
+	}
+
+	gyro_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_GYRO,
+			gyro_result, &gyro_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		gyro_result[j] = gyro_result[j] / gyro_s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	/* Set Self-Test Bit */
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	w = BIT_GYRO_CTEN | SELFTEST_GYRO_AVGCFG;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_2, w);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	msleep(DEF_ST_STABLE_TIME);
+
+	gyro_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_GYRO,
+			gyro_st_result, &gyro_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		gyro_st_result[j] = gyro_st_result[j] / gyro_s;
+		gyro_st_result[j] *= DEF_ST_PRECISION;
+	}
+
+	pr_debug("gyro=%d, %d, %d\n", gyro_result[0], gyro_result[1],
+		gyro_result[2]);
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXES], gyro_bias_regular[THREE_AXES];
+	int accel_bias_st[THREE_AXES], accel_bias_regular[THREE_AXES];
+	int test_times, i;
+	char accel_result, gyro_result, compass_result;
+
+	accel_result = 0;
+	gyro_result = 0;
+	compass_result = 0;
+
+	result = inv_setup_selftest(st);
+	if (result)
+		goto test_fail;
+
+	if (!st->chip_config.has_gyro) {
+		pr_debug("self_test skip gyro test\n");
+		goto accel_test;
+	}
+
+	/* gyro test */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test_gyro(st, gyro_bias_regular, gyro_bias_st);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("self_test gyro bias_regular - %+d %+d %+d\n",
+		gyro_bias_regular[0],
+		gyro_bias_regular[1], gyro_bias_regular[2]);
+	pr_debug("self_test gyro bias_st - %+d %+d %+d\n",
+		gyro_bias_st[0], gyro_bias_st[1], gyro_bias_st[2]);
+
+accel_test:
+	/* accel test */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test_accel(st, accel_bias_regular,
+				accel_bias_st);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("self_test accel bias_regular - %+d %+d %+d\n",
+		accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("self_test accel bias_st - %+d %+d %+d\n",
+		accel_bias_st[0], accel_bias_st[1], accel_bias_st[2]);
+
+	for (i = 0; i < 3; i++) {
+		st->gyro_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	accel_result = !inv_check_accel_self_test(st,
+				accel_bias_regular,
+				accel_bias_st);
+	if (st->chip_config.has_gyro) {
+		gyro_result = !inv_check_gyro_self_test(st,
+					gyro_bias_regular,
+					gyro_bias_st);
+	}
+	if (st->chip_config.has_compass)
+		compass_result = !st->slave_compass->self_test(st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (compass_result << DEF_ST_COMPASS_RESULT_SHIFT) |
+		(accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c
new file mode 100644
index 000000000000..87be4099e2d7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c
@@ -0,0 +1,1724 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+struct inv_local_store {
+	u8 reg_lp_config;
+	u8 reg_delay_enable;
+	u8 reg_delay_time;
+	u8 reg_gyro_smplrt;
+	bool wom_on;
+	bool activity_eng_on;
+	int accel_cal_ind;
+};
+
+static struct inv_local_store local;
+
+static int compass_cal_param[] = { 200, 70, 35, 15, 8, 4 };
+
+struct inv_accel_cal_params {
+	int freq;
+	int rate;
+	int bac_rate;
+	int gain;
+	int alpha;
+	int a;
+};
+
+static struct inv_accel_cal_params accel_cal_para[] = {
+	{
+		.freq = 1000,
+		},
+	{
+		.freq = 225,
+		.rate = 0,
+		.bac_rate = 3,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.alpha = 1026019965,
+		.a = 47721859,
+		},
+	{
+		.freq = 112,
+		.gain = DEFAULT_ACCEL_GAIN_112,
+		.rate = 0,
+		.bac_rate = 1,
+		.alpha = 977872018,
+		.a = 95869806,
+	},
+	{
+		.freq = 56,
+		.gain = PED_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 882002213,
+		.a = 191739611,
+		},
+	{
+		.freq = 15,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 357913941,
+		.a = 715827883,
+	},
+	{
+		.freq = 5,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 107374182,
+		.a = 966367642,
+	},
+};
+
+static int accel_gyro_rate[] = { 5, 6, 7, 8, 9, 10, 11, 12, 13,
+	14, 15, 17, 18, 22, 25, 28, 32, 37, 45,
+	56, 75, 112, 225
+};
+
+static int inv_set_batchmode(struct inv_mpu_state *st, bool enable)
+{
+	if (enable)
+		st->cntl2 |= BATCH_MODE_EN;
+
+	return 0;
+}
+
+static int inv_calc_engine_dur(struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_batchmode_calc(struct inv_mpu_state *st)
+{
+	int b, timeout;
+	int i, bps;
+	enum INV_ENGINE eng;
+
+	bps = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			bps += (st->sensor[i].sample_size + 2) *
+				st->sensor[i].rate;
+		}
+	}
+	if (bps) {
+		b = st->batch.timeout * bps;
+		if ((b > (FIFO_SIZE * MSEC_PER_SEC)) &&
+			(!st->batch.overflow_on))
+			timeout = FIFO_SIZE * MSEC_PER_SEC / bps;
+		else
+			timeout = st->batch.timeout;
+	} else {
+		if (st->chip_config.step_detector_on ||
+			st->step_counter_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.activity_eng_on) {
+			timeout = st->batch.timeout;
+		} else {
+			return -EINVAL;
+		}
+	}
+	if (st->chip_config.gyro_enable)
+		eng = ENGINE_GYRO;
+	else if (st->chip_config.accel_enable)
+		eng = ENGINE_ACCEL;
+	else
+		eng = ENGINE_I2C;
+	b = st->eng_info[eng].dur / USEC_PER_MSEC;
+	st->batch.engine_base = eng;
+	st->batch.counter = timeout * USEC_PER_MSEC / b;
+
+	if (st->batch.counter)
+		st->batch.on = true;
+
+	return 0;
+}
+
+static int inv_set_default_batch(struct inv_mpu_state *st)
+{
+	if (st->batch.max_rate > DEFAULT_BATCH_RATE) {
+		st->batch.default_on = true;
+		st->batch.counter = DEFAULT_BATCH_TIME * NSEC_PER_MSEC /
+			st->eng_info[ENGINE_GYRO].dur;
+	}
+
+	return 0;
+}
+
+int inv_batchmode_setup(struct inv_mpu_state *st)
+{
+	int r;
+	bool on;
+	s16 mask[ENGINE_NUM_MAX] = { 1, 2, 8, 8 };
+
+	st->batch.on = false;
+	st->batch.default_on = false;
+	if (st->batch.timeout > 0) {
+		r = inv_batchmode_calc(st);
+		if (r)
+			return r;
+	} else {
+		r = inv_set_default_batch(st);
+		if (r)
+			return r;
+	}
+
+	on = (st->batch.on || st->batch.default_on);
+
+	if (on) {
+		r = write_be32_to_mem(st, 0, BM_BATCH_CNTR);
+		if (r)
+			return r;
+		r = write_be32_to_mem(st, st->batch.counter, BM_BATCH_THLD);
+		if (r)
+			return r;
+		r = inv_write_2bytes(st, BM_BATCH_MASK,
+				mask[st->batch.engine_base]);
+		if (r)
+			return r;
+		r = inv_write_2bytes(st, FIFO_WATERMARK, FIFO_SIZE);
+		if (r)
+			return r;
+	} else {
+		/* disable FIFO WM interrupt */
+		r = inv_write_2bytes(st, FIFO_WATERMARK, HARDWARE_FIFO_SIZE);
+		if (r)
+			return r;
+	}
+
+	r = inv_set_batchmode(st, on);
+
+	return r;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 w, x;
+	int r;
+
+	/* clear FIFO data */
+	r = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE - 1);
+	if (r)
+		return r;
+	w = 0;
+	x = 0;
+	r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+
+	/* turn on user ctrl register */
+	w = BIT_DMP_RST;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+	if (r)
+		return r;
+	usleep_range(DMP_RESET_TIME, DMP_RESET_TIME + 100);
+
+	/* turn on interrupt */
+	w = BIT_DMP_INT_EN;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, w);
+	if (r)
+		return r;
+
+	w = BIT_FIFO_EN;
+	w |= BIT_DMP_EN;
+	if (st->chip_config.slave_enable && (!st->poke_mode_on))
+		w |= BIT_I2C_MST_EN;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int max_rate = 0;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	/* Drop first some samples for better timestamping.
+	 * The number depends on the frequency not to make
+	 * large latency for the first sample at application.
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			max_rate = max(st->sensor[i].rate, max_rate);
+	}
+	if (max_rate < 5)
+		ts_algo->first_sample = 0;
+	else if (max_rate < 100)
+		ts_algo->first_sample = 1;
+	else
+		ts_algo->first_sample = 2;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 w;
+	int r;
+
+	if ((st->chip_config.gyro_enable | st->chip_config.accel_enable)
+		&& (!st->poke_mode_on)) {
+		w = BIT_PWR_PRESSURE_STBY;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_PRESSURE_STBY);
+	}
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	if (r)
+		return r;
+	if ((!st->chip_config.eis_enable) || (!st->eis.eis_triggered)) {
+		/* secondary cycle mode should be set all the time */
+		r = inv_plat_single_write(st, REG_LP_CONFIG, BIT_I2C_MST_CYCLE |
+							BIT_ACCEL_CYCLE |
+							BIT_GYRO_CYCLE);
+		if (r)
+			return r;
+		inv_set_gyro_sf(st);
+	}
+	inv_set_bank(st, BANK_SEL_2);
+	inv_plat_single_write(st, REG_ODR_ALIGN_EN, BIT_ODR_ALIGN_EN);
+	inv_set_bank(st, BANK_SEL_0);
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_als) {
+		if (st->chip_config.als_enable)
+			r = st->slave_als->resume(st);
+		else
+			r = st->slave_als->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_pressure) {
+		if (st->chip_config.pressure_enable)
+			r = st->slave_pressure->resume(st);
+		else
+			r = st->slave_pressure->suspend(st);
+		if (r)
+			return r;
+	}
+
+	/* secondary cycle mode should be set all the time */
+	w = BIT_I2C_MST_CYCLE;
+	if (st->chip_config.low_power_gyro_on)
+		w |= BIT_GYRO_CYCLE;
+	w |= BIT_ACCEL_CYCLE;
+	if (w != local.reg_lp_config) {
+		r = inv_plat_single_write(st, REG_LP_CONFIG, w);
+		if (r)
+			return r;
+		local.reg_lp_config = w;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i, result;
+	int div[SENSOR_NUM_MAX];
+	bool d_flag;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (!st->sensor[i].rate) {
+				pr_err("sensor %d rate is zero\n", i);
+				return -EINVAL;
+			}
+			pr_info(
+			"[Before]sensor %d rate [%d], running_rate %d\n",
+			i, st->sensor[i].rate,
+			st->eng_info[st->sensor[i].engine_base].running_rate);
+
+			div[i] =
+				st->eng_info[st->sensor[i].engine_base].
+				running_rate / st->sensor[i].rate;
+			if (!div[i])
+				div[i] = 1;
+			if (SENSOR_PRESSURE == i) {
+				if (st->eng_info[st->sensor[i].engine_base].running_rate
+						* 100 / div[i] > MAX_PRESSURE_RATE * 150)
+					div[i]++;
+			}
+			st->sensor[i].rate = st->eng_info
+				[st->sensor[i].engine_base].running_rate / div[i];
+
+			pr_info(
+			"sensor %d rate [%d] div [%d] running_rate [%d]\n",
+				i, st->sensor[i].rate, div[i],
+			st->eng_info[st->sensor[i].engine_base].running_rate);
+		}
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur *
+				div[i];
+			st->sensor[i].div = div[i];
+			pr_info("sensor %d div [%d] odr_addr [%02X] cntl [%04X]\n",
+				i, div[i], st->sensor[i].odr_addr, st->cntl);
+			result = inv_write_2bytes(st,
+					st->sensor[i].odr_addr, div[i] - 1);
+			if (result)
+				return result;
+			/* reset all data counter */
+			result = inv_write_2bytes(st,
+					st->sensor[i].counter_addr, 0);
+			if (result)
+				return result;
+		}
+	}
+
+	d_flag = 0;
+	for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+		if (st->sensor_accuracy[i].on)
+			st->cntl2 |= st->sensor_accuracy[i].output;
+		d_flag |= st->sensor_accuracy[i].on;
+	}
+	d_flag |= st->chip_config.activity_eng_on;
+	d_flag |= st->chip_config.pick_up_enable;
+	d_flag |= st->chip_config.eis_enable;
+	if (d_flag)
+		st->cntl |= HEADER2_SET;
+
+	if (st->chip_config.step_indicator_on)
+		st->cntl |= PED_STEPIND_SET;
+	if (st->chip_config.step_detector_on)
+		st->cntl |= PED_STEPDET_SET;
+	if (st->chip_config.activity_eng_on) {
+		st->cntl2 |= ACT_RECOG_SET;
+		st->cntl2 |= SECOND_SEN_OFF_SET;
+	}
+	if (st->chip_config.pick_up_enable)
+		st->cntl2 |= FLIP_PICKUP_SET;
+
+	if (st->chip_config.eis_enable)
+		st->cntl2 |= FSYNC_SET;
+
+	if (!st->chip_config.dmp_event_int_on) {
+		result = inv_batchmode_setup(st);
+		if (result)
+			return result;
+	} else {
+		st->batch.on = false;
+	}
+
+	return 0;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	if (st->chip_config.eis_enable)
+		inv_plat_single_write(st, REG_FSYNC_CONFIG, BIT_TRIGGER_EIS);
+	else
+		inv_plat_single_write(st, REG_FSYNC_CONFIG, 0);
+
+	if (local.reg_gyro_smplrt != g_d) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV, g_d);
+		if (result)
+			return result;
+		local.reg_gyro_smplrt = g_d;
+	}
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2, a_d);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+
+	return result;
+}
+
+static int inv_set_fifo_size(struct inv_mpu_state *st)
+{
+	int result;
+	u8 cfg;
+
+	/* use one FIFO in DMP mode */
+	cfg = BIT_SINGLE_FIFO_CFG;
+	result = inv_plat_single_write(st, REG_FIFO_CFG, cfg);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_set_fake_secondary() - set fake secondary I2C such that
+ *                           I2C data in the same position.
+ */
+static int inv_set_fake_secondary(struct inv_mpu_state *st)
+{
+	int r;
+	u8 bytes, ind;
+
+	/* may need to saturate the master I2C counter like Scorpion did */
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	if (st->sec_set.delay_enable != local.reg_delay_enable) {
+		r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+				st->sec_set.delay_enable);
+		if (r)
+			return r;
+		local.reg_delay_enable = st->sec_set.delay_enable;
+	}
+	if (st->sec_set.delay_time != local.reg_delay_time) {
+		r = inv_plat_single_write(st, REG_I2C_SLV4_CTRL,
+				st->sec_set.delay_time);
+		if (r)
+			return r;
+		local.reg_delay_time = st->sec_set.delay_time;
+	}
+	/* odr config is changed during slave setup */
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+			st->sec_set.odr_config);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+	if (r)
+		return r;
+
+	/*111, 110 */
+	if (st->chip_config.compass_enable && st->chip_config.als_enable)
+		return 0;
+	/* 100 */
+	if (st->chip_config.compass_enable &&
+		(!st->chip_config.als_enable) && (!st->chip_config.pressure_enable))
+		return 0;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	if (st->chip_config.pressure_enable) {
+		/* 001 */
+		if ((!st->chip_config.compass_enable) &&
+			(!st->chip_config.als_enable)) {
+			r = inv_read_secondary(st, 0,
+				st->plat_data.aux_i2c_addr,
+				BMP280_DIG_T1_LSB_REG,
+				DATA_AKM_99_BYTES_DMP);
+			if (r)
+				return r;
+			r = inv_read_secondary(st, 2,
+				st->plat_data.aux_i2c_addr,
+				BMP280_DIG_T1_LSB_REG,
+				DATA_ALS_BYTES_DMP);
+			r = inv_set_bank(st, BANK_SEL_0);
+
+			return r;
+		}
+
+		if (st->chip_config.compass_enable &&
+			(!st->chip_config.als_enable)) {
+			/* 101 */
+			ind = 2;
+			if ((COMPASS_ID_AK09911 ==
+				st->plat_data.sec_slave_id) ||
+				(COMPASS_ID_AK09912 ==
+				st->plat_data.sec_slave_id) ||
+				(COMPASS_ID_AK09916 == st->plat_data.sec_slave_id))
+				bytes = DATA_ALS_BYTES_DMP;
+			else
+				bytes = DATA_ALS_BYTES_DMP +
+				DATA_AKM_99_BYTES_DMP -
+				DATA_AKM_89_BYTES_DMP;
+		} else {	/* 011 */
+			ind = 0;
+			bytes = DATA_AKM_99_BYTES_DMP;
+		}
+		r = inv_read_secondary(st, ind, st->plat_data.aux_i2c_addr,
+			BMP280_DIG_T1_LSB_REG, bytes);
+	} else {/* compass disabled; als enabled, pressure disabled 010 */
+		r = inv_read_secondary(st, 0, st->plat_data.read_only_i2c_addr,
+			APDS9900_AILTL_REG,
+			DATA_AKM_99_BYTES_DMP);
+	}
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	return r;
+}
+
+static int inv_set_ICM20628_secondary(struct inv_mpu_state *st)
+{
+	int rate, compass_rate, pressure_rate, als_rate, min_rate, base;
+	int mst_odr_config, d, delay;
+
+	if (st->chip_config.compass_enable)
+		compass_rate = st->chip_config.compass_rate;
+	else
+		compass_rate = 0;
+	if (st->chip_config.pressure_enable)
+		pressure_rate = st->sensor[SENSOR_PRESSURE].rate;
+	else
+		pressure_rate = 0;
+	if (st->chip_config.als_enable)
+		als_rate = max(st->sensor[SENSOR_ALS].rate,
+			       MPU_INIT_SENSOR_RATE);
+	else
+		als_rate = 0;
+	if (compass_rate)
+		rate = compass_rate;
+	else
+		rate = max(pressure_rate, als_rate);
+	mst_odr_config = 0;
+	min_rate = BASE_SAMPLE_RATE;
+	while (rate < min_rate) {
+		mst_odr_config++;
+		min_rate >>= 1;
+	}
+	base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+	if (base < rate) {
+		mst_odr_config--;
+		base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+	}
+	if (mst_odr_config < MIN_MST_ODR_CONFIG)
+		mst_odr_config = MIN_MST_ODR_CONFIG;
+	if (compass_rate) {
+		if (mst_odr_config > MAX_MST_ODR_CONFIG)
+			mst_odr_config = MAX_MST_ODR_CONFIG;
+	} else {
+		if (mst_odr_config > MAX_MST_NON_COMPASS_ODR_CONFIG)
+			mst_odr_config = MAX_MST_NON_COMPASS_ODR_CONFIG;
+	}
+
+	base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+
+	if ((!st->chip_config.gyro_enable) && (!st->chip_config.accel_enable)) {
+		st->eng_info[ENGINE_I2C].running_rate = base;
+		st->eng_info[ENGINE_I2C].divider = (1 << mst_odr_config);
+	}
+	pr_debug("%s compass_running_rate %d  base %d\n",
+		__func__, st->eng_info[ENGINE_I2C].running_rate, base);
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_I2C]);
+
+	d = 0;
+	if (d > 0)
+		d -= 1;
+	if (d > MAX_5_BIT_VALUE)
+		d = MAX_5_BIT_VALUE;
+
+	/* I2C_MST_DLY is set to slow down secondary I2C */
+	if (d)
+		delay = 0x1F;
+	else
+		delay = 0;
+
+	st->sec_set.delay_enable = delay;
+	st->sec_set.delay_time = d;
+	st->sec_set.odr_config = mst_odr_config;
+
+	pr_info("mst_odr_conf %X no modified\n", mst_odr_config);
+
+	return 0;
+}
+
+static int inv_set_master_delay(struct inv_mpu_state *st)
+{
+
+	if (!st->chip_config.slave_enable)
+		return 0;
+	inv_set_ICM20628_secondary(st);
+
+	return 0;
+}
+
+static void inv_enable_accel_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (ACCEL_CAL_EN);
+}
+
+static void inv_enable_gyro_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (GYRO_CAL_EN);
+}
+
+static void inv_enable_compass_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= COMPASS_CAL_EN;
+}
+
+static int inv_set_wom(struct inv_mpu_state *st)
+{
+	int result;
+	u8 d[4] = { 0, 0, 0, 0 };
+
+	if (st->chip_config.wom_on)
+		d[3] = 1;
+
+	if (local.wom_on != st->chip_config.wom_on) {
+		result = mem_w(WOM_ENABLE, ARRAY_SIZE(d), d);
+		if (result)
+			return result;
+		local.wom_on = st->chip_config.wom_on;
+	}
+
+	inv_write_2bytes(st, DATA_RDY_STATUS, st->chip_config.gyro_enable |
+			(st->chip_config.accel_enable << 1) |
+			(st->chip_config.slave_enable << 3));
+
+	return 0;
+}
+
+static void inv_setup_events(struct inv_mpu_state *st)
+{
+	if (st->ped.engine_on)
+		st->motion_event_cntl |= (PEDOMETER_EN);
+	if (st->smd.on)
+		st->motion_event_cntl |= (SMD_EN);
+	if (st->ped.int_on)
+		st->motion_event_cntl |= (PEDOMETER_INT_EN);
+	if (st->chip_config.pick_up_enable)
+		st->motion_event_cntl |= (FLIP_PICKUP_EN);
+	if (st->chip_config.geomag_enable)
+		st->motion_event_cntl |= GEOMAG_RV_EN;
+	if (st->sensor[SENSOR_NINEQ].on)
+		st->motion_event_cntl |= NINE_AXIS_EN;
+	if (!st->chip_config.activity_eng_on)
+		st->motion_event_cntl |= BAC_ACCEL_ONLY_EN;
+}
+
+static int inv_setup_sensor_interrupt(struct inv_mpu_state *st)
+{
+	int i, ind, rate;
+
+	ind = -1;
+	rate = 0;
+
+	st->intr_cntl = 0;
+	if (st->batch.on) {
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on)
+				st->intr_cntl |= st->sensor[i].output;
+		}
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (st->sensor[i].rate > rate) {
+				ind = i;
+				rate = st->sensor[i].rate;
+			}
+		}
+	}
+
+	if (ind != -1)
+		st->intr_cntl |= st->sensor[ind].output;
+	if (st->chip_config.step_detector_on)
+		st->intr_cntl |= PED_STEPDET_SET;
+	if (st->chip_config.activity_eng_on)
+		st->intr_cntl |= HEADER2_SET;
+	if (st->chip_config.pick_up_enable)
+		st->intr_cntl |= HEADER2_SET;
+	if (st->chip_config.eis_enable)
+		st->intr_cntl |= HEADER2_SET;
+
+	pr_debug("eis for Header2 %s\n",
+		st->chip_config.eis_enable == 1 ? "Enabled" : "Disabled");
+	return inv_write_2bytes(st, DATA_INTR_CTL, st->intr_cntl);
+}
+
+static int inv_mpu_reset_pickup(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st, 0, FP_PICKUP_CNTR);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static int inv_setup_dmp(struct inv_mpu_state *st)
+{
+	int result, i, tmp, min_diff, ind;
+
+	result = inv_setup_sensor_interrupt(st);
+	if (result)
+		return result;
+
+	i = 0;
+	ind = 0;
+	min_diff = accel_cal_para[0].freq;
+	while (i < ARRAY_SIZE(accel_cal_para)) {
+		tmp = abs(accel_cal_para[i].freq -
+				st->eng_info[ENGINE_ACCEL].running_rate);
+		if (tmp < min_diff) {
+			min_diff = tmp;
+			ind = i;
+		}
+		i++;
+	}
+	i = ind;
+		result = inv_write_2bytes(st, BAC_RATE,
+					accel_cal_para[i].bac_rate);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].bac_rate, FP_RATE);
+		if (result)
+			return result;
+
+		result = inv_write_2bytes(st,
+					ACCEL_CAL_RATE,
+					accel_cal_para[i].rate);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].alpha,
+					ACCEL_ALPHA_VAR);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].a,
+					ACCEL_A_VAR);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].gain,
+					ACCEL_ONLY_GAIN);
+		if (result)
+			return result;
+		local.accel_cal_ind = i;
+
+	i = 0;
+	min_diff = compass_cal_param[0];
+	while (i < ARRAY_SIZE(compass_cal_param)) {
+		tmp = abs(compass_cal_param[i] -
+			st->eng_info[ENGINE_I2C].running_rate);
+		if (tmp < min_diff) {
+			min_diff = tmp;
+			ind = i;
+		}
+		i++;
+	}
+
+	if ((st->eng_info[ENGINE_I2C].running_rate)) {
+		result =
+			inv_write_2bytes(st, CPASS_TIME_BUFFER,
+				compass_cal_param[ind]);
+		if (result)
+			return result;
+	}
+
+	if (st->chip_config.activity_eng_on) {
+		result = write_be32_to_mem(st, 0, BAC_STATE);
+		if (result)
+			return result;
+
+		result = write_be32_to_mem(st, 0, BAC_STATE_PREV);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_ACT_ON);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_ACT_OFF);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_STILL_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_RUN_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_DRIVE_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_WALK_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_SMD_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_BIKE_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E1_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E2_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E3_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_VAR_RUN);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 1, BAC_TILT_INIT);
+		if (result)
+			return result;
+
+		local.activity_eng_on = st->chip_config.activity_eng_on;
+	}
+
+	inv_enable_accel_cal_V3(st, st->accel_cal_enable);
+	inv_enable_gyro_cal_V3(st, st->gyro_cal_enable);
+	inv_enable_compass_cal_V3(st, st->calib_compass_on);
+
+	if (st->ped.engine_on) {
+		result = write_be32_to_mem(st, 0, DMPRATE_CNTR);
+		if (result)
+			return result;
+		result = write_be16_to_mem(st, 0, PEDSTEP_IND);
+		if (result)
+			return result;
+	}
+
+	if (st->chip_config.pick_up_enable) {
+		result = inv_mpu_reset_pickup(st);
+		if (result)
+			return result;
+	}
+
+	inv_setup_events(st);
+
+	result = inv_set_wom(st);
+	if (result)
+		return result;
+
+	result = inv_write_2bytes(st, DATA_OUT_CTL1, st->cntl);
+	if (result)
+		return result;
+	result = inv_write_2bytes(st, DATA_OUT_CTL2, st->cntl2);
+	if (result)
+		return result;
+	result = inv_write_2bytes(st, MOTION_EVENT_CTL, st->motion_event_cntl);
+
+	if (st->chip_config.gyro_enable) {
+		if (st->eng_info[ENGINE_GYRO].running_rate ==
+			MPU_DEFAULT_DMP_FREQ)
+			result = write_be32_to_mem(st, st->gyro_sf, GYRO_SF);
+		else
+			result = write_be32_to_mem(st,
+						st->gyro_sf << 1, GYRO_SF);
+	}
+	pr_info("setup DMP  cntl [%04X] cntl2 [%04X] motion_event [%04X]",
+				st->cntl, st->cntl2, st->motion_event_cntl);
+
+	return result;
+}
+
+static int inv_get_accel_gyro_rate(int compass_rate)
+{
+	int i;
+
+	i = 0;
+	while ((i < ARRAY_SIZE(accel_gyro_rate)) &&
+		compass_rate > accel_gyro_rate[i])
+		i++;
+
+	return accel_gyro_rate[i];
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en, c_en, p_en, data_on, ped_on;
+	int compass_rate, nineq_rate, accel_rate, gyro_rate;
+
+#define MIN_GYRO_RATE         112
+
+	a_en = false;
+	g_en = false;
+	c_en = false;
+	p_en = false;
+	ped_on = false;
+	data_on = false;
+	compass_rate = NINEQ_MIN_COMPASS_RATE;
+	nineq_rate = 0;
+	gyro_rate = MIN_GYRO_RATE;
+	accel_rate = PEDOMETER_FREQ;
+
+	st->chip_config.geomag_enable = 0;
+	if (st->sensor[SENSOR_NINEQ].on)
+		nineq_rate = max(nineq_rate, NINEQ_MIN_COMPASS_RATE);
+	if (st->sensor[SENSOR_GEOMAG].on) {
+		st->chip_config.geomag_enable = 1;
+		nineq_rate = max(nineq_rate, GEOMAG_MIN_COMPASS_RATE);
+	}
+	/* loop the streaming sensors to see which engine needs to be turned on
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			data_on = true;
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+			c_en |= st->sensor[i].c_en;
+			p_en |= st->sensor[i].p_en;
+			if (st->sensor[i].c_en)
+				compass_rate =
+					max(compass_rate, st->sensor[i].rate);
+			if (st->sensor[i].p_en)
+				compass_rate =
+					max(compass_rate, st->sensor[i].rate);
+		}
+	}
+	g_en |= st->secondary_gyro_on;
+
+	/* tilt and activity both uses activity engine */
+	st->chip_config.activity_eng_on = (st->chip_config.activity_on |
+					st->chip_config.tilt_enable);
+	/* step detector and step detector wake and pedometer in batch mode
+	 * all use step detector sensor in the base sensor of invensense
+	 */
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on || (st->ped.on && st->batch.timeout && st->ped.int_mode))
+		st->chip_config.step_detector_on = true;
+	else
+		st->chip_config.step_detector_on = false;
+	/* ped_on engine is on depends on the step detector and step indicator
+	 * and activity engine on
+	 */
+	if (st->chip_config.step_detector_on ||
+		st->chip_config.step_indicator_on ||
+		st->chip_config.activity_eng_on) {
+		ped_on = true;
+		data_on = true;
+	}
+	/* smd depends on ped engine */
+	if (st->smd.on)
+		ped_on = true;
+
+	/* pedometer interrupt is enabled when ped int mode */
+	if (st->ped.int_mode && st->ped.on)
+		st->ped.int_on = 1;
+	else
+		st->ped.int_on = 0;
+
+	if (st->ped.on || ped_on)
+		st->ped.engine_on = true;
+	else
+		st->ped.engine_on = false;
+	/* ped engine needs accel engine on */
+	if (st->ped.engine_on)
+		a_en = true;
+	/* pick up needs accel engine on */
+	if (st->chip_config.pick_up_enable)
+		a_en = true;
+	/* eis needs gyro engine. gyro rate is 225 by default.
+	 * eis_triggerred set to be false when it is turned false
+	 */
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		gyro_rate = MPU_DEFAULT_DMP_FREQ;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+	} else {
+		st->eis.eis_triggered = false;
+	}
+
+	if (data_on)
+		st->chip_config.dmp_event_int_on = 0;
+	else
+		st->chip_config.dmp_event_int_on = 1;
+
+	if (st->chip_config.dmp_event_int_on)
+		st->chip_config.wom_on = 1;
+	else
+		st->chip_config.wom_on = 0;
+
+	if (compass_rate < nineq_rate)
+		compass_rate = nineq_rate;
+	st->chip_config.compass_rate = compass_rate;
+	if (st->sensor[SENSOR_SIXQ].on || st->sensor[SENSOR_NINEQ].on ||
+		st->sensor[SENSOR_PEDQ].on || st->sensor[SENSOR_GEOMAG].on) {
+		/* if 6 Q or 9 Q is on, set gyro/accel to default rate */
+		accel_rate = MPU_DEFAULT_DMP_FREQ;
+		gyro_rate = MPU_DEFAULT_DMP_FREQ;
+	} else {
+		/* determine the fastest accel engine rate when it is not
+		 * using default DMP frequency
+		 */
+		if (st->sensor[SENSOR_ACCEL].on) {
+			accel_rate = max(accel_rate,
+						st->sensor[SENSOR_ACCEL].rate);
+		}
+		if (st->sensor[SENSOR_GYRO].on)
+			gyro_rate = max(gyro_rate,
+					st->sensor[SENSOR_GYRO].rate);
+	}
+
+	if (compass_rate < MIN_COMPASS_RATE)
+		compass_rate = MIN_COMPASS_RATE;
+	st->ts_algo.clock_base = ENGINE_I2C;
+	if (c_en && (!g_en) && (!a_en)) {
+		a_en = true;
+		accel_rate = compass_rate;
+	}
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		if (c_en || p_en) {
+			if (gyro_rate < compass_rate)
+				gyro_rate =
+					inv_get_accel_gyro_rate(compass_rate);
+		}
+		accel_rate = gyro_rate;
+		compass_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_GYRO;
+		st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		if (c_en || p_en) {
+			if (accel_rate <= compass_rate)
+				accel_rate =
+					inv_get_accel_gyro_rate(compass_rate);
+		}
+		compass_rate = accel_rate;
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_ACCEL;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	st->eng_info[ENGINE_PRESSURE].running_rate = MPU_DEFAULT_DMP_FREQ;
+	st->eng_info[ENGINE_I2C].running_rate = compass_rate;
+	/* engine divider for pressure and compass is set later */
+	st->eng_info[ENGINE_GYRO].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+		(MPU_DEFAULT_DMP_FREQ / st->eng_info[ENGINE_GYRO].running_rate);
+	st->eng_info[ENGINE_ACCEL].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+		(MPU_DEFAULT_DMP_FREQ / st->eng_info[ENGINE_ACCEL].running_rate);
+	if (g_en)
+		st->eng_info[ENGINE_I2C].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+				st->eng_info[ENGINE_GYRO].running_rate);
+	else
+		st->eng_info[ENGINE_I2C].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+				st->eng_info[ENGINE_ACCEL].running_rate);
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(&st->eng_info[ENGINE_ACCEL]);
+
+	if (st->debug_determine_engine_on)
+		return 0;
+
+	st->chip_config.gyro_enable = g_en;
+	st->gyro_cal_enable = g_en;
+
+	st->chip_config.accel_enable = a_en;
+	st->accel_cal_enable = a_en;
+
+	st->chip_config.compass_enable = c_en;
+	st->calib_compass_on = c_en;
+
+	st->chip_config.pressure_enable = p_en;
+	st->chip_config.dmp_on = 1;
+	pr_info("gen: %d aen: %d cen: %d grate: %d arate: %d\n",
+				g_en, a_en, c_en, gyro_rate, accel_rate);
+	if (st->sensor[SENSOR_ALS].on || st->secondary_prox_on)
+		st->chip_config.als_enable = 1;
+	else
+		st->chip_config.als_enable = 0;
+
+	if (c_en || st->chip_config.als_enable || p_en)
+		st->chip_config.slave_enable = 1;
+	else
+		st->chip_config.slave_enable = 0;
+
+	/* setting up accel accuracy output */
+	if (st->sensor[SENSOR_ACCEL].on || st->sensor[SENSOR_NINEQ].on ||
+				st->sensor[SENSOR_SIXQ].on)
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = false;
+
+	if (st->sensor[SENSOR_GYRO].on || st->sensor[SENSOR_NINEQ].on ||
+				st->sensor[SENSOR_SIXQ].on)
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = false;
+
+	/* Setting up accurcy outpu of compass */
+	if (st->sensor[SENSOR_COMPASS].on || st->sensor[SENSOR_COMPASS_CAL].on
+		|| st->sensor[SENSOR_NINEQ].on)
+		st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].on = false;
+
+	st->cntl = 0;
+	st->cntl2 = 0;
+	st->motion_event_cntl = 0;
+	st->intr_cntl = 0;
+	st->send_raw_compass = false;
+
+	inv_set_master_delay(st);
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 w;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = inv_stop_dmp(st);
+	if (result)
+		return result;
+
+	inv_determine_engine(st);
+	if (!st->secondary_switch) {
+		result = inv_set_rate(st);
+		if (result) {
+			pr_err("inv_set_rate error\n");
+			return result;
+		}
+	}
+	if (!st->secondary_switch) {
+		result = inv_setup_dmp(st);
+		if (result) {
+			pr_err("setup dmp error\n");
+			return result;
+		}
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	if (!st->secondary_switch) {
+		result = inv_set_fifo_size(st);
+		if (result) {
+			pr_err("inv_set_fifo_size error\n");
+			return result;
+		}
+	}
+	if ((!st->secondary_switch) || (st->secondary_switch &&
+			(st->secondary_switch_data != SENCONDARY_GYRO_OFF) &&
+			(st->secondary_switch_data != SENCONDARY_GYRO_ON))) {
+		result = inv_set_fake_secondary(st);
+		if (result)
+			return result;
+	}
+	if (!st->secondary_switch) {
+		result = inv_reset_fifo(st, false);
+		if (result)
+			return result;
+	} else {
+		/* Recover only REG_USER_CTRL */
+		w = BIT_FIFO_EN;
+		w |= BIT_DMP_EN;
+		if (st->chip_config.slave_enable && (!st->poke_mode_on))
+			w |= BIT_I2C_MST_EN;
+		result = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+		if (result)
+			return result;
+	}
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_set_power(st, false);
+
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_set_flip_pickup_gesture_params_V3(struct inv_mpu_state *st)
+{
+	int var_error_alpha;
+	int still_threshold;
+	int middle_still_threshold;
+	int not_still_threshold;
+	int vibration_rejection_threshold;
+	int maximum_pickup_time_threshold;
+	int pickup_timeout_threshold;
+	int still_consistency_count_threshold;
+	int motion_consistency_count_threshold;
+	int vibration_count_threshold;
+	int steady_tilt_threshold;
+	int steady_tilt_upper_threshold;
+	int accel_z_flat_threshold_minus;
+	int accel_z_flat_threshold_plus;
+	int device_in_pocket_threshold;
+	int result;
+
+	var_error_alpha = 107374182L;
+	still_threshold = 4L;
+	middle_still_threshold = 10L;
+	not_still_threshold = 40L;
+	vibration_rejection_threshold = 65100L;
+	maximum_pickup_time_threshold = 30L;
+	pickup_timeout_threshold = 150L;
+	still_consistency_count_threshold = 80;
+	motion_consistency_count_threshold = 10;
+	vibration_count_threshold = 3;
+	steady_tilt_threshold = 6710886L;
+	steady_tilt_upper_threshold = 140928614L;
+	accel_z_flat_threshold_minus = 60397978L;
+	accel_z_flat_threshold_plus = 6710886L;
+	device_in_pocket_threshold = 100L;
+
+	result = write_be32_to_mem(st, var_error_alpha, FP_VAR_ALPHA);
+	result += write_be32_to_mem(st, still_threshold, FP_STILL_TH);
+	result += write_be32_to_mem(st, middle_still_threshold,
+				FP_MID_STILL_TH);
+	result += write_be32_to_mem(st, not_still_threshold, FP_NOT_STILL_TH);
+	result += write_be32_to_mem(st, vibration_rejection_threshold,
+				FP_VIB_REJ_TH);
+	result += write_be32_to_mem(st, maximum_pickup_time_threshold,
+				FP_MAX_PICKUP_T_TH);
+	result += write_be32_to_mem(st, pickup_timeout_threshold,
+				FP_PICKUP_TIMEOUT_TH);
+	result += write_be32_to_mem(st, still_consistency_count_threshold,
+				FP_STILL_CONST_TH);
+	result += write_be32_to_mem(st, motion_consistency_count_threshold,
+				FP_MOTION_CONST_TH);
+	result += write_be32_to_mem(st, vibration_count_threshold,
+				FP_VIB_COUNT_TH);
+	result += write_be32_to_mem(st, steady_tilt_threshold,
+				FP_STEADY_TILT_TH);
+	result += write_be32_to_mem(st, steady_tilt_upper_threshold,
+				FP_STEADY_TILT_UP_TH);
+	result += write_be32_to_mem(st, accel_z_flat_threshold_minus,
+				FP_Z_FLAT_TH_MINUS);
+	result += write_be32_to_mem(st, accel_z_flat_threshold_plus,
+				FP_Z_FLAT_TH_PLUS);
+	result += write_be32_to_mem(st, device_in_pocket_threshold,
+				FP_DEV_IN_POCKET_TH);
+	return result;
+}
+
+int inv_write_compass_matrix(struct inv_mpu_state *st, int *adj)
+{
+	int addr[] = {CPASS_MTX_00, CPASS_MTX_01, CPASS_MTX_02,
+			CPASS_MTX_10, CPASS_MTX_11, CPASS_MTX_12,
+			CPASS_MTX_20, CPASS_MTX_21, CPASS_MTX_22};
+	int r, i;
+
+	for (i = 0; i < 9; i++) {
+		r = write_be32_to_mem(st, adj[i], addr[i]);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_compass_dmp_cal(struct inv_mpu_state *st)
+{
+	s8 *compass_m, *m;
+	s8 trans[NINE_ELEM];
+	s32 tmp_m[NINE_ELEM];
+	int i, j, k;
+	int sens[THREE_AXES];
+	int *adj;
+	int scale, shift, r;
+
+	compass_m = st->plat_data.secondary_orientation;
+	m = st->plat_data.orientation;
+	for (i = 0; i < THREE_AXES; i++)
+		for (j = 0; j < THREE_AXES; j++)
+			trans[THREE_AXES * j + i] = m[THREE_AXES * i + j];
+
+	adj = st->current_compass_matrix;
+	st->slave_compass->get_scale(st, &scale);
+
+	if ((COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09916 == st->plat_data.sec_slave_id))
+		shift = AK89XX_SHIFT;
+	else
+		shift = AK99XX_SHIFT;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		sens[i] = st->chip_info.compass_sens[i] + 128;
+		sens[i] = inv_q30_mult(sens[i] << shift, scale);
+	}
+
+	for (i = 0; i < NINE_ELEM; i++) {
+		adj[i] = compass_m[i] * sens[i % THREE_AXES];
+		tmp_m[i] = 0;
+	}
+	for (i = 0; i < THREE_AXES; i++)
+		for (j = 0; j < THREE_AXES; j++)
+			for (k = 0; k < THREE_AXES; k++)
+				tmp_m[THREE_AXES * i + j] +=
+					trans[THREE_AXES * i + k] *
+					adj[THREE_AXES * k + j];
+
+	for (i = 0; i < NINE_ELEM; i++)
+		st->final_compass_matrix[i] = adj[i];
+
+	r = inv_write_compass_matrix(st, tmp_m);
+
+	return 0;
+}
+
+static int inv_write_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st, st->gyro_sf, GYRO_SF);
+
+	return result;
+}
+
+int inv_write_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st,
+		(DMP_ACCEL_SCALE_2G << st->chip_config.accel_fs), ACC_SCALE);
+	if (result)
+		return result;
+	result = write_be32_to_mem(st,
+		(DMP_ACCEL_SCALE2_2G >> st->chip_config.accel_fs), ACC_SCALE2);
+
+	return result;
+}
+
+int inv_setup_dmp_firmware(struct inv_mpu_state *st)
+{
+	int result;
+	u8 v[2] = {0, 0};
+
+	result = mem_w(DATA_OUT_CTL1, 2, v);
+	if (result)
+		return result;
+	result = mem_w(DATA_OUT_CTL2, 2, v);
+	if (result)
+		return result;
+	result = mem_w(MOTION_EVENT_CTL, 2, v);
+	if (result)
+		return result;
+	result = write_be32_to_mem(st, 12000, SMD_VAR_TH);
+	if (result)
+		return result;
+
+	result = inv_write_accel_sf(st);
+	if (result)
+		return result;
+	result = inv_write_gyro_sf(st);
+	if (result)
+		return result;
+
+	if (st->chip_config.has_compass) {
+		result = inv_compass_dmp_cal(st);
+		if (result)
+			return result;
+	}
+	result = inv_set_flip_pickup_gesture_params_V3(st);
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+	int i;
+	u16 cntl = st->intr_cntl;
+
+	/* keep streaming if any gesture reported by FIFO data is enabled */
+	if (st->chip_config.tilt_enable ||
+			st->chip_config.pick_up_enable ||
+			st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->chip_config.activity_on)
+		return 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		cntl &= ~st->sensor[i].output;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_write_2bytes(st, DATA_INTR_CTL, cntl);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	/* skip as did nothing in inv_stop_stream_interrupt() */
+	if (st->chip_config.tilt_enable ||
+			st->chip_config.pick_up_enable ||
+			st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->chip_config.activity_on)
+		return 0;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_write_2bytes(st, DATA_INTR_CTL, st->intr_cntl);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_read_offset_regs(struct inv_mpu_state *st, s16 accel[3], s16 gyro[3])
+{
+	int res = 0;
+	u8 data[2];
+
+	/* accel */
+	res = inv_set_bank(st, BANK_SEL_1);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_read(st, REG_XA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[2] = (data[0] << 8) | data[1];
+
+	pr_info("read accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_read(st, REG_XG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[2] = (data[0] << 8) | data[1];
+
+	pr_info("read gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+restore_bank:
+	inv_set_bank(st, BANK_SEL_0);
+
+	return res;
+}
+
+int inv_write_offset_regs(struct inv_mpu_state *st, const s16 accel[3], const s16 gyro[3])
+{
+	int res = 0;
+
+	/* accel */
+	res = inv_set_bank(st, BANK_SEL_1);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_single_write(st, REG_XA_OFFS_H,
+			(accel[0] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_XA_OFFS_H + 1,
+			accel[0] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H,
+			(accel[1] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H + 1,
+			accel[1] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H,
+			(accel[2] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H + 1,
+			accel[2] & 0xff);
+	if (res)
+		goto restore_bank;
+
+	pr_info("write accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H,
+			(gyro[0] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H + 1,
+			gyro[0] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H,
+			(gyro[1] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H + 1,
+			gyro[1] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H,
+			(gyro[2] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H + 1,
+			gyro[2] & 0xff);
+	if (res)
+		goto restore_bank;
+
+	pr_info("write gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+restore_bank:
+	inv_set_bank(st, BANK_SEL_0);
+
+	return res;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c
new file mode 100644
index 000000000000..8a68f80777f0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c
@@ -0,0 +1,288 @@
+/*
+* Copyright (C) 2017-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* AVAGO APDS-9930 */
+#define APDS9930_ENABLE_REG     0x00
+#define APDS9930_ATIME_REG      0x01
+#define APDS9930_PTIME_REG      0x02
+#define APDS9930_WTIME_REG      0x03
+#define APDS9930_AILTL_REG      0x04
+#define APDS9930_AILTH_REG      0x05
+#define APDS9930_AIHTL_REG      0x06
+#define APDS9930_AIHTH_REG      0x07
+#define APDS9930_PILTL_REG      0x08
+#define APDS9930_PILTH_REG      0x09
+#define APDS9930_PIHTL_REG      0x0A
+#define APDS9930_PIHTH_REG      0x0B
+#define APDS9930_PERS_REG       0x0C
+#define APDS9930_CONFIG_REG     0x0D
+#define APDS9930_PPCOUNT_REG    0x0E
+#define APDS9930_CONTROL_REG    0x0F
+#define APDS9930_REV_REG        0x11
+#define APDS9930_ID_REG         0x12
+#define APDS9930_STATUS_REG     0x13
+#define APDS9930_CDATAL_REG     0x14
+#define APDS9930_CDATAH_REG     0x15
+#define APDS9930_IRDATAL_REG    0x16
+#define APDS9930_IRDATAH_REG    0x17
+#define APDS9930_PDATAL_REG     0x18
+#define APDS9930_PDATAH_REG     0x19
+
+#define LIGHT_SENSOR_RATE_SCALE  100
+
+#define CMD_BYTE                0x80
+#define CMD_WORD                0xA0
+#define CMD_SPECIAL             0xE0
+#define DATA_ALS_ID             0x39
+#define DATA_ATIME              0xDB
+#define DATA_PPCOUNT            0x08
+#define DATA_CONFIG             0x00
+#define DATA_CONTROL            0x20
+#define DATA_ENABLE             0x03
+
+#define GA                      49
+#define B                       186
+#define C                       74
+#define D                       129
+#define CALC_RESOL              100
+#define DF                      52
+#define AGAIN                   1
+#define MIN_ATIME               273
+#define PON                     1
+#define AEN                     0x2
+#define PEN                     0x4
+#define WEN                     0x8
+
+#define ALS_89XX_BYTES          9
+#define ALS_99XX_BYTES          8
+
+static bool secondary_resume_state;
+
+static int setup_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result;
+	u8 addr;
+	u8 d[1];
+
+	addr = st->plat_data.read_only_i2c_addr;
+	result = inv_execute_read_secondary(st, 2, addr,
+					    CMD_BYTE | APDS9930_ID_REG, 1, d);
+	if (result)
+		return result;
+
+	if (d[0] != DATA_ALS_ID) {
+		pr_info("APDS9930 not found. Addr:0x%02X, ID:0x%02X (expected:0x%02X)\n",
+				addr, d[0], DATA_ALS_ID);
+		return -ENXIO;
+	}
+	pr_info("APDS9930 found. Addr:0x%02X, ID:0x%02X\n", addr, d[0]);
+
+	/* power off the chip to setup */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG,
+					     0x0);
+	if (result)
+		return result;
+
+	/* Write Atime, multiples of 50ms */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ATIME_REG,
+					     DATA_ATIME);
+	if (result)
+		return result;
+
+	/* Leave PTIME register at reset value of 0xFF */
+	/* Leave WTIME register at reset value of 0xFF */
+
+	/* write  config register register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_CONFIG_REG,
+					     DATA_CONFIG);
+	if (result)
+		return result;
+
+	/* write pp count register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_PPCOUNT_REG,
+					     DATA_PPCOUNT);
+	if (result)
+		return result;
+	/* write control register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_CONTROL_REG,
+					     DATA_CONTROL);
+
+	return result;
+}
+
+static int resume_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result, start, bytes;
+	u8 addr;
+	u8 d[1];
+
+	addr = st->plat_data.read_only_i2c_addr;
+
+	/* setup the secondary bus to default speed */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				       MIN_MST_ODR_CONFIG);
+	if (result)
+		return result;
+
+	/* clear up the ctrl register to avoid interference of setup */
+	if (!st->chip_config.compass_enable) {
+		result = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (result)
+			return result;
+	}
+
+	/* enable ALS only and power on */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG,
+					     PON | AEN | PEN | WEN);
+	if (result)
+		return result;
+	if (st->chip_config.compass_enable &&
+	    ((st->plat_data.sec_slave_id == COMPASS_ID_AK8975) ||
+	     (st->plat_data.sec_slave_id == COMPASS_ID_AK8963))) {
+		start = APDS9930_ID_REG;
+		bytes = ALS_89XX_BYTES;
+	} else {
+		start = APDS9930_STATUS_REG;
+		bytes = ALS_99XX_BYTES;
+	}
+	/* dummy read */
+	result = inv_execute_read_secondary(st, 2, addr,
+					    CMD_WORD | start, 1, d);
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_read_secondary(st, 2, addr, CMD_WORD | start, bytes);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return result;
+}
+
+static int suspend_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result;
+	u8 addr;
+
+	if (!secondary_resume_state)
+		return 0;
+
+	addr = st->plat_data.read_only_i2c_addr;
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				       MIN_MST_ODR_CONFIG);
+	if (result)
+		return result;
+	if (!st->chip_config.compass_enable) {
+		result = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (result)
+			return result;
+	}
+	/* disable 9930 */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG, 0);
+	if (result)
+		return result;
+
+	/* slave 2 is disabled */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV2_CTRL, 0);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return result;
+}
+
+static int read_data_apds9930_avago(struct inv_mpu_state *st, s16 *o)
+{
+	u8 *d;
+	u16 c0data, c1data;
+	int lux1, lux2;
+
+	d = st->fifo_data;
+
+	c0data = ((d[2] << 8) | d[1]);
+	c1data = ((d[4] << 8) | d[3]);
+#if 1
+	lux1 = ((1000 * c0data) - (2005 * c1data))
+	    / (71 * 8);
+	if (lux1 < 0)
+		lux1 = 0;
+	lux2 = ((604 * c0data) - (1090 * c1data))
+	    / (71 * 8);
+	if (lux2 < 0)
+		lux2 = 0;
+	if (lux1 < lux2)
+		lux1 = lux2;
+#else
+	lux1 = ((1000 * c0data) - (2005 * c1data)) / 71;
+	if (lux1 < 0)
+		lux1 = 0;
+	lux2 = ((604 * c0data) - (1090 * c1data)) / 71;
+	if (lux2 < 0)
+		lux2 = 0;
+	if (lux1 < lux2)
+		lux1 = lux2;
+#endif
+
+	o[0] = lux1;
+	o[1] = (short)((d[6] << 8) | d[5]);
+	o[2] = 0;
+
+	return 0;
+}
+
+static struct inv_mpu_slave slave_apds9930 = {
+	.suspend = suspend_apds9930_avago,
+	.resume = resume_apds9930_avago,
+	.setup = setup_apds9930_avago,
+	.read_data = read_data_apds9930_avago,
+	.rate_scale = LIGHT_SENSOR_RATE_SCALE,
+};
+
+int inv_mpu_setup_als_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.read_only_slave_id) {
+	case ALS_ID_APDS_9930:
+	case ALS_ID_TSL_2772:
+		st->slave_als = &slave_apds9930;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_als->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c
new file mode 100644
index 000000000000..633a5e4e40c2
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c
@@ -0,0 +1,640 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* AKM definitions */
+#define REG_AKM_ID			0x00
+#define REG_AKM_INFO			0x01
+#define REG_AKM_STATUS			0x02
+#define REG_AKM_MEASURE_DATA		0x03
+#define REG_AKM_MODE			0x0A
+#define REG_AKM_ST_CTRL			0x0C
+#define REG_AKM_SENSITIVITY		0x10
+#define REG_AKM8963_CNTL1		0x0A
+
+/* AK09911 register definition */
+#define REG_AK09911_DMP_READ		0x3
+#define REG_AK09911_STATUS1		0x10
+#define REG_AK09911_CNTL2		0x31
+#define REG_AK09911_SENSITIVITY		0x60
+#define REG_AK09911_MEASURE_DATA	0x11
+
+/* AK09912 register definition */
+#define REG_AK09912_DMP_READ		0x3
+#define REG_AK09912_STATUS1		0x10
+#define REG_AK09912_CNTL1		0x30
+#define REG_AK09912_CNTL2		0x31
+#define REG_AK09912_SENSITIVITY		0x60
+#define REG_AK09912_MEASURE_DATA	0x11
+
+/* AK09916 register definition */
+#define REG_AK09916_DMP_READ		0x3
+#define REG_AK09916_STATUS1		0x10
+#define REG_AK09916_CNTL2		0x31
+#define REG_AK09916_MEASURE_DATA	0x11
+
+#define DATA_AKM_ID			0x48
+#define DATA_AKM_MODE_PD		0x00
+#define DATA_AKM_MODE_SM		0x01
+#define DATA_AKM_MODE_ST		0x08
+#define DATA_AK09911_MODE_ST		0x10
+#define DATA_AK09912_MODE_ST		0x10
+#define DATA_AK09916_MODE_ST		0x10
+#define DATA_AKM_MODE_FR		0x0F
+#define DATA_AK09911_MODE_FR		0x1F
+#define DATA_AK09912_MODE_FR		0x1F
+#define DATA_AKM_SELF_TEST		0x40
+#define DATA_AKM_DRDY			0x01
+#define DATA_AKM8963_BIT		0x10
+#define DATA_AKM_STAT_MASK		0x0C
+
+/* 0.3 uT * (1 << 30) */
+#define DATA_AKM8975_SCALE		322122547
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8972_SCALE		644245094
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE0		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE1		161061273
+/* 0.6 uT * (1 << 30) */
+#define DATA_AK09911_SCALE		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09912_SCALE		161061273
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09916_SCALE		161061273
+#define DATA_MLX_SCALE			(4915 * (1L << 15))
+#define DATA_MLX_SCALE_EMPIRICAL	(26214 * (1L << 15))
+
+#define DATA_AKM8963_SCALE_SHIFT	4
+#define DATA_AKM_MIN_READ_TIME		(9 * NSEC_PER_MSEC)
+
+/* AK09912C NSF */
+/* 0:disable, 1:Low, 2:Middle, 3:High */
+#define DATA_AK9912_NSF			1
+#define DATA_AK9912_NSF_SHIFT		5
+
+#define DEF_ST_COMPASS_WAIT_MIN		(10 * 1000)
+#define DEF_ST_COMPASS_WAIT_MAX		(15 * 1000)
+#define DEF_ST_COMPASS_TRY_TIMES	10
+#define DEF_ST_COMPASS_8963_SHIFT	2
+#define X	0
+#define Y	1
+#define Z	2
+
+/* milliseconds between each access */
+#define AKM_RATE_SCALE			10
+#define MLX_RATE_SCALE			50
+
+static const short AKM8975_ST_Lower[3] = { -100, -100, -1000 };
+static const short AKM8975_ST_Upper[3] = { 100, 100, -300 };
+
+static const short AKM8972_ST_Lower[3] = { -50, -50, -500 };
+static const short AKM8972_ST_Upper[3] = { 50, 50, -100 };
+
+static const short AKM8963_ST_Lower[3] = { -200, -200, -3200 };
+static const short AKM8963_ST_Upper[3] = { 200, 200, -800 };
+
+static const short AK09911_ST_Lower[3] = { -30, -30, -400 };
+static const short AK09911_ST_Upper[3] = { 30, 30, -50 };
+
+static const short AK09912_ST_Lower[3] = { -200, -200, -1600 };
+static const short AK09912_ST_Upper[3] = { 200, 200, -400 };
+
+static const short AK09916_ST_Lower[3] = { -200, -200, -1000 };
+static const short AK09916_ST_Upper[3] = { 200, 200, -200 };
+
+static bool secondary_resume_state;
+/*
+ *  inv_setup_compass_akm() - Configure akm series compass.
+ */
+static int inv_setup_compass_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[4];
+	u8 sens, mode, cmd, addr;
+
+	addr = st->plat_data.secondary_i2c_addr;
+
+	result = inv_execute_read_secondary(st, 0, addr, REG_AKM_ID, 1, data);
+	if (result) {
+		pr_info("%s: read secondary failed\n", __func__);
+		return result;
+	}
+	if (data[0] != DATA_AKM_ID) {
+		pr_info
+	("%s: DATA_AKM_ID check failed data[0] [%x] ID [%x] Addr [0x%X]\n",
+		__func__, data[0], DATA_AKM_ID, addr);
+		return -ENXIO;
+	}
+
+	/* set AKM register for mode control */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+
+	/* AK09916 not have Fuse ROM */
+	if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		/* set dummy sens which should be utilized
+		 * in the same manner as AK09912 to make no adjustment. */
+		st->chip_info.compass_sens[0] = 128;
+		st->chip_info.compass_sens[1] = 128;
+		st->chip_info.compass_sens[2] = 128;
+		goto skip_akm_fuse_rom_read;
+	}
+
+	/* set AKM to Fuse ROM access mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09911_SENSITIVITY;
+		cmd = DATA_AK09911_MODE_FR;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09912_SENSITIVITY;
+		cmd = DATA_AK09912_MODE_FR;
+	} else {
+		sens = REG_AKM_SENSITIVITY;
+		cmd = DATA_AKM_MODE_FR;
+	}
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_read_secondary(st, 0, addr, sens, THREE_AXES);
+	if (result)
+		return result;
+	result = inv_write_secondary(st, 1, addr, mode, cmd);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_write_secondary(st, 2, addr, REG_AK09912_CNTL1,
+				DATA_AK9912_NSF <<
+				DATA_AK9912_NSF_SHIFT);
+		if (result)
+			return result;
+	}
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+			BIT_I2C_MST_EN);
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00, THREE_AXES,
+			st->chip_info.compass_sens);
+	if (result)
+		return result;
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		return result;
+
+skip_akm_fuse_rom_read:
+	pr_debug("%s senx=%d, seny=%d, senz=%d\n",
+		st->hw->name,
+		st->chip_info.compass_sens[0],
+		st->chip_info.compass_sens[1], st->chip_info.compass_sens[2]);
+
+	/* output data for slave 1 is fixed, single measure mode */
+	st->slave_compass->scale = 1;
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8975_ST_Upper;
+		st->slave_compass->st_lower = AKM8975_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8972_ST_Upper;
+		st->slave_compass->st_lower = AKM8972_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8963_ST_Upper;
+		st->slave_compass->st_lower = AKM8963_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM |
+			(st->slave_compass->scale << DATA_AKM8963_SCALE_SHIFT);
+	} else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09911_ST_Upper;
+		st->slave_compass->st_lower = AK09911_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09912_ST_Upper;
+		st->slave_compass->st_lower = AK09912_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09916_ST_Upper;
+		st->slave_compass->st_lower = AK09916_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else {
+		return -EINVAL;
+	}
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_write_secondary(st, 1, addr, mode, data[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV2_CTRL, 0);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_akm_read_data(struct inv_mpu_state *st, short *o)
+{
+	int result;
+	int i;
+	u8 d[DATA_AKM_99_BYTES_DMP - 1];
+	u8 *sens;
+
+	sens = st->chip_info.compass_sens;
+	result = 0;
+	for (i = 0; i < 6; i++)
+		d[1 + i] = st->fifo_data[i];
+	for (i = 0; i < 3; i++)
+		o[i] = (short)((d[i * 2 + 1] << 8) | d[i * 2 + 2]);
+
+	return result;
+}
+
+static int inv_check_akm_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[6], mode, addr;
+	u8 counter, cntl;
+	short x, y, z;
+	u8 *sens;
+	int shift;
+	u8 slv_ctrl[2];
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	u8 odr_cfg;
+#endif
+	addr = st->plat_data.secondary_i2c_addr;
+	sens = st->chip_info.compass_sens;
+
+	/* back up registers */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	/* SLV0_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* SLV1_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+	if (result)
+		return result;
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	/* I2C_MST ODR */
+	result = inv_plat_read(st, REG_I2C_MST_ODR_CONFIG, 1, &odr_cfg);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG, 0);
+	if (result)
+		return result;
+#endif
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+	/* set to power down mode */
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		goto AKM_fail;
+
+	/* write 1 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result = inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL,
+				DATA_AKM_SELF_TEST);
+		if (result)
+			goto AKM_fail;
+	}
+	/* set self test mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09911_MODE_ST);
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09912_MODE_ST);
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09916_MODE_ST);
+	else
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AKM_MODE_ST);
+
+	if (result)
+		goto AKM_fail;
+	counter = DEF_ST_COMPASS_TRY_TIMES;
+	while (counter > 0) {
+		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
+		if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09911_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09912_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09916_STATUS1,
+					1, data);
+		else
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AKM_STATUS, 1,
+					data);
+		if (result)
+			goto AKM_fail;
+		if ((data[0] & DATA_AKM_DRDY) == 0)
+			counter--;
+		else
+			counter = 0;
+	}
+	if ((data[0] & DATA_AKM_DRDY) == 0) {
+		result = -EINVAL;
+		goto AKM_fail;
+	}
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09911_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09912_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09916_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	}
+	if (result)
+		goto AKM_fail;
+
+	x = le16_to_cpup((__le16 *) (&data[0]));
+	y = le16_to_cpup((__le16 *) (&data[2]));
+	z = le16_to_cpup((__le16 *) (&data[4]));
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		shift = 7;
+	else
+		shift = 8;
+	x = ((x * (sens[0] + 128)) >> shift);
+	y = ((y * (sens[1] + 128)) >> shift);
+	z = ((z * (sens[2] + 128)) >> shift);
+	if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM8963_CNTL1, 1,
+				&cntl);
+		if (result)
+			goto AKM_fail;
+		if (0 == (cntl & DATA_AKM8963_BIT)) {
+			x <<= DEF_ST_COMPASS_8963_SHIFT;
+			y <<= DEF_ST_COMPASS_8963_SHIFT;
+			z <<= DEF_ST_COMPASS_8963_SHIFT;
+		}
+	}
+
+	pr_debug("lowerx=%d, upperx=%d, x=%d\n",
+		st->slave_compass->st_lower[X],
+		st->slave_compass->st_upper[X], x);
+	pr_debug("lowery=%d, uppery=%d, y=%d\n",
+		st->slave_compass->st_lower[Y],
+		st->slave_compass->st_upper[Y], y);
+	pr_debug("lowerz=%d, upperz=%d, z=%d\n",
+		st->slave_compass->st_lower[Z],
+		st->slave_compass->st_upper[Z], z);
+
+	result = -EINVAL;
+	if (x > st->slave_compass->st_upper[X] ||
+		x < st->slave_compass->st_lower[X])
+		goto AKM_fail;
+	if (y > st->slave_compass->st_upper[Y] ||
+		y < st->slave_compass->st_lower[Y])
+		goto AKM_fail;
+	if (z > st->slave_compass->st_upper[Z] ||
+		z < st->slave_compass->st_lower[Z])
+		goto AKM_fail;
+	result = 0;
+AKM_fail:
+	/*write 0 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result |= inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL, 0);
+	}
+	/*set to power down mode */
+	result |= inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+
+	/* restore registers */
+	result |= inv_set_bank(st, BANK_SEL_3);
+	result |= inv_plat_single_write(st, REG_I2C_SLV0_CTRL, slv_ctrl[0]);
+	result |= inv_plat_single_write(st, REG_I2C_SLV1_CTRL, slv_ctrl[1]);
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	result |= inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG, odr_cfg);
+#endif
+	result |= inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+/*
+ *  inv_write_akm_scale() - Configure the akm scale range.
+ */
+static int inv_write_akm_scale(struct inv_mpu_state *st, int data)
+{
+	char d, en;
+	int result;
+
+	if (COMPASS_ID_AK8963 != st->plat_data.sec_slave_id)
+		return 0;
+	en = !!data;
+	if (st->slave_compass->scale == en)
+		return 0;
+	d = (DATA_AKM_MODE_SM | (en << DATA_AKM8963_SCALE_SHIFT));
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV1_DO, d);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+	st->slave_compass->scale = en;
+
+	return 0;
+}
+
+/*
+ *  inv_read_akm_scale() - show AKM scale.
+ */
+static int inv_read_akm_scale(struct inv_mpu_state *st, int *scale)
+{
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8975_SCALE;
+	else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8972_SCALE;
+	else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id)
+		if (st->slave_compass->scale)
+			*scale = DATA_AKM8963_SCALE1;
+		else
+			*scale = DATA_AKM8963_SCALE0;
+	else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09911_SCALE;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09912_SCALE;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09916_SCALE;
+	else
+		return -EINVAL;
+
+	return IIO_VAL_INT;
+}
+
+static int inv_suspend_akm(struct inv_mpu_state *st)
+{
+	int result;
+
+	if (!secondary_resume_state)
+		return 0;
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+
+	/* slave 0 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* slave 1 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return result;
+}
+
+static int inv_resume_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 reg_addr, bytes;
+
+	if (secondary_resume_state)
+		return 0;
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+
+	/* slave 0 is used to read data from compass */
+	/*read mode */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_ADDR,
+			INV_MPU_BIT_I2C_READ |
+			st->plat_data.secondary_i2c_addr);
+	if (result)
+		return result;
+	/* AKM status register address is 1 */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09911_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09912_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09916_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else {
+		reg_addr = REG_AKM_INFO;
+		bytes = DATA_AKM_89_BYTES_DMP;
+	}
+	result = inv_plat_single_write(st, REG_I2C_SLV0_REG, reg_addr);
+	if (result)
+		return result;
+
+	/* slave 0 is enabled, read 10 or 8 bytes from here, swap bytes */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL,
+			INV_MPU_BIT_GRP |
+			INV_MPU_BIT_BYTE_SW |
+			INV_MPU_BIT_SLV_EN | bytes);
+	if (result)
+		return result;
+	/* slave 1 is enabled, write byte length is 1 */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL,
+			INV_MPU_BIT_SLV_EN | 1);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return result;
+}
+
+static struct inv_mpu_slave slave_akm = {
+	.suspend = inv_suspend_akm,
+	.resume = inv_resume_akm,
+	.get_scale = inv_read_akm_scale,
+	.set_scale = inv_write_akm_scale,
+	.self_test = inv_check_akm_self_test,
+	.setup = inv_setup_compass_akm,
+	.read_data = inv_akm_read_data,
+	.rate_scale = AKM_RATE_SCALE,
+	.min_read_time = DATA_AKM_MIN_READ_TIME,
+};
+
+int inv_mpu_setup_compass_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.sec_slave_id) {
+	case COMPASS_ID_AK8975:
+	case COMPASS_ID_AK8972:
+	case COMPASS_ID_AK8963:
+	case COMPASS_ID_AK09911:
+	case COMPASS_ID_AK09912:
+	case COMPASS_ID_AK09916:
+		st->slave_compass = &slave_akm;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_compass->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c
new file mode 100644
index 000000000000..7ca2420de9c5
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c
@@ -0,0 +1,521 @@
+/*
+* Copyright (C) 2017-2018 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* Constants */
+#define SHIFT_RIGHT_4_POSITION				 4
+#define SHIFT_LEFT_2_POSITION                2
+#define SHIFT_LEFT_4_POSITION                4
+#define SHIFT_LEFT_5_POSITION                5
+#define SHIFT_LEFT_8_POSITION                8
+#define SHIFT_LEFT_12_POSITION               12
+#define SHIFT_LEFT_16_POSITION               16
+
+/* Sensor Specific constants */
+#define BMP280_SLEEP_MODE                    0x00
+#define BMP280_FORCED_MODE                   0x01
+#define BMP280_NORMAL_MODE                   0x03
+#define BMP280_SOFT_RESET                    0xB6
+
+#define BMP280_DELAYTIME_MS_NONE             0
+#define BMP280_DELAYTIME_MS_5                5
+#define BMP280_DELAYTIME_MS_6                6
+#define BMP280_DELAYTIME_MS_8                8
+#define BMP280_DELAYTIME_MS_12               12
+#define BMP280_DELAYTIME_MS_22               22
+#define BMP280_DELAYTIME_MS_38               38
+
+#define BMP280_OVERSAMPLING_SKIPPED          0x00
+#define BMP280_OVERSAMPLING_1X               0x01
+#define BMP280_OVERSAMPLING_2X               0x02
+#define BMP280_OVERSAMPLING_4X               0x03
+#define BMP280_OVERSAMPLING_8X               0x04
+#define BMP280_OVERSAMPLING_16X              0x05
+
+#define BMP280_ULTRALOWPOWER_MODE            0x00
+#define BMP280_LOWPOWER_MODE	             0x01
+#define BMP280_STANDARDRESOLUTION_MODE       0x02
+#define BMP280_HIGHRESOLUTION_MODE           0x03
+#define BMP280_ULTRAHIGHRESOLUTION_MODE      0x04
+
+#define BMP280_ULTRALOWPOWER_OSRS_P          BMP280_OVERSAMPLING_1X
+#define BMP280_ULTRALOWPOWER_OSRS_T          BMP280_OVERSAMPLING_1X
+
+#define BMP280_LOWPOWER_OSRS_P	             BMP280_OVERSAMPLING_2X
+#define BMP280_LOWPOWER_OSRS_T	             BMP280_OVERSAMPLING_1X
+
+#define BMP280_STANDARDRESOLUTION_OSRS_P     BMP280_OVERSAMPLING_4X
+#define BMP280_STANDARDRESOLUTION_OSRS_T     BMP280_OVERSAMPLING_1X
+
+#define BMP280_HIGHRESOLUTION_OSRS_P         BMP280_OVERSAMPLING_8X
+#define BMP280_HIGHRESOLUTION_OSRS_T         BMP280_OVERSAMPLING_1X
+
+#define BMP280_ULTRAHIGHRESOLUTION_OSRS_P    BMP280_OVERSAMPLING_16X
+#define BMP280_ULTRAHIGHRESOLUTION_OSRS_T    BMP280_OVERSAMPLING_2X
+
+#define BMP280_FILTERCOEFF_OFF               0x00
+#define BMP280_FILTERCOEFF_2                 0x01
+#define BMP280_FILTERCOEFF_4                 0x02
+#define BMP280_FILTERCOEFF_8                 0x03
+#define BMP280_FILTERCOEFF_16                0x04
+
+/*calibration parameters */
+#define BMP280_DIG_T1_LSB_REG                0x88
+#define BMP280_DIG_T1_MSB_REG                0x89
+#define BMP280_DIG_T2_LSB_REG                0x8A
+#define BMP280_DIG_T2_MSB_REG                0x8B
+#define BMP280_DIG_T3_LSB_REG                0x8C
+#define BMP280_DIG_T3_MSB_REG                0x8D
+#define BMP280_DIG_P1_LSB_REG                0x8E
+#define BMP280_DIG_P1_MSB_REG                0x8F
+#define BMP280_DIG_P2_LSB_REG                0x90
+#define BMP280_DIG_P2_MSB_REG                0x91
+#define BMP280_DIG_P3_LSB_REG                0x92
+#define BMP280_DIG_P3_MSB_REG                0x93
+#define BMP280_DIG_P4_LSB_REG                0x94
+#define BMP280_DIG_P4_MSB_REG                0x95
+#define BMP280_DIG_P5_LSB_REG                0x96
+#define BMP280_DIG_P5_MSB_REG                0x97
+#define BMP280_DIG_P6_LSB_REG                0x98
+#define BMP280_DIG_P6_MSB_REG                0x99
+#define BMP280_DIG_P7_LSB_REG                0x9A
+#define BMP280_DIG_P7_MSB_REG                0x9B
+#define BMP280_DIG_P8_LSB_REG                0x9C
+#define BMP280_DIG_P8_MSB_REG                0x9D
+#define BMP280_DIG_P9_LSB_REG                0x9E
+#define BMP280_DIG_P9_MSB_REG                0x9F
+
+#define BMP280_CHIPID_REG                    0xD0	/*Chip ID Register */
+#define BMP280_RESET_REG                     0xE0	/*Softreset Register */
+#define BMP280_STATUS_REG                    0xF3	/*Status Register */
+#define BMP280_CTRLMEAS_REG                  0xF4  /*Ctrl Measure Register */
+#define BMP280_CONFIG_REG                    0xF5  /*Configuration Register */
+#define BMP280_PRESSURE_MSB_REG              0xF7   /*Pressure MSB Register */
+#define BMP280_PRESSURE_LSB_REG              0xF8   /*Pressure LSB Register */
+#define BMP280_PRESSURE_XLSB_REG             0xF9  /*Pressure XLSB Register */
+#define BMP280_TEMPERATURE_MSB_REG           0xFA  /*Temperature MSB Reg */
+#define BMP280_TEMPERATURE_LSB_REG           0xFB  /*Temperature LSB Reg */
+#define BMP280_TEMPERATURE_XLSB_REG          0xFC  /*Temperature XLSB Reg */
+
+/* Status Register */
+#define BMP280_STATUS_REG_MEASURING__POS           3
+#define BMP280_STATUS_REG_MEASURING__MSK           0x08
+#define BMP280_STATUS_REG_MEASURING__LEN           1
+#define BMP280_STATUS_REG_MEASURING__REG           BMP280_STATUS_REG
+
+#define BMP280_STATUS_REG_IMUPDATE__POS            0
+#define BMP280_STATUS_REG_IMUPDATE__MSK            0x01
+#define BMP280_STATUS_REG_IMUPDATE__LEN            1
+#define BMP280_STATUS_REG_IMUPDATE__REG            BMP280_STATUS_REG
+
+/* Control Measurement Register */
+#define BMP280_CTRLMEAS_REG_OSRST__POS             5
+#define BMP280_CTRLMEAS_REG_OSRST__MSK             0xE0
+#define BMP280_CTRLMEAS_REG_OSRST__LEN             3
+#define BMP280_CTRLMEAS_REG_OSRST__REG             BMP280_CTRLMEAS_REG
+
+#define BMP280_CTRLMEAS_REG_OSRSP__POS             2
+#define BMP280_CTRLMEAS_REG_OSRSP__MSK             0x1C
+#define BMP280_CTRLMEAS_REG_OSRSP__LEN             3
+#define BMP280_CTRLMEAS_REG_OSRSP__REG             BMP280_CTRLMEAS_REG
+
+#define BMP280_CTRLMEAS_REG_MODE__POS              0
+#define BMP280_CTRLMEAS_REG_MODE__MSK              0x03
+#define BMP280_CTRLMEAS_REG_MODE__LEN              2
+#define BMP280_CTRLMEAS_REG_MODE__REG              BMP280_CTRLMEAS_REG
+
+/* Configuation Register */
+#define BMP280_CONFIG_REG_TSB__POS                 5
+#define BMP280_CONFIG_REG_TSB__MSK                 0xE0
+#define BMP280_CONFIG_REG_TSB__LEN                 3
+#define BMP280_CONFIG_REG_TSB__REG                 BMP280_CONFIG_REG
+
+#define BMP280_CONFIG_REG_FILTER__POS              2
+#define BMP280_CONFIG_REG_FILTER__MSK              0x1C
+#define BMP280_CONFIG_REG_FILTER__LEN              3
+#define BMP280_CONFIG_REG_FILTER__REG              BMP280_CONFIG_REG
+
+#define BMP280_CONFIG_REG_SPI3WEN__POS             0
+#define BMP280_CONFIG_REG_SPI3WEN__MSK             0x01
+#define BMP280_CONFIG_REG_SPI3WEN__LEN             1
+#define BMP280_CONFIG_REG_SPI3WEN__REG             BMP280_CONFIG_REG
+
+/* Data Register */
+#define BMP280_PRESSURE_XLSB_REG_DATA__POS         4
+#define BMP280_PRESSURE_XLSB_REG_DATA__MSK         0xF0
+#define BMP280_PRESSURE_XLSB_REG_DATA__LEN         4
+#define BMP280_PRESSURE_XLSB_REG_DATA__REG         BMP280_PRESSURE_XLSB_REG
+
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__POS      4
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__MSK      0xF0
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__LEN      4
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__REG      BMP280_TEMPERATURE_XLSB_REG
+
+#define BMP280_RATE_SCALE  35
+#define DATA_BMP280_MIN_READ_TIME            (32 * NSEC_PER_MSEC)
+#define BMP280_DATA_BYTES                6
+#define DATA_BMP280_ID                   0x58
+static int odr_config[] = { 166, 15, 8, 4, 2, 1 };
+
+/** this structure holds all device specific calibration parameters */
+struct bmp280_calibration_param_t {
+	u32 dig_T1;
+	s32 dig_T2;
+	s32 dig_T3;
+	u32 dig_P1;
+	s32 dig_P2;
+	s32 dig_P3;
+	s32 dig_P4;
+	s32 dig_P5;
+	s32 dig_P6;
+	s32 dig_P7;
+	s32 dig_P8;
+	s32 dig_P9;
+
+	s32 t_fine;
+};
+/** BMP280 image registers data structure */
+struct bmp280_t {
+	struct bmp280_calibration_param_t cal_param;
+
+	u8 chip_id;
+	u8 dev_addr;
+
+	u8 waittime;
+
+	u8 osrs_t;
+	u8 osrs_p;
+};
+static struct bmp280_t bmp280;
+static bool secondary_resume_state;
+static int curr_t_sb;
+
+static int bmp280_get_calib_param(struct inv_mpu_state *st)
+{
+	u8 d[24];
+	int r;
+
+	r = inv_execute_read_secondary(st, 3,
+				       st->plat_data.aux_i2c_addr,
+				       BMP280_DIG_T1_LSB_REG, 12, d);
+	if (r)
+		return r;
+	r = inv_execute_read_secondary(st, 3,
+				       st->plat_data.aux_i2c_addr,
+				       BMP280_DIG_T1_LSB_REG + 12, 12, &d[12]);
+	if (r)
+		return r;
+
+	bmp280.cal_param.dig_T1 = (u16) ((((u16) ((u8) d[1])) <<
+					  SHIFT_LEFT_8_POSITION) | d[0]);
+	bmp280.cal_param.dig_T2 = (s16) ((((s16) ((s8) d[3])) <<
+					  SHIFT_LEFT_8_POSITION) | d[2]);
+	bmp280.cal_param.dig_T3 = (s16) ((((s16) ((s8) d[5])) <<
+					  SHIFT_LEFT_8_POSITION) | d[4]);
+	bmp280.cal_param.dig_P1 = (u16) ((((u16) ((u8) d[7])) <<
+					  SHIFT_LEFT_8_POSITION) | d[6]);
+	bmp280.cal_param.dig_P2 = (s16) ((((s16) ((s8) d[9])) <<
+					  SHIFT_LEFT_8_POSITION) | d[8]);
+	bmp280.cal_param.dig_P3 = (s16) ((((s16) ((s8) d[11])) <<
+					  SHIFT_LEFT_8_POSITION) | d[10]);
+	bmp280.cal_param.dig_P4 = (s16) ((((s16) ((s8) d[13])) <<
+					  SHIFT_LEFT_8_POSITION) | d[12]);
+	bmp280.cal_param.dig_P5 = (s16) ((((s16) ((s8) d[15])) <<
+					  SHIFT_LEFT_8_POSITION) | d[14]);
+	bmp280.cal_param.dig_P6 = (s16) ((((s16) ((s8) d[17])) <<
+					  SHIFT_LEFT_8_POSITION) | d[16]);
+	bmp280.cal_param.dig_P7 = (s16) ((((s16) ((s8) d[19])) <<
+					  SHIFT_LEFT_8_POSITION) | d[18]);
+	bmp280.cal_param.dig_P8 = (s16) ((((s16) ((s8) d[21])) <<
+					  SHIFT_LEFT_8_POSITION) | d[20]);
+	bmp280.cal_param.dig_P9 = (s16) ((((s16) ((s8) d[23])) <<
+					  SHIFT_LEFT_8_POSITION) | d[22]);
+
+	return 0;
+}
+
+static int inv_setup_bmp280(struct inv_mpu_state *st)
+{
+	int r;
+	u8 d[1], addr;
+
+	addr = st->plat_data.aux_i2c_addr;
+	/* issue soft reset */
+	r = inv_execute_write_secondary(st, 3, addr,
+					BMP280_RESET_REG, BMP280_SOFT_RESET);
+	if (r)
+		return r;
+
+	msleep(100);
+
+	r = inv_execute_read_secondary(st, 3, addr, BMP280_CHIPID_REG, 1, d);
+	if (r)
+		return r;
+	if (d[0] != DATA_BMP280_ID) {
+		pr_info("BMP280 not found. Addr:0x%02X, ID:0x%02X (expected:0x%02X)\n",
+				addr, d[0], DATA_BMP280_ID);
+		return -ENXIO;
+	}
+	pr_info("BMP280 found. Addr:0x%02X, ID:0x%02X\n", addr, d[0]);
+
+	/* set pressure as ultra high resolution */
+	bmp280.osrs_t = BMP280_ULTRAHIGHRESOLUTION_OSRS_T;
+	bmp280.osrs_p = BMP280_ULTRAHIGHRESOLUTION_OSRS_P;
+
+	r = bmp280_get_calib_param(st);
+
+	return r;
+}
+
+static int inv_check_bmp280_self_test(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static int inv_write_bmp280_scale(struct inv_mpu_state *st, int data)
+{
+	return 0;
+}
+
+static int inv_read_bmp280_scale(struct inv_mpu_state *st, int *scale)
+{
+	return 0;
+}
+
+static int inv_resume_bmp280(struct inv_mpu_state *st)
+{
+	int r, rate, i;
+	u8 d, addr;
+
+	rate = st->sensor[SENSOR_PRESSURE].rate;
+	i = 0;
+	while (rate < odr_config[i])
+		i++;
+
+	r = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (r)
+		return r;
+	curr_t_sb = i;
+
+	addr = st->plat_data.aux_i2c_addr;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				  MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+	if (!st->chip_config.compass_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (r)
+			return r;
+	}
+	if (!st->chip_config.als_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[2].ctrl, 0);
+		if (r)
+			return r;
+	}
+
+	/* set IIR filter as 4 */
+	d = (i << SHIFT_LEFT_5_POSITION) |
+	    (BMP280_FILTERCOEFF_16 << SHIFT_LEFT_2_POSITION);
+	r = inv_execute_write_secondary(st, 3, addr,
+					BMP280_CONFIG_REG_FILTER__REG, d);
+	if (r)
+		return r;
+
+	d = (bmp280.osrs_t << SHIFT_LEFT_5_POSITION) +
+	    (bmp280.osrs_p << SHIFT_LEFT_2_POSITION) + BMP280_NORMAL_MODE;
+	r = inv_execute_write_secondary(st, 3, addr, BMP280_CTRLMEAS_REG, d);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	/* slave 3 is used to read data from pressure sensor */
+	/*read mode */
+	r = inv_read_secondary(st, 3, addr, BMP280_PRESSURE_MSB_REG,
+			       BMP280_DATA_BYTES);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return r;
+}
+
+static int inv_suspend_bmp280(struct inv_mpu_state *st)
+{
+	int r;
+
+	if (!secondary_resume_state)
+		return 0;
+	r = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (r)
+		return r;
+
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				  MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+	if (!st->chip_config.compass_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (r)
+			return r;
+	}
+	if (!st->chip_config.als_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[2].ctrl, 0);
+		if (r)
+			return r;
+	}
+	/* make pressure into sleep mode */
+	r = inv_execute_write_secondary(st, 3, st->plat_data.aux_i2c_addr,
+					BMP280_CTRLMEAS_REG, 0);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	/* slave 3 is disabled */
+	r = inv_plat_single_write(st, REG_I2C_SLV3_CTRL, 0);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return r;
+}
+
+static s32 bmp280_compensate_T_int32(s32 adc_t)
+{
+	s32 v_x1_u32r = 0;
+	s32 v_x2_u32r = 0;
+	s32 temperature = 0;
+
+	v_x1_u32r = ((((adc_t >> 3) - ((s32)
+				       bmp280.cal_param.dig_T1 << 1))) *
+		     ((s32) bmp280.cal_param.dig_T2)) >> 11;
+	v_x2_u32r = (((((adc_t >> 4) -
+			((s32) bmp280.cal_param.dig_T1)) * ((adc_t >> 4) -
+							    ((s32) bmp280.
+							     cal_param.
+							     dig_T1))) >> 12) *
+		     ((s32) bmp280.cal_param.dig_T3)) >> 14;
+	bmp280.cal_param.t_fine = v_x1_u32r + v_x2_u32r;
+	temperature = (bmp280.cal_param.t_fine * 5 + 128) >> 8;
+
+	return temperature;
+}
+
+static u32 bmp280_compensate_P_int32(s32 adc_p)
+{
+	s32 v_x1_u32r = 0;
+	s32 v_x2_u32r = 0;
+	u32 pressure = 0;
+
+	v_x1_u32r = (((s32) bmp280.cal_param.t_fine) >> 1) - (s32) 64000;
+	v_x2_u32r = (((v_x1_u32r >> 2) * (v_x1_u32r >> 2)) >> 11) *
+	    ((s32) bmp280.cal_param.dig_P6);
+	v_x2_u32r = v_x2_u32r + ((v_x1_u32r *
+				  ((s32) bmp280.cal_param.dig_P5)) << 1);
+	v_x2_u32r = (v_x2_u32r >> 2) + (((s32) bmp280.cal_param.dig_P4) << 16);
+	v_x1_u32r = (((bmp280.cal_param.dig_P3 * (((v_x1_u32r >> 2) *
+						   (v_x1_u32r >> 2)) >> 13)) >>
+		      3) +
+		     ((((s32) bmp280.cal_param.dig_P2) *
+		       v_x1_u32r) >> 1)) >> 18;
+	v_x1_u32r =
+	    ((((32768 + v_x1_u32r)) * ((s32) bmp280.cal_param.dig_P1)) >> 15);
+	/* Avoid exception caused by division by zero */
+	if (v_x1_u32r == 0)
+		return 0;
+	pressure = (((u32) (((s32) 1048576) - adc_p) -
+		     (v_x2_u32r >> 12))) * 3125;
+	if (pressure < 0x80000000)
+		pressure = (pressure << 1) / ((u32) v_x1_u32r);
+	else
+		pressure = (pressure / (u32) v_x1_u32r) * 2;
+	v_x1_u32r = (((s32) bmp280.cal_param.dig_P9) *
+		     ((s32) (((pressure >> 3) * (pressure >> 3)) >> 13)))
+	    >> 12;
+	v_x2_u32r = (((s32) (pressure >> 2)) *
+		     ((s32) bmp280.cal_param.dig_P8)) >> 13;
+	pressure = (u32) ((s32) pressure +
+			  ((v_x1_u32r + v_x2_u32r +
+			    bmp280.cal_param.dig_P7) >> 4));
+
+	return pressure;
+}
+
+static int inv_bmp280_read_data(struct inv_mpu_state *st, short *o)
+{
+	int r;
+	u8 *d;
+	s32 upressure, utemperature;
+
+	d = st->fifo_data;
+	/* pressure */
+	upressure = (s32) ((((s32) (d[0]))
+			    << SHIFT_LEFT_12_POSITION) | (((u32) (d[1]))
+							  <<
+							  SHIFT_LEFT_4_POSITION)
+			   | ((u32) d[2] >> SHIFT_RIGHT_4_POSITION));
+
+	/* Temperature */
+	utemperature = (s32) ((((s32) (d[3])) << SHIFT_LEFT_12_POSITION) |
+			      (((u32) (d[4])) << SHIFT_LEFT_4_POSITION)
+			      | ((u32) d[5] >> SHIFT_RIGHT_4_POSITION));
+
+	bmp280_compensate_T_int32(utemperature);
+	r = bmp280_compensate_P_int32(upressure);
+	r *= 100; /* Pa x 100 */
+	o[0] = 0;
+	o[1] = (r >> 16);
+	o[2] = (r & 0xffff);
+
+	return 0;
+}
+
+static struct inv_mpu_slave slave_bmp280 = {
+	.suspend = inv_suspend_bmp280,
+	.resume = inv_resume_bmp280,
+	.get_scale = inv_read_bmp280_scale,
+	.set_scale = inv_write_bmp280_scale,
+	.self_test = inv_check_bmp280_self_test,
+	.setup = inv_setup_bmp280,
+	.read_data = inv_bmp280_read_data,
+	.rate_scale = BMP280_RATE_SCALE,
+	.min_read_time = DATA_BMP280_MIN_READ_TIME,
+};
+
+int inv_mpu_setup_pressure_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.aux_slave_id) {
+	case PRESSURE_ID_BMP280:
+		st->slave_pressure = &slave_bmp280;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_pressure->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_core_20690.c b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_core_20690.c
new file mode 100644
index 000000000000..6bd9026e2a7b
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_core_20690.c
@@ -0,0 +1,1678 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM20690] = {128, "icm20690"},
+};
+
+static const int ois_gyro_fs[] = {250, 500, 1000, 2000, -1, 31, 62, 125};
+static const int ois_accel_fs[] = {2, 4, 8, 1};
+
+static char debug_reg_addr = 0x6;
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[0];
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[1];
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[2];
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0 */
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	case ATTR_DEBUG_WRITE_CFG:
+		break;
+	}
+	return count;
+}
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		st->chip_config.low_power_gyro_on = !!data;
+		break;
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		st->debug_determine_engine_on = !!data;
+		break;
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_STEP_THRESH:
+		st->ped.step_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_THRESH:
+		st->ped.int_thresh = data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int _debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (!st->debug_determine_engine_on)
+		return -EINVAL;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return -ENOSYS;
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return -ENOSYS;
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		st->gyro_cal_enable = !!data;
+		break;
+	case ATTR_DMP_EVENT_INT_ON:
+		st->chip_config.dmp_event_int_on = !!data;
+		break;
+	case ATTR_DMP_ON:
+		st->chip_config.dmp_on = !!data;
+		break;
+	case ATTR_GYRO_ENABLE:
+		st->chip_config.gyro_enable = !!data;
+		break;
+	case ATTR_ACCEL_ENABLE:
+		st->chip_config.accel_enable = !!data;
+		break;
+	case ATTR_COMPASS_ENABLE:
+		return -ENODEV;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = DEBUG_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_debug_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _debug_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		return -ENODEV;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.stationary_detect_enable)
+			return count;
+		st->chip_config.stationary_detect_enable = !!data;
+		pr_info("Stationary Detect %s\n",
+			st->chip_config.stationary_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.motion_detect_enable)
+			return count;
+		st->chip_config.motion_detect_enable = !!data;
+		pr_info("Motion Detect %s\n",
+			st->chip_config.motion_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0, sizeof(struct spi_transfer));
+
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_ACTIVITY_ON:
+		return -ENODEV;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store() -  calling this function will store current
+ *                        non-dmp parameter settings
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+static int _ois_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	switch (this_attr->address) {
+	case IN_OIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ois.en);
+	case IN_OIS_ACCEL_FS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+						ois_accel_fs[st->ois.accel_fs]);
+	case IN_OIS_GYRO_FS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+						ois_gyro_fs[st->ois.gyro_fs]);
+	default:
+		return -EINVAL;
+	}
+}
+static ssize_t inv_ois_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _ois_show(dev, attr, buf);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+static ssize_t _ois_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case IN_OIS_ENABLE:
+		st->ois.en = !!data;
+		set_inv_enable(indio_dev);
+		break;
+	case IN_OIS_ACCEL_FS:
+		if (data < ARRAY_SIZE(ois_accel_fs)) {
+			st->ois.accel_fs = data;
+			result = inv_set_accel_sf(st);
+			if (result)
+				return result;
+		} else
+			return -EINVAL;
+
+		break;
+	case IN_OIS_GYRO_FS:
+		if ((data < ARRAY_SIZE(ois_gyro_fs))
+						&& (ois_gyro_fs[data] != -1)) {
+			result = inv_set_gyro_sf(st);
+			if (result)
+				return result;
+			st->ois.gyro_fs = data;
+		} else
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store() -  calling this function will store current
+ *                        non-dmp parameter settings
+ */
+static ssize_t inv_ois_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	inv_switch_power_in_lp(st, true);
+	result = _ois_store(dev, attr, buf, count);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.compass_enable) && (!st->ois.en))
+		inv_set_power(st, false);
+	else
+		inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show() -  calling this function will show current
+ *                        dmp parameters.
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_COMPASS_SCALE:
+		st->slave_compass->get_scale(st, &result);
+		return snprintf(buf, MAX_WR_SZ, "%d\n", result);
+	case ATTR_COMPASS_SENSITIVITY_X:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[0]);
+	case ATTR_COMPASS_SENSITIVITY_Y:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[1]);
+	case ATTR_COMPASS_SENSITIVITY_Z:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[2]);
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.accel_enable);
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return -ENOSYS;
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_cal_enable);
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->debug_determine_engine_on);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		return -ENOSYS;
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		return -ENOSYS;
+	case ATTR_FIRMWARE_LOADED:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.firmware_loaded);
+	case ATTR_DMP_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.dmp_on);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_EVENT_INT_ON:
+		return snprintf(buf, MAX_WR_SZ,
+			"%d\n", st->chip_config.dmp_event_int_on);
+	case ATTR_DMP_PED_INT_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_on);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_STEP_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.step_thresh);
+	case ATTR_DMP_PED_INT_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_thresh);
+	case ATTR_DMP_SMD_ENABLE:
+		return -ENODEV;
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.stationary_detect_enable);
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.motion_detect_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.eis_enable);
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		return -ENOSYS;
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_COMPASS_ENABLE:
+		return -ENODEV;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_wake_l_on);
+	case ATTR_DMP_ACTIVITY_ON:
+		return -ENODEV;
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on);
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return -ENOSYS;
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_COMPASS_MATRIX:
+		if (st->plat_data.sec_slave_type ==
+			SECONDARY_SLAVE_TYPE_COMPASS)
+			m = st->plat_data.secondary_orientation;
+		else
+			return -ENODEV;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_SECONDARY_NAME:
+		{
+			const char *n[] = { "NULL", "AK8975", "AK8972",
+				"AK8963", "MLX90399",
+				"AK09911", "AK09912", "AK09915", "AK09916"};
+
+			switch (st->plat_data.sec_slave_id) {
+			case COMPASS_ID_AK8975:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[1]);
+			case COMPASS_ID_AK8972:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[2]);
+			case COMPASS_ID_AK8963:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[3]);
+			case COMPASS_ID_MLX90399:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[4]);
+			case COMPASS_ID_AK09911:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[5]);
+			case COMPASS_ID_AK09912:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[6]);
+			case COMPASS_ID_AK09915:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[7]);
+			case COMPASS_ID_AK09916:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[8]);
+			default:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[0]);
+			}
+		}
+	case ATTR_DMP_MAGN_ACCURACY:
+		return -ENODEV;
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_ANGLVEL_X_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_ois_st_bias[0]);
+	case ATTR_ANGLVEL_Y_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_ois_st_bias[1]);
+	case ATTR_ANGLVEL_Z_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_ois_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_ACCEL_X_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_ois_st_bias[0]);
+	case ATTR_ACCEL_Y_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_ois_st_bias[1]);
+	case ATTR_ACCEL_Z_OIS_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_ois_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[2]);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+	int test_res = 0;
+	s16 gyro_offset_reg[3];
+	s16 accel_offset_reg[3];
+
+	mutex_lock(&st->lock);
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+
+	/* save the current offset registers */
+	res = inv_read_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+	if (res)
+		goto err_out;
+	/* write initial offset register values */
+	res = inv_write_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (res)
+		goto restore_regs;
+
+	res = inv_switch_power_in_lp(st, false);
+	if (res)
+		goto restore_regs;
+
+	test_res = inv_hw_self_test(st);
+
+restore_regs:
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+	/* restore offset register values */
+	inv_write_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+
+err_out:
+	inv_switch_power_in_lp(st, false);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", test_res);
+}
+
+static ssize_t inv_ois_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	u8 data[2];
+	s32 temp;
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_plat_read(st, REG_TEMP_OUT_H, 2, data);
+	if (res)
+		return res;
+	mutex_unlock(&st->lock);
+
+	temp = (s32)be16_to_cpup((__be16 *)(data)) * 10000;
+	temp = temp / TEMP_SENSITIVITY + TEMP_OFFSET;
+
+	return snprintf(buf, MAX_WR_SZ, "%d %lld\n", temp, get_time_ns());
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+static ssize_t inv_pick_up_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_sensor_raw_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int res, i, mag[3];
+	u8 d[DATA_AKM_99_BYTES_DMP];
+	u8 *sens;
+
+	switch (this_attr->address) {
+	case SENSOR_L_ACCEL:
+		{
+			res = inv_plat_read(st, REG_ACCEL_XOUT_H_SH,
+					INV_RAW_DATA_BYTES, d);
+			if (res)
+				return res;
+			return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+					(s16) (be16_to_cpup((short *)&d[0])),
+					(s16) (be16_to_cpup((short *)&d[2])),
+					(s16) (be16_to_cpup((short *)&d[4])));
+		}
+
+	case SENSOR_L_GYRO:
+		{
+			res = inv_plat_read(st, REG_GYRO_XOUT_H_SH,
+					INV_RAW_DATA_BYTES, d);
+			if (res)
+				return res;
+
+			return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+					(s16) (be16_to_cpup((short *)&d[0])),
+					(s16) (be16_to_cpup((short *)&d[2])),
+					(s16) (be16_to_cpup((short *)&d[4])));
+
+		}
+	case SENSOR_L_MAG:
+		{
+			res = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00,
+					DATA_AKM_99_BYTES_DMP, d);
+			if (res)
+				return res;
+			sens = st->chip_info.compass_sens;
+			for (i = 0; i < 3; i++) {
+				mag[i] = (s16) (be16_to_cpup((short *)&d[i * 2 + 2]));
+				mag[i] *= (sens[i] + 128);
+				mag[i] >>= 7;
+			}
+
+			return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+					mag[0], mag[1], mag[2]);
+		}
+	default:
+		break;
+	}
+	return 0;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+static DEVICE_ATTR(poll_pedometer, S_IRUGO, inv_ped_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO, inv_tilt_show, NULL);
+static DEVICE_ATTR(poll_pick_up, S_IRUGO, inv_pick_up_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+static DEVICE_ATTR(misc_ois_self_test, S_IRUGO | S_IWUSR,
+			inv_ois_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+static IIO_DEVICE_ATTR(info_magn_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_COMPASS_MATRIX);
+
+static IIO_DEVICE_ATTR(info_secondary_name, S_IRUGO, inv_attr_show, NULL,
+			ATTR_SECONDARY_NAME);
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_magn_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_magn_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_WAKE);
+
+/* OIS related sysfs */
+static IIO_DEVICE_ATTR(in_ois_accel_fs, S_IRUGO | S_IWUSR, inv_ois_show,
+			inv_ois_store, IN_OIS_ACCEL_FS);
+static IIO_DEVICE_ATTR(in_ois_gyro_fs, S_IRUGO | S_IWUSR, inv_ois_show,
+			inv_ois_store, IN_OIS_GYRO_FS);
+static IIO_DEVICE_ATTR(in_ois_enable, S_IRUGO | S_IWUSR, inv_ois_show,
+			inv_ois_store, IN_OIS_ENABLE);
+
+/* test related raw data reading sysfs entries */
+static IIO_DEVICE_ATTR(in_accel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_magn_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_MAG);
+
+/* debug determine engine related sysfs */
+static IIO_DEVICE_ATTR(debug_anglvel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_gyro_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_GYRO_CAL_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ACCEL_CAL_ENABLE);
+
+static IIO_DEVICE_ATTR(debug_gyro_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_GYRO_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_ACCEL_ENABLE);
+static IIO_DEVICE_ATTR(debug_compass_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_COMPASS_ENABLE);
+static IIO_DEVICE_ATTR(debug_dmp_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ON);
+static IIO_DEVICE_ATTR(debug_dmp_event_int_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_EVENT_INT_ON);
+static IIO_DEVICE_ATTR(debug_magn_accuracy, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_DMP_MAGN_ACCURACY);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+static IIO_DEVICE_ATTR(in_magn_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SCALE);
+
+static IIO_DEVICE_ATTR(in_magn_sensitivity_x, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_X);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_y, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Y);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_z, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Z);
+
+static IIO_DEVICE_ATTR(debug_low_power_gyro_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_LOW_POWER_GYRO_ON);
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_cfg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_WRITE_CFG);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_OIS_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_OIS_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_OIS_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_OIS_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_OIS_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_ois_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_OIS_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(debug_determine_engine_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON);
+
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(event_stationary_detect_enable, S_IRUGO | S_IWUSR,
+		inv_attr_show, inv_basic_attr_store,
+		ATTR_DMP_STATIONARY_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_motion_detect_enable, S_IRUGO | S_IWUSR,
+		inv_attr_show, inv_basic_attr_store,
+		ATTR_DMP_MOTION_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_secondary_name.dev_attr.attr,
+	&iio_dev_attr_debug_magn_accuracy.dev_attr.attr,
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+	&iio_dev_attr_in_accel_raw.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_raw.dev_attr.attr,
+	&iio_dev_attr_in_magn_raw.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_accel_enable.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_event_int_on.dev_attr.attr,
+	&iio_dev_attr_debug_low_power_gyro_on.dev_attr.attr,
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+	&iio_dev_attr_debug_cfg_write.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_on.dev_attr.attr,
+	&iio_dev_attr_debug_accel_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_accel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_determine_engine_on.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_enable.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_anglvel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_compass_enable.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+};
+
+static const struct attribute *inv_compass_attributes[] = {
+	&iio_dev_attr_in_magn_sensitivity_x.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_y.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_z.dev_attr.attr,
+	&iio_dev_attr_in_magn_scale.dev_attr.attr,
+	&iio_dev_attr_info_magn_matrix.dev_attr.attr,
+	&iio_dev_attr_in_magn_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_rate.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_tilt.attr,
+	&dev_attr_poll_pick_up.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_event_stationary_detect_enable.dev_attr.attr,
+	&iio_dev_attr_event_motion_detect_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+
+static const struct attribute *inv_ois_attributes[] = {
+	&dev_attr_misc_ois_self_test.attr,
+	&iio_dev_attr_in_ois_accel_fs.dev_attr.attr,
+	&iio_dev_attr_in_ois_gyro_fs.dev_attr.attr,
+	&iio_dev_attr_in_ois_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_ois_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_ois_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_ois_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_ois_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_ois_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_ois_st_calibbias.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+					ARRAY_SIZE(inv_debug_attributes) +
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+					ARRAY_SIZE(inv_compass_attributes) +
+					ARRAY_SIZE(inv_pedometer_attributes) +
+					ARRAY_SIZE(inv_ois_attributes) + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm20690"))
+		st->chip_type = ICM20690;
+	else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_ois_attributes,
+				sizeof(inv_ois_attributes));
+	t_ind += ARRAY_SIZE(inv_ois_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+	if (st->chip_config.has_compass) {
+		memcpy(&inv_attributes[t_ind],
+				inv_compass_attributes,
+				sizeof(inv_compass_attributes));
+		t_ind += ARRAY_SIZE(inv_compass_attributes);
+	}
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_iio_reg_20690.h b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_iio_reg_20690.h
new file mode 100644
index 000000000000..db2acf6c51a8
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_iio_reg_20690.h
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_20690_H_
+#define _INV_MPU_IIO_REG_20690_H_
+
+/*register and associated bit definition*/
+#define REG_SELF_TEST1			0x00
+#define REG_SELF_TEST2			0x01
+#define REG_SELF_TEST3			0x02
+
+#define REG_PRODUCT_ID			0xC
+
+#define REG_SELF_TEST4			0x0D
+#define REG_SELF_TEST5			0x0E
+#define REG_SELF_TEST6			0x0F
+
+#define REG_XG_OFFS_USR_H		0x13
+#define REG_YG_OFFS_USR_H		0x15
+#define REG_ZG_OFFS_USR_H		0x17
+
+#define REG_SAMPLE_RATE_DIV		0x19
+
+#define REG_CONFIG			0x1A
+#define BIT_FIFO_COUNT_REC		0x80
+#define EXT_SYNC_SET			8
+
+#define REG_GYRO_CONFIG			0x1B
+#define BITS_SELF_TEST_EN		0xE0
+#define SHIFT_GYRO_FS_SEL		0x02
+
+#define REG_ACCEL_CONFIG		0x1C
+#define SHIFT_ACCEL_FS			0x03
+
+#define REG_ACCEL_CONFIG_2		0x1D
+#define BIT_FIFO_SIZE_1K		0xC0
+#define BIT_ACCEL_FCHOCIE_B		0x08
+
+#define REG_LP_MODE_CTRL		0x1E
+#define BIT_GYRO_CYCLE_EN		0x80
+
+#define REG_ACCEL_WOM_THR		0x1F
+#define REG_ACCEL_WOM_X_THR		0x20
+#define REG_ACCEL_WOM_Y_THR		0x21
+#define REG_ACCEL_WOM_Z_THR		0x22
+
+#define REG_FIFO_EN			0x23
+#define BITS_TEMP_FIFO_EN		0x80
+#define BITS_GYRO_FIFO_EN		0x70
+#define BIT_ACCEL_FIFO_EN		0x08
+#define BIT_SLV_0_FIFO_EN		0x01
+
+#define REG_I2C_MST_CTRL		0x24
+#define BIT_WAIT_FOR_ES			0x40
+
+#define REG_I2C_SLV0_ADDR		0x25
+#define REG_I2C_SLV0_REG		0x26
+#define REG_I2C_SLV0_CTRL		0x27
+#define REG_I2C_SLV1_ADDR		0x28
+#define REG_I2C_SLV1_REG		0x29
+#define REG_I2C_SLV1_CTRL		0x2A
+#define REG_I2C_SLV2_ADDR		0x2B
+#define REG_I2C_SLV2_REG		0x2C
+#define REG_I2C_SLV2_CTRL		0x2D
+
+#define REG_ACCEL_XOUT_H_SH		0x3B
+
+#define REG_GYRO_XOUT_H_SH		0x43
+
+#define REG_AMA_CTRL_NEW_1		0x2E
+#define BIT_ODR_DELAY_TIME_EN		0x80
+
+#define REG_I2C_SLV4_CTRL		0x34
+
+#define REG_FSYNC_INT			0x36
+#define BIT_FSYNC_INT			0x80
+
+#define REG_INT_PIN_CFG			0x37
+
+#define REG_INT_ENABLE			0x38
+#define BIT_WOM_X_INT_EN		0x80
+#define BIT_WOM_Y_INT_EN		0x40
+#define BIT_WOM_Z_INT_EN		0x20
+#define BIT_WOM_ALL_INT_EN		0xE0
+#define BIT_FIFO_OFLOW_EN		0x10
+#define BIT_DATA_RDY_EN			0x01
+
+#define REG_DMP_INT_STATUS		0x39
+
+#define REG_INT_STATUS			0x3A
+#define BIT_WOM_INT			0xE0
+
+#define REG_RAW_ACCEL			0x3B
+
+#define REG_TEMP_OUT_H			0x41
+
+#define REG_EXT_SLV_SENS_DATA_00	0x49
+
+#define REG_ODR_DLY_CNT_HI		0x5F
+#define ODR_DLY_REG_COUNT		2
+
+#define REG_FIFO_WM_TH_HI		0x5E
+#define REG_FIFO_WM_TH			0x61
+
+#define REG_I2C_SLV0_DO			0x63
+#define REG_I2C_SLV1_DO			0x64
+#define REG_I2C_SLV2_DO			0x65
+
+#define REG_I2C_MST_DELAY_CTRL		0x67
+#define BIT_DELAY_ES_SHADOW		0x80
+#define BIT_I2C_SLV1_DELAY_EN		0x02
+#define BIT_I2C_SLV0_DELAY_EN		0x01
+
+#define REG_SIGNAL_PATH_RESET		0x68
+#define OIS_GYRO_FS_SHIFT		5
+#define OIS_FCHOICE_10			0x10
+
+#define REG_ACCEL_INTEL_CTRL		0x69
+#define BIT_ACCEL_INTEL_EN		0x80
+#define BIT_ACCEL_INTEL_MODE		0x40
+#define BIT_ACCEL_FCHOICE_OIS_B		0x30 /* 11: ODR 4kHz */
+
+#define REG_USER_CTRL			0x6A
+#define BIT_COND_RST			0x01
+#define BIT_FIFO_RST			0x04
+#define BIT_DMP_RST			0x08
+#define BIT_I2C_IF_DIS			0x10
+#define BIT_I2C_MST_EN			0x20
+#define BIT_FIFO_EN			0x40
+#define BIT_DMP_EN			0x80
+
+#define REG_PWR_MGMT_1			0x6B
+#define BIT_H_RESET			0x80
+#define BIT_SLEEP			0x40
+#define BIT_LP_EN			0x20
+#define BIT_CLK_PLL			0x01
+#define BIT_CLK_MASK			0x07
+
+#define REG_PWR_MGMT_2			0x6C
+#define BIT_PWR_ACCEL_STBY		0x38
+#define BIT_PWR_GYRO_STBY		0x07
+#define BIT_PWR_ALL_OFF			0x3F
+#define BIT_FIFO_LP_EN			0x80
+
+#define REG_MEM_BANK_SEL		0x6D
+#define REG_MEM_START_ADDR		0x6E
+#define REG_MEM_R_W			0x6F
+
+#define REG_USER_CTRL_NEW		0x70
+#define BIT_OIS_ENABLE			0x2
+
+#define REG_FIFO_COUNT_H		0x72
+#define REG_FIFO_R_W			0x74
+#define REG_WHO_AM_I			0x75
+
+#define REG_XA_OFFS_H			0x77
+#define REG_YA_OFFS_H			0x7A
+#define REG_ZA_OFFS_H			0x7D
+#define REG_XA_OFFS_L_TC		0x7
+
+/* self test definition */
+#define REG_6500_XG_ST_DATA		0x0
+#define REG_6500_XA_ST_DATA		0xD
+#define REG_6500_ACCEL_CONFIG2		0x1D
+
+#define INV_MPU_BIT_SLV_EN		0x80
+#define INV_MPU_BIT_BYTE_SW		0x40
+#define INV_MPU_BIT_REG_DIS		0x20
+#define INV_MPU_BIT_GRP			0x10
+#define INV_MPU_BIT_I2C_READ		0x80
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET		0x4000
+#define GYRO_ACCURACY_SET		0x2000
+#define CPASS_ACCURACY_SET		0x1000
+#define FSYNC_SET			0x0800
+#define FLIP_PICKUP_SET			0x0400
+#define BATCH_MODE_EN			0x0100
+#define ACT_RECOG_SET			0x0080
+#define SECOND_SEN_OFF_SET		0x0040
+
+#define INV_FSYNC_TEMP_BIT		0x1
+
+#define ACCEL_COVARIANCE		0
+
+/* dummy definitions */
+#define BANK_SEL_0			0x00
+#define BANK_SEL_1			0x10
+#define BANK_SEL_2			0x20
+#define BANK_SEL_3			0x30
+
+/* data definitions */
+#define BYTES_PER_SENSOR		6
+#define BYTES_FOR_TEMP			2
+#define BYTES_FOR_COMPASS		10
+#define FIFO_COUNT_BYTE			2
+#define INV_RAW_DATA_BYTES		6
+#define MAX_FIFO_PACKET_READ		6
+#define HARDWARE_FIFO_SIZE		1024
+#define FIFO_SIZE			(HARDWARE_FIFO_SIZE * 7 / 8)
+#define POWER_UP_TIME			100
+#define REG_UP_TIME_USEC		5000
+#define DMP_RESET_TIME			20
+#define GYRO_ENGINE_UP_TIME		50
+#define MPU_MEM_BANK_SIZE		256
+#define IIO_BUFFER_BYTES		8
+#define HEADERED_NORMAL_BYTES		8
+#define HEADERED_Q_BYTES		16
+#define LEFT_OVER_BYTES			128
+#define BASE_SAMPLE_RATE		1000
+#define DRY_RUN_TIME			50
+#define EIS_DIVIDER			1
+#define INV_ICM20690_GYRO_START_TIME	80
+#define INV_ICM20690_ACCEL_START_TIME	10
+#define MODE_1K_INIT_SAMPLE		5
+#define MODE_VR_INIT_SAMPLE		5
+#define FIRST_DROP_SAMPL_MS		40
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY		3
+#else
+#define DEFAULT_ACCURACY		1
+#endif
+
+enum inv_filter_e {
+	INV_FILTER_256HZ_NOLPF2 = 0,
+	INV_FILTER_188HZ,
+	INV_FILTER_98HZ,
+	INV_FILTER_42HZ,
+	INV_FILTER_20HZ,
+	INV_FILTER_10HZ,
+	INV_FILTER_5HZ,
+	INV_FILTER_2100HZ_NOLPF,
+	NUM_FILTER
+};
+
+enum inv_avg_filter_e {
+	BIT_AVG_FILTER_500HZ = 0x00,	// 1x
+	BIT_AVG_FILTER_200HZ = 0x20,	// 4x
+	BIT_AVG_FILTER_100HZ = 0x40,	// 16x
+	BIT_AVG_FILTER_50HZ = 0x50,	// 32x
+	BIT_AVG_FILTER_30HZ = 0x60	// 64x
+};
+
+#define MPU_DEFAULT_DMP_FREQ		200
+#define PEDOMETER_FREQ			(MPU_DEFAULT_DMP_FREQ >> 2)
+#define SENSOR_FUSION_MIN_RATE		100
+#define GESTURE_ACCEL_RATE		50
+#define ESI_GYRO_RATE			200
+#define MODE_VR_RATE			500
+
+#define MIN_MST_ODR_CONFIG		4
+#define MAX_MST_ODR_CONFIG		5
+#define MIN_COMPASS_RATE		4
+#define MAX_COMPASS_RATE		100
+#define MAX_MST_NON_COMPASS_ODR_CONFIG	7
+#define THREE_AXES			3
+#define NINE_ELEM			(THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT			16
+#define DMP_DIVIDER			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define MAX_5_BIT_VALUE			0x1F
+#define BAD_COMPASS_DATA		0x7FFF
+#define BAD_CAL_COMPASS_DATA		0x7FFF0000
+#define DEFAULT_BATCH_RATE		400
+#define DEFAULT_BATCH_TIME		(MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+#define NINEQ_DEFAULT_COMPASS_RATE	25
+
+#define DATA_AKM_99_BYTES_DMP		10
+#define DATA_AKM_89_BYTES_DMP		9
+#define DATA_ALS_BYTES_DMP		8
+#define TEMPERATURE_SCALE		3340827L
+#define TEMPERATURE_OFFSET		1376256L
+#define SECONDARY_INIT_WAIT		100
+#define AK99XX_SHIFT			23
+#define AK89XX_SHIFT			22
+
+/* data limit definitions */
+#define MIN_FIFO_RATE			4
+#define MAX_FIFO_RATE			MPU_DEFAULT_DMP_FREQ
+#define MAX_DMP_OUTPUT_RATE		MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM			8192
+#define MAX_PRS_RATE			281
+/* initial rate is important. For non-DMP mode, it is set as 4 1000/256*/
+#define MPU_INIT_SENSOR_RATE		4
+
+/* temperature */
+#define TEMP_SENSITIVITY		32680	// 326.8 LSB/degC * 100
+#define TEMP_OFFSET			2500	// 25 degC * 100
+
+/* enum for sensor
+   The sequence is important.
+   It represents the order of apperance from DMP */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+#endif
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_init_20690.c b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_init_20690.c
new file mode 100644
index 000000000000..e6e622ceccae
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_init_20690.c
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+
+	inv_plat_single_write(st, REG_CONFIG, 3);
+
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_vr = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_vr = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_vr = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(0);
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	/* set gyro fsr and FCHOICE_B = 00 */
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+				st->chip_config.fsr << SHIFT_GYRO_FS_SEL);
+	if (result)
+		return result;
+
+	/* set ois gyro fsr */
+	result = inv_plat_single_write(st, REG_SIGNAL_PATH_RESET,
+				st->ois.gyro_fs << OIS_GYRO_FS_SHIFT |
+				OIS_FCHOICE_10);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+				st->chip_config.accel_fs << SHIFT_ACCEL_FS |
+				st->ois.accel_fs);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	int result = 0;
+	u8 w;
+
+#define ACCEL_WOM_THR		7
+
+	w = ACCEL_WOM_THR;
+	result = inv_plat_single_write(st, REG_ACCEL_WOM_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_X_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Y_THR, w);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Z_THR, w);
+
+	return result;
+}
+
+static int inv_init_secondary(struct inv_mpu_state *st)
+{
+	st->slv_reg[0].addr = REG_I2C_SLV0_ADDR;
+	st->slv_reg[0].reg = REG_I2C_SLV0_REG;
+	st->slv_reg[0].ctrl = REG_I2C_SLV0_CTRL;
+	st->slv_reg[0].d0 = REG_I2C_SLV0_DO;
+
+	st->slv_reg[1].addr = REG_I2C_SLV1_ADDR;
+	st->slv_reg[1].reg = REG_I2C_SLV1_REG;
+	st->slv_reg[1].ctrl = REG_I2C_SLV1_CTRL;
+	st->slv_reg[1].d0 = REG_I2C_SLV1_DO;
+
+	st->slv_reg[2].addr = REG_I2C_SLV2_ADDR;
+	st->slv_reg[2].reg = REG_I2C_SLV2_REG;
+	st->slv_reg[2].ctrl = REG_I2C_SLV2_CTRL;
+	st->slv_reg[2].d0 = REG_I2C_SLV2_DO;
+
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_COMPASS].sample_size = BYTES_FOR_COMPASS;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+	st->sensor[SENSOR_COMPASS].c_en = true;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_NINEQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_MAG_CAL].base = SENSOR_COMPASS;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG_WAKE].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].base = SENSOR_COMPASS;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+	st->sensor_l[SENSOR_L_MAG].header = COMPASS_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL].header = COMPASS_CALIB_HDR;
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE].header = PRESSURE_HDR;
+	st->sensor_l[SENSOR_L_ALS].header = ALS_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG].header = GEOMAG_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].header = PRESSURE_WAKE_HDR;
+	st->sensor_l[SENSOR_L_ALS_WAKE].header = ALS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].header = GEOMAG_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PRESSURE].wake_on = false;
+	st->sensor_l[SENSOR_L_ALS].wake_on = false;
+	st->sensor_l[SENSOR_L_GEOMAG].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_ALS_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_USEC;
+	st->firmware = 0;
+	st->ts_algo.gyro_ts_shift = 1500 * NSEC_PER_USEC;
+	st->fifo_count_mode = RECORD_MODE;
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	inv_init_secondary(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+static int inv_compass_dmp_cal(struct inv_mpu_state *st)
+{
+	s8 compass_m[NINE_ELEM], m[NINE_ELEM];
+	s8 trans[NINE_ELEM];
+	s32 tmp_m[NINE_ELEM];
+	int i, j, k;
+	int sens[THREE_AXES];
+	int *adj;
+	int scale, shift;
+
+	for (i = 0; i < NINE_ELEM; i++) {
+		compass_m[i] = 0;
+		m[i] = 0;
+		trans[i] = 0;
+	}
+	compass_m[0] = 1;
+	m[0] = 1;
+	trans[0] = 1;
+
+	compass_m[4] = 1;
+	m[4] = 1;
+	trans[4] = 1;
+
+	compass_m[8] = 1;
+	m[8] = 1;
+	trans[8] = 1;
+
+	adj = st->current_compass_matrix;
+	st->slave_compass->get_scale(st, &scale);
+	/* scale = (1 << 30); */
+
+	if ((COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09915 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09916 == st->plat_data.sec_slave_id))
+		shift = AK89XX_SHIFT;
+	else
+		shift = AK99XX_SHIFT;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		sens[i] = st->chip_info.compass_sens[i] + 128;
+		sens[i] = inv_q30_mult(sens[i] << shift, scale);
+	}
+
+	for (i = 0; i < NINE_ELEM; i++) {
+		adj[i] = compass_m[i] * sens[i % THREE_AXES];
+		tmp_m[i] = 0;
+	}
+	for (i = 0; i < THREE_AXES; i++)
+		for (j = 0; j < THREE_AXES; j++)
+			for (k = 0; k < THREE_AXES; k++)
+				tmp_m[THREE_AXES * i + j] +=
+					trans[THREE_AXES * i + k] *
+					adj[THREE_AXES * k + j];
+
+	for (i = 0; i < NINE_ELEM; i++)
+		st->final_compass_matrix[i] = adj[i];
+
+	return 0;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	// hotfix - ois stall issue
+	msleep(10);
+
+	// hotfix - accel offset shift issue
+	result = inv_plat_single_write(st, 0x76, 0x20);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1, &v);
+	if (result)
+		return result;
+	v &= 0x7F;
+	result = inv_plat_single_write(st, REG_CONFIG, v);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, 0x76, 0x00);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+
+	result = inv_read_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	if (SECONDARY_SLAVE_TYPE_COMPASS == plat->sec_slave_type)
+		st->chip_config.has_compass = 1;
+	else
+		st->chip_config.has_compass = 0;
+
+	if (st->chip_config.has_compass) {
+		result = inv_mpu_setup_compass_slave(st);
+		if (result)
+			pr_err("compass setup failed\n");
+		inv_compass_dmp_cal(st);
+	}
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_parsing_20690.c b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_parsing_20690.c
new file mode 100644
index 000000000000..e3963a4d1b3c
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_parsing_20690.c
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_icm20690_set_lp_dis(struct inv_mpu_state *st, bool on)
+{
+	u8 v;
+	int res;
+
+	if (!st->cycle_on)
+		return 0;
+
+	v = 0;
+	if (st->chip_config.gyro_enable || st->chip_config.accel_enable) {
+		if (!st->chip_config.gyro_enable)
+			v |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			v |= BIT_PWR_ACCEL_STBY;
+	} else if (st->chip_config.compass_enable)
+		v |= BIT_PWR_GYRO_STBY;
+	else
+		v |= BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY;
+
+	if (on)
+		v |= BIT_FIFO_LP_EN;
+
+	res = inv_plat_single_write(st, REG_PWR_MGMT_2, v);
+	usleep_range(100, 120); /* give time to settle */
+
+	return res;
+}
+
+static int inv_apply_soft_iron(struct inv_mpu_state *st, s16 *out_1, s32 *out_2)
+{
+	int *r, i, j;
+	s64 tmp;
+
+	r = st->final_compass_matrix;
+	for (i = 0; i < THREE_AXES; i++) {
+		tmp = 0;
+		for (j = 0; j < THREE_AXES; j++)
+			tmp  +=
+			(s64)r[i * THREE_AXES + j] * (((int)out_1[j]) << 16);
+		out_2[i] = (int)(tmp >> 30);
+	}
+
+	return 0;
+}
+
+int inv_check_fsync(struct inv_mpu_state *st, u8 fsync_status)
+{
+	u8 data[2];
+	u16 fsync_counter;
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+
+	if ((fsync_status & INV_FSYNC_TEMP_BIT) && (st->eis.prev_state == 0)) {
+		inv_plat_read(st, REG_ODR_DLY_CNT_HI, ODR_DLY_REG_COUNT, data);
+
+		fsync_counter = data[0];
+		fsync_counter <<= 8;
+		fsync_counter += data[1];
+
+		pr_debug("fsync= %d\n", fsync_counter);
+		st->eis.eis_triggered = true;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+		inv_process_eis(st, fsync_counter);
+	} else if (fsync_status & INV_FSYNC_TEMP_BIT) {
+		st->eis.prev_state = 1;
+	} else {
+		st->eis.prev_state = 0;
+	}
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res, i;
+	s16 out_1[3];
+	s32 out_2[3];
+	s32 raw[3];
+	s32 calib[3] = { 0, 0, 0 };
+
+	res = 0;
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		st->eis.gyro_counter++;
+		inv_check_fsync(st, d[1]);
+		break;
+	case SENSOR_GYRO:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_gyro_data(indio_dev, raw, calib, t);
+		break;
+	case SENSOR_COMPASS:
+		if (st->mag_first_drop_cnt > 0) {
+			st->mag_first_drop_cnt--;
+			return 0;
+		}
+		if (d[0] != 1) {
+			pr_debug("Bad compass data= %x\n", d[0]);
+			return -EINVAL;
+		}
+		for (i = 0; i < 3; i++)
+			out_1[i] = be16_to_cpup((__be16 *) (d + i * 2 + 2));
+		inv_apply_soft_iron(st, out_1, out_2);
+		inv_push_16bytes_buffer(indio_dev, ind, t, out_2, 0);
+		break;
+	default:
+		break;
+	}
+
+	return res;
+}
+
+static int inv_push_20690_data(struct iio_dev *indio_dev, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 *dptr;
+	int i;
+
+	dptr = d;
+	st->eis.eis_frame = false;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			inv_get_dmp_ts(st, i);
+			if (st->sensor[i].send && (!st->ts_algo.first_sample)) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(indio_dev, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_process_20690_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 data[2];
+	bool done_flag;
+	u8 v;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		res = inv_plat_read(st, REG_INT_STATUS, 1, data);
+		if (res)
+			return res;
+		pr_debug("ges cnt=%d, statu=%x\n",
+						st->gesture_int_count, data[0]);
+		if (data[0] & (BIT_WOM_ALL_INT_EN)) {
+			if (!st->gesture_int_count) {
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN | BIT_DATA_RDY_EN);
+				if (res)
+					return res;
+				v = 0;
+				if (st->chip_config.gyro_enable)
+					v |= BITS_GYRO_FIFO_EN;
+
+				if (st->chip_config.accel_enable)
+					v |= BIT_ACCEL_FIFO_EN;
+				res = inv_plat_single_write(st, REG_FIFO_EN, v);
+				if (res)
+					return res;
+				/* First time wake up from WOM.
+					We don't need data in the FIFO */
+				res = inv_reset_fifo(st, true);
+				if (st->chip_config.stationary_detect_enable)
+					st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+				else
+					st->gesture_int_count = WOM_DELAY_THRESHOLD;
+
+				return res;
+			}
+			if (st->chip_config.stationary_detect_enable)
+				st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+			else
+				st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		} else {
+			if (!st->gesture_int_count) {
+				res = inv_plat_single_write(st, REG_FIFO_EN, 0);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN);
+				if (res)
+					return res;
+				return 0;
+			}
+			st->gesture_int_count--;
+		}
+	}
+
+	if (st->batch.timeout || st->chip_config.eis_enable) {
+		res = inv_plat_read(st, REG_DMP_INT_STATUS, 1, data);
+		if (res)
+			return res;
+	}
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("fifo_count is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE / st->batch.pk_size)) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n", fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+	dptr = d;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n", d[0], d[1], d[2],
+						d[3], d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n", d[8], d[9], d[10],
+					d[11], d[12], d[13], d[14], d[15]);
+	total_bytes = fifo_count;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->sensor[i].count =  total_bytes / pk_size;
+	}
+
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		if (total_bytes >= pk_size) {
+			res = inv_push_20690_data(indio_dev, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+
+	inv_icm20690_set_lp_dis(st, true);
+	st->wake_sensor_received = false;
+	result = inv_process_20690_data(indio_dev);
+	if (result)
+		goto err_reset_fifo;
+	inv_icm20690_set_lp_dis(st, false);
+
+	mutex_unlock(&st->lock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_set_power(st, false);
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	inv_icm20690_set_lp_dis(st, false);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		inv_icm20690_set_lp_dis(st, true);
+		st->wake_sensor_received = false;
+		inv_process_20690_data(indio_dev);
+		inv_icm20690_set_lp_dis(st, false);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_selftest_20690.c b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_selftest_20690.c
new file mode 100644
index 000000000000..70a77fc67ac0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_selftest_20690.c
@@ -0,0 +1,762 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* register settings */
+#define DEF_SELFTEST_GYRO_SENS		(32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS			20
+#define SELFTEST_WAIT_TIME		(MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME		20
+#define DEF_GYRO_SCALE			131
+#define DEF_ST_PRECISION		1000
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ST_SCALE			32768
+#define DEF_ST_TRY_TIMES		2
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define DEF_ST_COMPASS_RESULT_SHIFT	2
+#define DEF_ST_SAMPLES			200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN	500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX	1500
+#define DEF_GYRO_CT_SHIFT_DELTA		500
+
+#define SENSOR_UP_TIME			30
+#define REG_UP_TIME			2
+
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ACCEL_ST_SHIFT_DELTA	500
+#define ACCEL_ST_AL_MIN			((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+					/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX			((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+					/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+#define THREE_AXIS			3
+#define DEF_ST_MPU6500_ACCEL_LPF	2
+#define DEF_SELFTEST_SAMPLE_RATE	0 /* 1000Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_LP	4 /*  200Hz */
+#define INV_MPU_SAMPLE_RATE_CHANGE_STABLE	50
+#define DEF_SELFTEST_6500_ACCEL_FS	(0 << 3)
+#define DEF_SELFTEST_GYRO_FS		(0 << 3)
+#define DEF_ST_6500_STABLE_TIME		20
+#define BIT_ACCEL_OUT			0x08
+#define BITS_GYRO_OUT			0x70
+#define THREE_AXIS			3
+#define DEF_GYRO_WAIT_TIME		60
+#define DEF_GYRO_WAIT_TIME_LP		300
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX		20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL			60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN		225
+#define DEF_ACCEL_ST_AL_MAX		675
+
+struct recover_regs {
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 config;		/* REG_CONFIG */
+	u8 gyro_config;		/* REG_GYRO_CONFIG */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+	u8 smplrt_div;		/* REG_SAMPLE_RATE_DIV */
+	u8 lp_mode;		/* REG_LP_MODE_CTRL */
+	u8 pwr_mgmt_1;		/* REG_PWR_MGMT_1 */
+	u8 pwr_mgmt_2;		/* REG_PWR_MGMT_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_INT_ENABLE      : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_FIFO_EN         : 0x%02X\n", saved_regs.fifo_en);
+	pr_debug(" REG_USER_CTRL       : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_CONFIG          : 0x%02X\n", saved_regs.config);
+	pr_debug(" REG_GYRO_CONFIG     : 0x%02X\n", saved_regs.gyro_config);
+	pr_debug(" REG_ACCEL_CONFIG    : 0x%02X\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2  : 0x%02X\n", saved_regs.accel_config_2);
+	pr_debug(" REG_SAMPLE_RATE_DIV : 0x%02X\n", saved_regs.smplrt_div);
+	pr_debug(" REG_LP_MODE_CTRL    : 0x%02X\n", saved_regs.lp_mode);
+	pr_debug(" REG_PWR_MGMT_1      : 0x%02X\n", saved_regs.pwr_mgmt_1);
+	pr_debug(" REG_PWR_MGMT_2      : 0x%02X\n", saved_regs.pwr_mgmt_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_read(st, REG_PWR_MGMT_1, 1,
+			&saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	/* wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+
+	result = inv_plat_read(st, REG_INT_ENABLE, 1,
+			&saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1,
+			&saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1,
+			&saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1,
+			&saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG, 1,
+			&saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SAMPLE_RATE_DIV, 1,
+			&saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_MODE_CTRL, 1,
+			&saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1,
+			&saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN,
+			saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_CONFIG,
+			saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+			saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+			saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+			saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+	usleep_range(100, 120);
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_switch_engine(struct inv_mpu_state *st, bool en, u32 mask)
+{
+	u8 data, mgmt_1;
+	int result;
+
+	if (BIT_PWR_GYRO_STBY == mask) {
+		result = inv_plat_read(st, REG_PWR_MGMT_1, 1, &mgmt_1);
+		if (result)
+			return result;
+		mgmt_1 &= ~BIT_CLK_MASK;
+	}
+
+	if ((BIT_PWR_GYRO_STBY == mask) && (!en)) {
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+		usleep_range(100, 120);
+	}
+
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1, &data);
+	if (result)
+		return result;
+	if (en)
+		data &= (~mask);
+	else
+		data |= mask;
+	data |= BIT_FIFO_LP_EN;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2, data);
+	if (result)
+		return result;
+	usleep_range(100, 120);
+
+	if ((BIT_PWR_GYRO_STBY == mask) && en) {
+		/* only gyro on needs sensor up time */
+		msleep(SENSOR_UP_TIME);
+		/* after gyro is on & stable, switch internal clock to PLL */
+		mgmt_1 |= BIT_CLK_PLL;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+	if ((BIT_PWR_ACCEL_STBY == mask) && en)
+		msleep(REG_UP_TIME);
+
+	return 0;
+}
+
+int inv_set_offset_reg(struct inv_mpu_state *st, int reg, int val)
+{
+	int result;
+	u8 d;
+
+	d = ((val >> 8) & 0xff);
+	result = inv_plat_single_write(st, reg, d);
+	if (result)
+		return result;
+
+	d = (val & 0xff);
+	result = inv_plat_single_write(st, reg + 1, d);
+
+	return result;
+}
+
+/**
+* inv_check_gyro_self_test() - check gyro self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_gyro_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	u8 regs[3];
+	int ret_val, result;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XG_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test gyro shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA
+						* st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			/* Self Test Pass/Fail Criteria B */
+			if (st_shift_cust[i] < DEF_GYRO_ST_AL *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	if (ret_val == 0) {
+		/* Self Test Pass/Fail Criteria C */
+		for (i = 0; i < 3; i++)
+			if (abs(reg_avg[i]) > DEF_GYRO_OFFSET_MAX *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/**
+* inv_check_accel_self_test() - check 6500 accel self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+int inv_check_accel_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	int ret_val, result;
+	int st_shift_prod[3], st_shift_cust[3], st_shift_ratio[3], i;
+	u8 regs[3];
+	int otp_value_zero = 0;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_6500_XA_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test accel shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			st_shift_ratio[i] = abs(st_shift_cust[i] /
+					st_shift_prod[i] - DEF_ST_PRECISION);
+			if (st_shift_ratio[i] > DEF_ACCEL_ST_SHIFT_DELTA)
+				ret_val = 1;
+		}
+	} else {
+		/* Self Test Pass/Fail Criteria B */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = abs(st_avg[i] - reg_avg[i]);
+			if (st_shift_cust[i] < ACCEL_ST_AL_MIN ||
+					st_shift_cust[i] > ACCEL_ST_AL_MAX)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+int inv_do_test(struct inv_mpu_state *st, int self_test_flag,
+		int *gyro_result, int *accel_result, int lp_mode)
+{
+	int result, i, j, packet_size;
+	u8 data[BYTES_PER_SENSOR * 2], d, dd;
+	int fifo_count, packet_count, ind, s;
+
+	packet_size = BYTES_PER_SENSOR * 2;
+	/* clear signal path */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 1);
+	if (result)
+		return result;
+	msleep(30);
+
+	/* disable interrupt */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+	/* disable the sensor output to FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (result)
+		return result;
+	/* disable fifo reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+	if (result)
+		return result;
+	/* clear FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (result)
+		return result;
+	/* setup parameters */
+	result = inv_plat_single_write(st, REG_CONFIG, INV_FILTER_98HZ);
+	if (result)
+		return result;
+
+	/* gyro lp mode */
+	if (lp_mode == 1)
+		d  = BIT_GYRO_CYCLE_EN;
+	else
+		d = 0;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, d);
+	if (result)
+		return result;
+
+	/* config accel LPF register for MPU6500 */
+	d = BIT_FIFO_SIZE_1K;
+	if (lp_mode == 2)
+		d |= BIT_ACCEL_FCHOCIE_B;
+	else
+		d |= DEF_ST_MPU6500_ACCEL_LPF;
+	result = inv_plat_single_write(st, REG_6500_ACCEL_CONFIG2, d);
+	if (result)
+		return result;
+
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE_LP);
+	} else {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE);
+	}
+	if (result)
+		return result;
+	/* wait for the sampling rate change to stabilize */
+	mdelay(INV_MPU_SAMPLE_RATE_CHANGE_STABLE);
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+		self_test_flag | DEF_SELFTEST_GYRO_FS);
+	if (result)
+		return result;
+
+	d = DEF_SELFTEST_6500_ACCEL_FS;
+	d |= self_test_flag;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, d);
+	if (result)
+		return result;
+
+	/* wait for the output to get stable */
+	msleep(DEF_ST_6500_STABLE_TIME);
+
+	/* enable FIFO reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+	if (result)
+		return result;
+	/* enable sensor output to FIFO */
+	d = BITS_GYRO_OUT | BIT_ACCEL_OUT;
+	for (i = 0; i < THREE_AXIS; i++) {
+		gyro_result[i] = 0;
+		accel_result[i] = 0;
+	}
+	s = 0;
+	while (s < 200 /*st->self_test.samples*/) {
+		/* clear FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+		if (result)
+			return result;
+		/* enable FIFO reading */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+		if (result)
+			return result;
+
+		/* accel lp mode */
+		dd = BIT_CLK_PLL;
+		if (lp_mode == 2)
+			dd |= BIT_LP_EN;
+		else
+			dd &= ~BIT_LP_EN;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, dd);
+		if (result)
+			return result;
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, d);
+		if (result)
+			return result;
+		if (lp_mode)
+			mdelay(DEF_GYRO_WAIT_TIME_LP);
+		else
+			mdelay(DEF_GYRO_WAIT_TIME);
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+		if (result)
+			return result;
+
+		result = inv_plat_read(st, REG_FIFO_COUNT_H,
+					FIFO_COUNT_BYTE, data);
+		if (result)
+			return result;
+		fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+		pr_debug("%s self_test fifo_count - %d\n",
+			 st->hw->name, fifo_count);
+		packet_count = fifo_count / packet_size;
+		i = 0;
+		while ((i < packet_count) && (s < 200 /*st->self_test.samples*/)) {
+			short vals[3];
+
+			result = inv_plat_read(st, REG_FIFO_R_W,
+				packet_size, data);
+			if (result)
+				return result;
+			ind = 0;
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				accel_result[j] += vals[j];
+			}
+			ind += BYTES_PER_SENSOR;
+			pr_debug(
+				"%s self_test accel data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				gyro_result[j] += vals[j];
+			}
+			pr_debug("%s self_test gyro data - %d %+d %+d %+d",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			s++;
+			i++;
+		}
+	}
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXIS; j++) {
+		accel_result[j] = accel_result[j] / s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+	for (j = 0; j < THREE_AXIS; j++) {
+		gyro_result[j] = gyro_result[j] / s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	return 0;
+}
+
+
+int inv_power_up_self_test(struct inv_mpu_state *st)
+{
+	int result;
+
+	/* make sure no interrupts */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_ACCEL_STBY);
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXIS], gyro_bias_regular[THREE_AXIS];
+	int accel_bias_st[THREE_AXIS], accel_bias_regular[THREE_AXIS];
+	int gyro_bias_regular_lp[THREE_AXIS];
+	int accel_bias_regular_lp[THREE_AXIS];
+	int test_times, i;
+	char accel_result, gyro_result, compass_result;
+
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	result = inv_power_up_self_test(st);
+	if (result)
+		return result;
+	accel_result = 0;
+	gyro_result = 0;
+	compass_result = 0;
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular,
+			accel_bias_regular, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("%s self_test gyro bias_regular - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular[0], gyro_bias_regular[1],
+		gyro_bias_regular[2]);
+
+	for (i = 0; i < 3; i++) {
+		st->gyro_ois_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+		st->accel_ois_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, BITS_SELF_TEST_EN, gyro_bias_st,
+					accel_bias_st, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_st - %+d %+d %+d\n",
+		st->hw->name, accel_bias_st[0], accel_bias_st[1],
+		accel_bias_st[2]);
+	pr_debug("%s self_test gyro bias_st - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_st[0], gyro_bias_st[1],
+		gyro_bias_st[2]);
+
+
+	/* lp gyro mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			accel_bias_regular_lp, 1);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test gyro bias_regular lp - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular_lp[0], gyro_bias_regular_lp[1],
+		gyro_bias_regular_lp[2]);
+
+	for (i = 0; i < 3; i++)
+		st->gyro_st_bias[i] = gyro_bias_regular_lp[i] / DEF_ST_PRECISION;
+
+	/* lp accel mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			accel_bias_regular_lp, 2);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular lp - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular_lp[0],
+		accel_bias_regular_lp[1], accel_bias_regular_lp[2]);
+
+	for (i = 0; i < 3; i++)
+		st->accel_st_bias[i] = accel_bias_regular_lp[i] / DEF_ST_PRECISION;
+
+	/* Check is done on continuous mode data */
+	accel_result = !inv_check_accel_self_test(st,
+		accel_bias_regular, accel_bias_st);
+	gyro_result = !inv_check_gyro_self_test(st,
+		gyro_bias_regular, gyro_bias_st);
+	if (st->chip_config.has_compass)
+		compass_result = !st->slave_compass->self_test(st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (compass_result << DEF_ST_COMPASS_RESULT_SHIFT) |
+		(accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_setup_20690.c b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_setup_20690.c
new file mode 100644
index 000000000000..710f65361124
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_mpu_setup_20690.c
@@ -0,0 +1,794 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_engine_dur(struct inv_mpu_state *st,
+				struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	if (st->mode_1k_on)
+		ei->dur = ei->base_time_1k / ei->orig_rate;
+	else if (st->mode_vr_on)
+		ei->dur = ei->base_time_vr / ei->orig_rate;
+	else
+		ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_setup_eis(struct inv_mpu_state *st)
+{
+	int res;
+
+	if (st->chip_config.eis_enable)
+		res = inv_plat_single_write(st, REG_AMA_CTRL_NEW_1,
+							BIT_ODR_DELAY_TIME_EN);
+	else
+		res = inv_plat_single_write(st, REG_AMA_CTRL_NEW_1, 0);
+
+	return res;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 int_en, fifo_en, mode, user;
+	int r;
+	char data;
+	int div, sampling_rate;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST | st->i2c_dis);
+	if (r)
+		return r;
+	//dummy fifo reg read
+	inv_plat_read(st, REG_FIFO_R_W, 1, &data);
+	fifo_en = 0;
+	int_en = 0;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		if (st->chip_config.stationary_detect_enable)
+			st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+		else
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		int_en |= BIT_WOM_ALL_INT_EN;
+	}
+	if (st->batch.timeout) {
+		if (!st->batch.fifo_wm_th)
+			int_en = BIT_DATA_RDY_EN;
+	} else {
+		int_en = BIT_DATA_RDY_EN;
+	}
+	if (st->sensor[SENSOR_GYRO].on)
+		fifo_en |= BITS_GYRO_FIFO_EN;
+
+	if (st->sensor[SENSOR_ACCEL].on)
+		fifo_en |= BIT_ACCEL_FIFO_EN;
+	if (st->sensor[SENSOR_TEMP].on)
+		fifo_en |= BITS_TEMP_FIFO_EN;
+	if (st->sensor[SENSOR_COMPASS].on)
+		fifo_en |= BIT_SLV_0_FIFO_EN;
+	r = inv_plat_single_write(st, REG_FIFO_EN, fifo_en);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, int_en);
+	if (r)
+		return r;
+	if (st->gesture_only_on && (!st->batch.timeout))
+		mode = BIT_ACCEL_INTEL_EN | BIT_ACCEL_INTEL_MODE;
+	else
+		mode = 0;
+	mode |= BIT_ACCEL_FCHOICE_OIS_B;
+	r = inv_plat_single_write(st, REG_ACCEL_INTEL_CTRL, mode);
+	if ((st->eng_info[ENGINE_GYRO].running_rate > MAX_COMPASS_RATE) &&
+				st->chip_config.compass_enable) {
+		if (st->mode_1k_on) {
+			div = 0;
+		} else if (st->mode_vr_on) {
+			div = 1;
+		} else {
+			if (st->chip_config.gyro_enable)
+				div = st->eng_info[ENGINE_GYRO].divider - 1;
+			else
+				div = st->eng_info[ENGINE_ACCEL].divider - 1;
+			if (st->chip_config.eis_enable)
+				div = EIS_DIVIDER - 1;
+		}
+		sampling_rate = BASE_SAMPLE_RATE/(1+div);
+		st->mag_divider = sampling_rate/MAX_COMPASS_RATE - 1;
+		r = inv_plat_single_write(st, REG_I2C_SLV4_CTRL,
+						st->mag_divider);
+		if (r)
+			return r;
+		r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+						BIT_DELAY_ES_SHADOW |
+						BIT_I2C_SLV1_DELAY_EN |
+						BIT_I2C_SLV0_DELAY_EN);
+	} else {
+		r = inv_plat_single_write(st, REG_I2C_SLV4_CTRL, 0);
+		if (r)
+			return r;
+		r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+						BIT_DELAY_ES_SHADOW);
+	}
+	if (r)
+		return r;
+
+	/* make data ready interrupt happens after aux i2c access */
+	if (st->chip_config.compass_enable && st->mag_divider == 0)
+		r = inv_plat_single_write(st, REG_I2C_MST_CTRL, BIT_WAIT_FOR_ES);
+	else
+		r = inv_plat_single_write(st, REG_I2C_MST_CTRL, 0);
+	if (r)
+		return r;
+
+	/* The number of mag samples to be dropped
+	 * in addtion to ts_algo->first_sample
+	 */
+	st->mag_first_drop_cnt = st->mag_divider;
+
+	user = BIT_FIFO_EN;
+	if (st->sensor[SENSOR_COMPASS].on)
+		user |= BIT_I2C_MST_EN;
+	r = inv_plat_single_write(st, REG_USER_CTRL, user | st->i2c_dis);
+
+	inv_setup_eis(st);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int res;
+	unsigned int wait_ms;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	w = 0;
+	if (st->chip_config.gyro_enable | st->chip_config.accel_enable) {
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else if (st->chip_config.compass_enable) {
+		w |= BIT_PWR_GYRO_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY);
+	}
+
+	res = inv_plat_read(st, REG_PWR_MGMT_2, 1, &v);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	pr_debug("turn on engine REG %X\n", w);
+	if (res)
+		return res;
+
+	wait_ms = 0;
+	if (st->chip_config.gyro_enable && (v & BIT_PWR_GYRO_STBY)) {
+		/* enabling gyro */
+		wait_ms = INV_ICM20690_GYRO_START_TIME;
+	}
+	if (st->chip_config.accel_enable && (v & BIT_PWR_ACCEL_STBY)) {
+		/* enabling accel */
+		if (INV_ICM20690_ACCEL_START_TIME > wait_ms)
+			wait_ms = INV_ICM20690_ACCEL_START_TIME;
+	}
+
+	/* nb of first drop samples */
+	if (wait_ms < FIRST_DROP_SAMPL_MS)
+		wait_ms = FIRST_DROP_SAMPL_MS;
+
+	/* assume st->smplrt_div is set before coming here */
+	ts_algo->first_sample = wait_ms / (st->smplrt_div + 1);
+	if (ts_algo->first_sample == 0)
+		ts_algo->first_sample = 1;
+	if (st->mode_1k_on) {
+		if (ts_algo->first_sample < MODE_1K_INIT_SAMPLE)
+			ts_algo->first_sample = MODE_1K_INIT_SAMPLE;
+	}
+	if (st->mode_vr_on) {
+		if (ts_algo->first_sample < MODE_VR_INIT_SAMPLE)
+			ts_algo->first_sample = MODE_VR_INIT_SAMPLE;
+	}
+	pr_debug("first_sample= %d\n", ts_algo->first_sample);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			res = st->slave_compass->resume(st);
+		else
+			res = st->slave_compass->suspend(st);
+		if (res)
+			return res;
+	}
+	return res;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->ts_algo.clock_base].dur;
+			st->sensor[i].div = 1;
+			pr_debug("dur=%d, i=%d\n", st->sensor[i].dur, i);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf_gyro_cycle_avgcfg() - set gyro cycle mode and
+ * set avg filter config based on rate.
+ */
+static int inv_set_lpf_gyro_cycle_avgfltr(struct inv_mpu_state *st, int rate)
+{
+	const short odr[] = {30, 50, 100, 200, 500};
+	const int fltrconfig[] = {
+		BIT_AVG_FILTER_30HZ,
+		BIT_AVG_FILTER_50HZ,
+		BIT_AVG_FILTER_100HZ,
+		BIT_AVG_FILTER_200HZ,
+		BIT_AVG_FILTER_500HZ
+	};
+
+	int i, result, data;
+
+	i = 0;
+	while ((rate > odr[i]) && (i < ARRAY_SIZE(fltrconfig) - 1))
+		i++;
+	data = (BIT_GYRO_CYCLE_EN | fltrconfig[i]);
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, data);
+	return result;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st, int rate)
+{
+	const short hz[] = {188, 98, 42, 20, 10, 5};
+	const int   d[] = {INV_FILTER_188HZ, INV_FILTER_98HZ,
+			INV_FILTER_42HZ, INV_FILTER_20HZ,
+			INV_FILTER_10HZ, INV_FILTER_5HZ};
+	int i, h, data, result;
+
+	if (st->chip_config.eis_enable || st->ois.en ||
+		st->mode_1k_on || st->mode_vr_on) {
+		h = (rate >> 1);
+		i = 0;
+		while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+			i++;
+		data = d[i];
+		data |= (EXT_SYNC_SET | BIT_FIFO_COUNT_REC);
+		result = inv_plat_single_write(st, REG_CONFIG, data);
+		if (result)
+			return result;
+
+		st->chip_config.lpf = data;
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL, 0);
+		st->gyro_lp_mode = 0;
+	} else {
+		result = inv_set_lpf_gyro_cycle_avgfltr(st, rate);
+		if (result)
+			return result;
+		data = (BIT_FIFO_COUNT_REC);
+		result = inv_plat_single_write(st, REG_CONFIG, data | 3);
+		st->gyro_lp_mode = 1;
+	}
+
+	return result;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result, div;
+
+	if (st->chip_config.gyro_enable)
+		div = g_d;
+	else
+		div = a_d;
+	if (st->chip_config.eis_enable)
+		div = EIS_DIVIDER - 1;
+
+	pr_debug("div= %d\n", div);
+	st->smplrt_div = div;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV, div);
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+	int res = 0;
+	u32 w;
+
+	if (st->batch.timeout) {
+		w = st->batch.timeout * st->eng_info[ENGINE_GYRO].running_rate
+					* st->batch.pk_size / 1000;
+		if (w > FIFO_SIZE)
+			w = FIFO_SIZE;
+	} else {
+		w = 0;
+	}
+	if (st->batch.pk_size)
+		w /= st->batch.pk_size;
+	st->batch.fifo_wm_th = w;
+	pr_debug("running= %d, pksize=%d, to=%d w=%d\n",
+		st->eng_info[ENGINE_GYRO].running_rate,
+		st->batch.pk_size, st->batch.timeout, w);
+	res = inv_plat_single_write(st, REG_FIFO_WM_TH, w & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_FIFO_WM_TH_HI, (w >> 8) & 0xff);
+
+	return res;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result, i;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st, st->eng_info[ENGINE_GYRO].running_rate);
+	// set ADLPF at this point not to change after accel is enabled
+	result = inv_set_accel_config2(st, false);
+	st->batch.pk_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->batch.pk_size +=  st->sensor[i].sample_size;
+	}
+
+	inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en, c_en;
+	int compass_rate, accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	c_en = false;
+	compass_rate = MPU_INIT_SENSOR_RATE;
+	gyro_rate = MPU_INIT_SENSOR_RATE;
+	accel_rate = MPU_INIT_SENSOR_RATE;
+	/* loop the streaming sensors to see which engine needs to be turned on
+		*/
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+			c_en |= st->sensor[i].c_en;
+			if (st->sensor[i].c_en)
+				compass_rate =
+				    max(compass_rate, st->sensor[i].rate);
+		}
+	}
+
+	/* force to enable accel and gyro in OIS mode */
+	if (st->ois.en) {
+		g_en = true;
+		a_en = true;
+	}
+
+	st->mag_divider = 0;
+	st->mag_first_drop_cnt = 0;
+
+	if (st->chip_config.eis_enable)
+		st->sensor[SENSOR_TEMP].on = true;
+	else
+		st->sensor[SENSOR_TEMP].on = false;
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	if (compass_rate > MAX_COMPASS_RATE)
+		compass_rate = MAX_COMPASS_RATE;
+	st->chip_config.compass_rate = compass_rate;
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	if (compass_rate < MIN_COMPASS_RATE)
+		compass_rate = MIN_COMPASS_RATE;
+	st->ts_algo.clock_base = ENGINE_ACCEL;
+	if (c_en && (!g_en) && (!a_en)) {
+		a_en = true;
+		accel_rate = compass_rate;
+	}
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		if (c_en) {
+			if (gyro_rate < compass_rate)
+				gyro_rate = max(gyro_rate, compass_rate);
+		}
+		accel_rate = gyro_rate;
+		compass_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		if (c_en) {
+			if (accel_rate < compass_rate)
+				accel_rate = max(accel_rate, compass_rate);
+		}
+		compass_rate = accel_rate;
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_TEMP].on = true;
+	} else if (c_en) {
+		gyro_rate = compass_rate;
+		accel_rate = compass_rate;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	st->eng_info[ENGINE_I2C].running_rate = compass_rate;
+	if ((gyro_rate > MPU_DEFAULT_DMP_FREQ) ||
+					(accel_rate > MPU_DEFAULT_DMP_FREQ)) {
+		if ((gyro_rate == MODE_VR_RATE) ||
+				(accel_rate == MODE_VR_RATE))
+			st->mode_vr_on = true;
+		else
+			st->mode_1k_on = true;
+	} else {
+		st->mode_1k_on = false;
+		st->mode_vr_on = false;
+	}
+
+	if (st->chip_config.eis_enable) {
+		st->eng_info[ENGINE_GYRO].divider = EIS_DIVIDER;
+		st->eng_info[ENGINE_ACCEL].divider = EIS_DIVIDER;
+		st->eng_info[ENGINE_I2C].divider = EIS_DIVIDER;
+	} else if (st->mode_1k_on) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		st->eng_info[ENGINE_I2C].divider = 1;
+		// need to update rate and div for 1khz mode
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on) {
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+						((BASE_SAMPLE_RATE /
+						st->eng_info[ENGINE_GYRO].divider) /
+						(st->sensor_l[i].rate));
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else if (st->mode_vr_on) {
+		st->eng_info[ENGINE_GYRO].divider = 2;
+		st->eng_info[ENGINE_ACCEL].divider = 2;
+		st->eng_info[ENGINE_I2C].divider = 2;
+		// need to update rate and div for VR mode
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on) {
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+						((BASE_SAMPLE_RATE /
+						st->eng_info[ENGINE_GYRO].divider) /
+						(st->sensor_l[i].rate));
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_GYRO].running_rate);
+		st->eng_info[ENGINE_ACCEL].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+			st->eng_info[ENGINE_ACCEL].running_rate);
+		st->eng_info[ENGINE_I2C].divider =
+			(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+				(MPU_DEFAULT_DMP_FREQ /
+					st->eng_info[ENGINE_I2C].running_rate);
+	}
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++)
+		st->sensor_l[i].counter = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts_adj = 0;
+
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d cen: %d grate: %d arate: %d\n",
+				g_en, a_en, c_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+	st->chip_config.compass_enable = c_en;
+
+	if (c_en)
+		st->chip_config.slave_enable = 1;
+	else
+		st->chip_config.slave_enable = 0;
+
+	st->cycle_on = (!st->eis.eis_triggered)
+				&& (!st->chip_config.gyro_enable)
+				&& (!st->chip_config.compass_enable)
+				&& (!st->ois.en)
+				&& (!st->mode_1k_on)
+				&& (!st->mode_vr_on);
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	u8 v;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	inv_stop_interrupt(st);
+	inv_determine_engine(st);
+
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+
+	/* ois mode */
+	v = 0;
+	if (st->ois.en)
+		v |= BIT_OIS_ENABLE;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL_NEW, v);
+	if (result)
+		return result;
+
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.compass_enable) && (!st->ois.en)) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_stop_interrupt(st);
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_restore_interrupt(st);
+}
+
+int inv_read_offset_regs(struct inv_mpu_state *st, s16 accel[3], s16 gyro[3])
+{
+	int res;
+	u8 data[2];
+
+	/* accel */
+	res = inv_plat_read(st, REG_XA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZA_OFFS_H, 2, data);
+	if (res)
+		return res;
+	accel[2] = (data[0] << 8) | data[1];
+
+	pr_info("read accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_plat_read(st, REG_XG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZG_OFFS_USR_H, 2, data);
+	if (res)
+		return res;
+	gyro[2] = (data[0] << 8) | data[1];
+
+	pr_info("read gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+	return 0;
+}
+
+int inv_write_offset_regs(struct inv_mpu_state *st, const s16 accel[3], const s16 gyro[3])
+{
+	int res;
+
+	/* accel */
+	res = inv_plat_single_write(st, REG_XA_OFFS_H,
+			(accel[0] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_XA_OFFS_H + 1,
+			accel[0] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H,
+			(accel[1] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H + 1,
+			accel[1] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H,
+			(accel[2] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H + 1,
+			accel[2] & 0xff);
+	if (res)
+		return res;
+
+	pr_info("write accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H,
+			(gyro[0] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H + 1,
+			gyro[0] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H,
+			(gyro[1] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H + 1,
+			gyro[1] & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H,
+			(gyro[2] >> 8) & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H + 1,
+			gyro[2] & 0xff);
+	if (res)
+		return res;
+
+	pr_info("write gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+	return 0;
+}
+
diff --git a/drivers/iio/imu/inv_mpu/icm20690/inv_slave_compass.c b/drivers/iio/imu/inv_mpu/icm20690/inv_slave_compass.c
new file mode 100644
index 000000000000..bdaeb7324453
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20690/inv_slave_compass.c
@@ -0,0 +1,654 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* AKM definitions */
+#define REG_AKM_ID			0x00
+#define REG_AKM_INFO			0x01
+#define REG_AKM_STATUS			0x02
+#define REG_AKM_MEASURE_DATA		0x03
+#define REG_AKM_MODE			0x0A
+#define REG_AKM_ST_CTRL			0x0C
+#define REG_AKM_SENSITIVITY		0x10
+#define REG_AKM8963_CNTL1		0x0A
+
+/* AK09911 register definition */
+#define REG_AK09911_DMP_READ		0x3
+#define REG_AK09911_STATUS1		0x10
+#define REG_AK09911_CNTL2		0x31
+#define REG_AK09911_SENSITIVITY		0x60
+#define REG_AK09911_MEASURE_DATA	0x11
+
+/* AK09912 register definition */
+#define REG_AK09912_DMP_READ		0x3
+#define REG_AK09912_STATUS1		0x10
+#define REG_AK09912_CNTL1		0x30
+#define REG_AK09912_CNTL2		0x31
+#define REG_AK09912_SENSITIVITY		0x60
+#define REG_AK09912_MEASURE_DATA	0x11
+
+/* AK09915 register definition */
+#define REG_AK09915_DMP_READ		0x3
+#define REG_AK09915_STATUS1		0x10
+#define REG_AK09915_CNTL1		0x30
+#define REG_AK09915_CNTL2		0x31
+#define REG_AK09915_SENSITIVITY		0x60
+#define REG_AK09915_MEASURE_DATA	0x11
+
+/* AK09916 register definition */
+#define REG_AK09916_DMP_READ		0x3
+#define REG_AK09916_STATUS1		0x10
+#define REG_AK09916_CNTL2		0x31
+#define REG_AK09916_MEASURE_DATA	0x11
+
+#define DATA_AKM_ID			0x48
+#define DATA_AKM_MODE_PD		0x00
+#define DATA_AKM_MODE_SM		0x01
+#define DATA_AKM_MODE_ST		0x08
+#define DATA_AK09911_MODE_ST		0x10
+#define DATA_AK09912_MODE_ST		0x10
+#define DATA_AK09915_MODE_ST		0x10
+#define DATA_AK09916_MODE_ST		0x10
+#define DATA_AKM_MODE_FR		0x0F
+#define DATA_AK09911_MODE_FR		0x1F
+#define DATA_AK09912_MODE_FR		0x1F
+#define DATA_AKM_SELF_TEST		0x40
+#define DATA_AKM_DRDY			0x01
+#define DATA_AKM8963_BIT		0x10
+#define DATA_AKM_STAT_MASK		0x0C
+
+/* 0.3 uT * (1 << 30) */
+#define DATA_AKM8975_SCALE		322122547
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8972_SCALE		644245094
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE0		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE1		161061273
+/* 0.6 uT * (1 << 30) */
+#define DATA_AK09911_SCALE		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09912_SCALE		161061273
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09915_SCALE		161061273
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09916_SCALE		161061273
+#define DATA_MLX_SCALE			(4915 * (1L << 15))
+#define DATA_MLX_SCALE_EMPIRICAL	(26214 * (1L << 15))
+
+#define DATA_AKM8963_SCALE_SHIFT	4
+#define DATA_AKM_MIN_READ_TIME		(9 * NSEC_PER_MSEC)
+
+/* AK09912C NSF */
+/* 0:disable, 1:Low, 2:Middle, 3:High */
+#define DATA_AK9912_NSF			1
+#define DATA_AK9912_NSF_SHIFT		5
+
+/* AK09915 NSF */
+/* 0:disable, 1:Low, 2:Middle, 3:High */
+#define DATA_AK9915_NSF			1
+#define DATA_AK9915_NSF_SHIFT		5
+
+/* AK09915 SDR */
+/* 0:Low power drive, 1:Low noise drive */
+#define DATA_AK9915_SDR			0
+#define DATA_AK9915_SDR_SHIFT		6
+
+#define DEF_ST_COMPASS_WAIT_MIN		(10 * 1000)
+#define DEF_ST_COMPASS_WAIT_MAX		(15 * 1000)
+#define DEF_ST_COMPASS_TRY_TIMES	10
+#define DEF_ST_COMPASS_8963_SHIFT	2
+#define X	0
+#define Y	1
+#define Z	2
+
+/* milliseconds between each access */
+#define AKM_RATE_SCALE			10
+#define MLX_RATE_SCALE			50
+
+static const short AKM8975_ST_Lower[3] = { -100, -100, -1000 };
+static const short AKM8975_ST_Upper[3] = { 100, 100, -300 };
+
+static const short AKM8972_ST_Lower[3] = { -50, -50, -500 };
+static const short AKM8972_ST_Upper[3] = { 50, 50, -100 };
+
+static const short AKM8963_ST_Lower[3] = { -200, -200, -3200 };
+static const short AKM8963_ST_Upper[3] = { 200, 200, -800 };
+
+static const short AK09911_ST_Lower[3] = { -30, -30, -400 };
+static const short AK09911_ST_Upper[3] = { 30, 30, -50 };
+
+static const short AK09912_ST_Lower[3] = { -200, -200, -1600 };
+static const short AK09912_ST_Upper[3] = { 200, 200, -400 };
+
+static const short AK09915_ST_Lower[3] = { -200, -200, -800 };
+static const short AK09915_ST_Upper[3] = { 200, 200, -200 };
+
+static const short AK09916_ST_Lower[3] = { -200, -200, -1000 };
+static const short AK09916_ST_Upper[3] = { 200, 200, -200 };
+
+static bool secondary_resume_state;
+/*
+ *  inv_setup_compass_akm() - Configure akm series compass.
+ */
+static int inv_setup_compass_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[4];
+	u8 sens, mode, cmd, addr;
+
+	addr = st->plat_data.secondary_i2c_addr;
+
+	result = inv_execute_read_secondary(st, 0, addr, REG_AKM_ID, 1, data);
+	if (result) {
+		pr_info("%s: read secondary failed\n", __func__);
+		return result;
+	}
+	if (data[0] != DATA_AKM_ID) {
+		pr_info
+	("%s: DATA_AKM_ID check failed data[0] [%x] ID [%x] Addr [0x%X]\n",
+		__func__, data[0], DATA_AKM_ID, addr);
+		return -ENXIO;
+	}
+
+	/* set AKM register for mode control */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id)
+		mode = REG_AK09915_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+
+	/* AK09915 has ASA, but it is dummy with fixed value 128 */
+	if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id) {
+		st->chip_info.compass_sens[0] = 128;
+		st->chip_info.compass_sens[1] = 128;
+		st->chip_info.compass_sens[2] = 128;
+		result = inv_execute_write_secondary(st, 0, addr,
+				REG_AK09915_CNTL1,
+				DATA_AK9915_NSF << DATA_AK9915_NSF_SHIFT);
+		if (result)
+			return result;
+		goto skip_akm_fuse_rom_read;
+	}
+
+	/* AK09916 not have Fuse ROM */
+	if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		/* set dummy sens which should be utilized
+		 * in the same manner as AK09912 to make no adjustment. */
+		st->chip_info.compass_sens[0] = 128;
+		st->chip_info.compass_sens[1] = 128;
+		st->chip_info.compass_sens[2] = 128;
+		goto skip_akm_fuse_rom_read;
+	}
+
+	/* set AKM to Fuse ROM access mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09911_SENSITIVITY;
+		cmd = DATA_AK09911_MODE_FR;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09912_SENSITIVITY;
+		cmd = DATA_AK09912_MODE_FR;
+	} else {
+		sens = REG_AKM_SENSITIVITY;
+		cmd = DATA_AKM_MODE_FR;
+	}
+	result = inv_read_secondary(st, 0, addr, sens, THREE_AXES);
+	if (result)
+		return result;
+	result = inv_write_secondary(st, 1, addr, mode, cmd);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_write_secondary(st, 2, addr, REG_AK09912_CNTL1,
+				DATA_AK9912_NSF <<
+				DATA_AK9912_NSF_SHIFT);
+		if (result)
+			return result;
+	}
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+			BIT_I2C_MST_EN);
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00, THREE_AXES,
+			st->chip_info.compass_sens);
+	if (result)
+		return result;
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		return result;
+
+skip_akm_fuse_rom_read:
+	pr_debug("%s senx=%d, seny=%d, senz=%d\n",
+		st->hw->name,
+		st->chip_info.compass_sens[0],
+		st->chip_info.compass_sens[1], st->chip_info.compass_sens[2]);
+
+	/* output data for slave 1 is fixed, single measure mode */
+	st->slave_compass->scale = 1;
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8975_ST_Upper;
+		st->slave_compass->st_lower = AKM8975_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8972_ST_Upper;
+		st->slave_compass->st_lower = AKM8972_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8963_ST_Upper;
+		st->slave_compass->st_lower = AKM8963_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM |
+			(st->slave_compass->scale << DATA_AKM8963_SCALE_SHIFT);
+	} else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09911_ST_Upper;
+		st->slave_compass->st_lower = AK09911_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09912_ST_Upper;
+		st->slave_compass->st_lower = AK09912_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09915_ST_Upper;
+		st->slave_compass->st_lower = AK09915_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM |
+			(DATA_AK9915_SDR << DATA_AK9915_SDR_SHIFT);
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09916_ST_Upper;
+		st->slave_compass->st_lower = AK09916_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else {
+		return -EINVAL;
+	}
+	result = inv_write_secondary(st, 1, addr, mode, data[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV2_CTRL, 0);
+
+	return result;
+}
+
+static int inv_akm_read_data(struct inv_mpu_state *st, short *o)
+{
+	int result;
+	int i;
+	u8 d[DATA_AKM_99_BYTES_DMP - 1];
+	u8 *sens;
+
+	sens = st->chip_info.compass_sens;
+	result = 0;
+	for (i = 0; i < 6; i++)
+		d[1 + i] = st->fifo_data[i];
+	for (i = 0; i < 3; i++)
+		o[i] = (short)((d[i * 2 + 1] << 8) | d[i * 2 + 2]);
+
+	return result;
+}
+
+static int inv_check_akm_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[6], mode, addr;
+	u8 counter, cntl;
+	short x, y, z;
+	u8 *sens;
+	int shift;
+	u8 slv_ctrl[2];
+
+	addr = st->plat_data.secondary_i2c_addr;
+	sens = st->chip_info.compass_sens;
+
+	/* back up registers */
+	/* SLV0_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* SLV1_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id)
+		mode = REG_AK09915_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+	/* set to power down mode */
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		goto AKM_fail;
+
+	/* write 1 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09915 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result = inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL,
+				DATA_AKM_SELF_TEST);
+		if (result)
+			goto AKM_fail;
+	}
+	/* set self test mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09911_MODE_ST);
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09912_MODE_ST);
+	else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09915_MODE_ST);
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09916_MODE_ST);
+	else
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AKM_MODE_ST);
+
+	if (result)
+		goto AKM_fail;
+	counter = DEF_ST_COMPASS_TRY_TIMES;
+	while (counter > 0) {
+		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
+		if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09911_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09912_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09915_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09916_STATUS1,
+					1, data);
+		else
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AKM_STATUS, 1,
+					data);
+		if (result)
+			goto AKM_fail;
+		if ((data[0] & DATA_AKM_DRDY) == 0)
+			counter--;
+		else
+			counter = 0;
+	}
+	if ((data[0] & DATA_AKM_DRDY) == 0) {
+		result = -EINVAL;
+		goto AKM_fail;
+	}
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09911_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09912_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09915_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09916_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	}
+	if (result)
+		goto AKM_fail;
+
+	x = le16_to_cpup((__le16 *) (&data[0]));
+	y = le16_to_cpup((__le16 *) (&data[2]));
+	z = le16_to_cpup((__le16 *) (&data[4]));
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		shift = 7;
+	else
+		shift = 8;
+	x = ((x * (sens[0] + 128)) >> shift);
+	y = ((y * (sens[1] + 128)) >> shift);
+	z = ((z * (sens[2] + 128)) >> shift);
+	if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM8963_CNTL1, 1,
+				&cntl);
+		if (result)
+			goto AKM_fail;
+		if (0 == (cntl & DATA_AKM8963_BIT)) {
+			x <<= DEF_ST_COMPASS_8963_SHIFT;
+			y <<= DEF_ST_COMPASS_8963_SHIFT;
+			z <<= DEF_ST_COMPASS_8963_SHIFT;
+		}
+	}
+
+	pr_debug("lowerx=%d, upperx=%d, x=%d\n",
+		st->slave_compass->st_lower[X],
+		st->slave_compass->st_upper[X], x);
+	pr_debug("lowery=%d, uppery=%d, y=%d\n",
+		st->slave_compass->st_lower[Y],
+		st->slave_compass->st_upper[Y], y);
+	pr_debug("lowerz=%d, upperz=%d, z=%d\n",
+		st->slave_compass->st_lower[Z],
+		st->slave_compass->st_upper[Z], z);
+
+	result = -EINVAL;
+	if (x > st->slave_compass->st_upper[X] ||
+		x < st->slave_compass->st_lower[X])
+		goto AKM_fail;
+	if (y > st->slave_compass->st_upper[Y] ||
+		y < st->slave_compass->st_lower[Y])
+		goto AKM_fail;
+	if (z > st->slave_compass->st_upper[Z] ||
+		z < st->slave_compass->st_lower[Z])
+		goto AKM_fail;
+	result = 0;
+AKM_fail:
+	/*write 0 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09915 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result |= inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL, 0);
+	}
+	/*set to power down mode */
+	result |= inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+
+	/* restore registers */
+	result |= inv_plat_single_write(st, REG_I2C_SLV0_CTRL, slv_ctrl[0]);
+	result |= inv_plat_single_write(st, REG_I2C_SLV1_CTRL, slv_ctrl[1]);
+
+	return result;
+}
+
+/*
+ *  inv_write_akm_scale() - Configure the akm scale range.
+ */
+static int inv_write_akm_scale(struct inv_mpu_state *st, int data)
+{
+	char d, en;
+	int result;
+
+	if (COMPASS_ID_AK8963 != st->plat_data.sec_slave_id)
+		return 0;
+	en = !!data;
+	if (st->slave_compass->scale == en)
+		return 0;
+	d = (DATA_AKM_MODE_SM | (en << DATA_AKM8963_SCALE_SHIFT));
+	result = inv_plat_single_write(st, REG_I2C_SLV1_DO, d);
+	if (result)
+		return result;
+	st->slave_compass->scale = en;
+
+	return 0;
+}
+
+/*
+ *  inv_read_akm_scale() - show AKM scale.
+ */
+static int inv_read_akm_scale(struct inv_mpu_state *st, int *scale)
+{
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8975_SCALE;
+	else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8972_SCALE;
+	else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id)
+		if (st->slave_compass->scale)
+			*scale = DATA_AKM8963_SCALE1;
+		else
+			*scale = DATA_AKM8963_SCALE0;
+	else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09911_SCALE;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09912_SCALE;
+	else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09915_SCALE;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09916_SCALE;
+	else
+		return -EINVAL;
+
+	return IIO_VAL_INT;
+}
+
+static int inv_suspend_akm(struct inv_mpu_state *st)
+{
+	int result;
+
+	if (!secondary_resume_state)
+		return 0;
+
+	/* slave 0 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* slave 1 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+
+	secondary_resume_state = false;
+
+	return result;
+}
+
+static int inv_resume_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 reg_addr, bytes;
+
+	if (secondary_resume_state)
+		return 0;
+
+	/* slave 0 is used to read data from compass */
+	/*read mode */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_ADDR,
+			INV_MPU_BIT_I2C_READ |
+			st->plat_data.secondary_i2c_addr);
+	if (result)
+		return result;
+	/* AKM status register address is 1 */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09911_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09912_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09915 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09915_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09916_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else {
+		reg_addr = REG_AKM_INFO;
+		bytes = DATA_AKM_89_BYTES_DMP;
+	}
+	result = inv_plat_single_write(st, REG_I2C_SLV0_REG, reg_addr);
+	if (result)
+		return result;
+
+	/* slave 0 is enabled, read 10 or 8 bytes from here, swap bytes */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL,
+			INV_MPU_BIT_GRP |
+			INV_MPU_BIT_BYTE_SW |
+			INV_MPU_BIT_SLV_EN | bytes);
+	if (result)
+		return result;
+	/* slave 1 is enabled, write byte length is 1 */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL,
+			INV_MPU_BIT_SLV_EN | 1);
+
+	secondary_resume_state = true;
+
+	return result;
+}
+
+static struct inv_mpu_slave slave_akm = {
+	.suspend = inv_suspend_akm,
+	.resume = inv_resume_akm,
+	.get_scale = inv_read_akm_scale,
+	.set_scale = inv_write_akm_scale,
+	.self_test = inv_check_akm_self_test,
+	.setup = inv_setup_compass_akm,
+	.read_data = inv_akm_read_data,
+	.rate_scale = AKM_RATE_SCALE,
+	.min_read_time = DATA_AKM_MIN_READ_TIME,
+};
+
+int inv_mpu_setup_compass_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.sec_slave_id) {
+	case COMPASS_ID_AK8975:
+	case COMPASS_ID_AK8972:
+	case COMPASS_ID_AK8963:
+	case COMPASS_ID_AK09911:
+	case COMPASS_ID_AK09912:
+	case COMPASS_ID_AK09915:
+	case COMPASS_ID_AK09916:
+		st->slave_compass = &slave_akm;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_compass->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_core_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_core_42600.c
new file mode 100644
index 000000000000..d11c8b929105
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_core_42600.c
@@ -0,0 +1,1577 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM42600] = {128, "icm42600"},
+	[ICM42686] = {128, "icm42600"},
+	[ICM42688] = {128, "icm42600"},
+	[ICM40609D] = {128, "icm40600"},
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static char debug_reg_addr = 0x6;
+#endif
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int result = 0;
+	u8 w;
+	int bias;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+
+	/* accel_bias is 2g scaled by 1<<16 */
+	if (st->chip_type == ICM42686) {
+		/* convert to 32g */
+		bias = -(accel_bias / 16 / 65536);
+	} else {
+		/* convert to 16g */
+		bias = -(accel_bias / 8 / 65536);
+	}
+
+	switch (axis) {
+	case 0:
+		/*
+		 * X
+		 * REG_GOS_USER4 : AX[11:8] / GZ[11:8]
+		 * REG_GOS_USER5 : AX[7:0]
+		 */
+		result = inv_plat_read(st, REG_GOS_USER4, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_plat_single_write(st, REG_GOS_USER4, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER5, w);
+		if (result)
+			return result;
+		break;
+	case 1:
+		/*
+		 * Y
+		 * REG_GOS_USER6: AY[7:0]
+		 * REG_GOS_USER7: AZ[11:8] / AY[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER6, w);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GOS_USER7, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_plat_single_write(st, REG_GOS_USER7, w);
+		if (result)
+			return result;
+		break;
+	case 2:
+		/*
+		 * Z
+		 * REG_GOS_USER7: AZ[11:8] / AY[11:8]
+		 * REG_GOS_USER8: AZ[7:0]
+		 */
+		result = inv_plat_read(st, REG_GOS_USER7, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_plat_single_write(st, REG_GOS_USER7, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER8, w);
+		if (result)
+			return result;
+		break;
+	default:
+		result = -EINVAL;
+	}
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int result = 0;
+	u8 w;
+	int bias;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+
+	/* gyro_bias is 2000dps scaled by 1<<16 */
+	if (st->chip_type == ICM42686) {
+		/* convert to 2000dps */
+		bias = -(gyro_bias * 1 / 65536);
+	} else {
+		/* convert to 1000dps */
+		bias = -(gyro_bias * 2 / 65536);
+	}
+
+	switch (axis) {
+	case 0:
+		/*
+		 * X
+		 * REG_GOS_USER0: GX[7:0]
+		 * REG_GOS_USER1: GY[11:8] / GX[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER0, w);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GOS_USER1, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_plat_single_write(st, REG_GOS_USER1, w);
+		if (result)
+			return result;
+		break;
+	case 1:
+		/*
+		 * Y
+		 * REG_GOS_USER1: GY[11:8] / GX[11:8]
+		 * REG_GOS_USER2: GY[7:0]
+		 */
+		result = inv_plat_read(st, REG_GOS_USER1, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_plat_single_write(st, REG_GOS_USER1, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER2, w);
+		if (result)
+			return result;
+		break;
+	case 2:
+		/*
+		 * Z
+		 * REG_GOS_USER3: GZ[7:0]
+		 * REG_GOS_USER4: AX[11:8] / GZ[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_plat_single_write(st, REG_GOS_USER3, w);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GOS_USER4, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_plat_single_write(st, REG_GOS_USER4, w);
+		if (result)
+			return result;
+		break;
+	default:
+		result = -EINVAL;
+	}
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	}
+	return count;
+}
+#endif
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data, max, min;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		if (st->chip_type == ICM42686) {
+			min = 0; /* 250dps */
+			max = 4; /* 4000dps */
+		} else {
+			min = 0; /* 250dps */
+			max = 3; /* 2000dps */
+		}
+		if (data > max || data < min)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (st->chip_type == ICM42686) {
+			min = 0; /* 2g */
+			max = 4; /* 32g */
+		} else if (st->chip_type == ICM40609D) {
+			min = 1; /* 4g */
+			max = 4; /* 32g */
+		} else {
+			min = 0; /* 2g */
+			max = 3; /* 16g */
+		}
+		if (data > max || data < min)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_INT_MODE:
+		st->ped.int_mode = !!data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int rate = st->sensor_l[this_attr->address].rate;
+
+	switch (rate) {
+	case 12:
+		rate = 12500;
+		break;
+	case 6:
+		rate = 6250;
+		break;
+	case 3:
+		rate = 3125;
+		break;
+	default:
+		rate *= 1000;
+		break;
+	}
+
+	return snprintf(buf, MAX_WR_SZ, "%d.%03d\n", rate / 1000, rate % 1000);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, fract, rate, ind;
+	int result;
+
+	result = iio_str_to_fixpoint(buf, 1000, &data, &fract);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+		st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int step;
+	int update;
+
+	result = inv_get_42600_pedometer_steps(st,
+		&step, &update);
+	if (result) {
+		pr_info("Failed to read step count\n");
+		return result;
+	}
+	inv_send_steps(indio_dev, step, get_time_ns());
+	st->prev_steps = step;
+
+	return 0;
+}
+
+static int inv_send_pedo_steps(struct iio_dev *indio_dev)
+{
+	_send_pedo_steps(indio_dev);
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+	bool send_ped = false;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		if ((!!data) == st->smd.on) {
+			pr_debug("SMD is %s\n  Same",
+						st->smd.on ? "On" : "Off");
+			return count;
+		}
+		st->smd.on = !!data;
+		pr_debug("SMD is %s\n", st->smd.on ? "On" : "Off");
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_TAP_ENABLE:
+		if ((!!data) == st->chip_config.tap_enable) {
+			pr_info("Tap enable already %s\n",
+				st->chip_config.tap_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.tap_enable = !!data;
+		pr_info("Tap %s\n",
+			st->chip_config.tap_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.stationary_detect_enable)
+			return count;
+		st->chip_config.stationary_detect_enable = !!data;
+		pr_info("Stationary Detect %s\n",
+			st->chip_config.stationary_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.motion_detect_enable)
+			return count;
+		st->chip_config.motion_detect_enable = !!data;
+		pr_info("Motion Detect %s\n",
+			st->chip_config.motion_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0,
+					sizeof(struct spi_transfer));
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		if (st->step_counter_l_on)
+			send_ped = true;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		if (st->step_counter_wake_l_on)
+			send_ped = true;
+		break;
+	case ATTR_DMP_STEP_COUNTER_SEND:
+		if (st->step_counter_l_on || st->step_counter_wake_l_on)
+			inv_send_pedo_steps(indio_dev);
+		return count;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	case ATTR_HIGH_RES_MODE:
+		if (!!data == st->chip_config.high_res_mode)
+			return count;
+		/* high resolution mode is only supported by icm4268x chips */
+		if (!!data == 1 && st->chip_type != ICM42686 &&
+				   st->chip_type != ICM42688)
+			return -ENODEV;
+		st->chip_config.high_res_mode = !!data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	/* send the first step count after all configuration is done */
+	if (send_ped)
+		inv_send_pedo_steps(indio_dev);
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store()
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show()
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000, 4000 };
+			s16 fsr;
+
+			/* fifo data will be 4000dps FSR regardless of
+			 * FSR configuration when high resolution mode
+			 */
+			if (st->chip_config.high_res_mode) {
+				if (st->chip_type == ICM42686)
+					fsr = 4000;
+				else
+					fsr = 2000;
+			} else
+				fsr = gyro_scale[st->chip_config.fsr];
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", fsr);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16, 32 };
+			s16 fsr;
+
+			/* fifo data will be 32g FSR regardless of
+			 * FSR configuration when high resolution mode
+			 */
+			if (st->chip_config.high_res_mode) {
+				if (st->chip_type == ICM42686)
+					fsr = 32;
+				else
+					fsr = 16;
+			} else
+				fsr = accel_scale[st->chip_config.accel_fs];
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", fsr);
+		}
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.accel_enable);
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_INT_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_mode);
+	case ATTR_DMP_SMD_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->smd.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_TAP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tap_enable);
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.stationary_detect_enable);
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.motion_detect_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.eis_enable);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_wake_l_on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[2]);
+	case ATTR_HIGH_RES_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.high_res_mode);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+/*
+ * inv_smd_show() -  calling this function showes smd interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_smd_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_tilt_show() -  calling this function showes tilt interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_pick_up_show() -  calling this function showes pick up interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_pick_up_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+#endif
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 0\n");
+	for (ii = 0; ii <= 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_DATA_REG))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+
+	inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 4\n");
+	for (ii = REG_APEX_CONFIG1; ii <= 0x7F; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+
+	inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+static DEVICE_ATTR(poll_smd, S_IRUGO,
+			inv_smd_show, NULL);
+static DEVICE_ATTR(poll_pedometer, S_IRUGO,
+			inv_ped_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO,
+			inv_tilt_show, NULL);
+static DEVICE_ATTR(poll_pick_up, S_IRUGO,
+			inv_pick_up_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR,
+			inv_reg_dump_show, NULL);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+#endif
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR,
+			inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR,
+			NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show,
+			inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_GYRO_SCALE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DEBUG_REG_ADDR);
+#endif
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_send, S_IRUGO | S_IWUSR,
+		NULL, inv_basic_attr_store,
+		ATTR_DMP_STEP_COUNTER_SEND);
+static IIO_DEVICE_ATTR(event_smd_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_SMD_ENABLE);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(event_stationary_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STATIONARY_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_motion_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_MOTION_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+
+static IIO_DEVICE_ATTR(in_high_res_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_HIGH_RES_MODE);
+
+static IIO_DEVICE_ATTR(event_tap_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TAP_ENABLE);
+
+static IIO_DEVICE_ATTR(params_pedometer_int_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_ON);
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+static IIO_DEVICE_ATTR(params_pedometer_int_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_MODE);
+#endif
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&dev_attr_out_temperature.attr,
+#endif
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_high_res_mode.dev_attr.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_tilt.attr,
+	&dev_attr_poll_pick_up.attr,
+	&iio_dev_attr_params_pedometer_int_on.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_mode.dev_attr.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_event_tap_enable.dev_attr.attr,
+	&iio_dev_attr_event_stationary_detect_enable.dev_attr.attr,
+	&iio_dev_attr_event_motion_detect_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_send.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_smd_attributes[] = {
+	&dev_attr_poll_smd.attr,
+	&iio_dev_attr_event_smd_enable.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_debug_attributes) +
+#endif
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_pedometer_attributes) +
+#endif
+					ARRAY_SIZE(inv_smd_attributes) +
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	pr_info("id name = %s\n", name);
+	if (!strcmp(name, "icm42600") || !strcmp(name, "iim42600")) {
+		st->chip_type = ICM42600;
+		st->apex_supported = true;
+		st->smd_supported = true;
+	} else if (!strcmp(name, "icm42686")) {
+		st->chip_type = ICM42686;
+		st->apex_supported = true;
+		st->smd_supported = true;
+	} else if (!strcmp(name, "icm42688")) {
+		st->chip_type = ICM42688;
+		st->apex_supported = true;
+		st->smd_supported = true;
+	} else if (!strcmp(name, "icm40609d")) {
+		st->chip_type = ICM40609D;
+		st->apex_supported = false;
+		st->smd_supported = false;
+	} else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_smd_attributes,
+				sizeof(inv_smd_attributes));
+	t_ind += ARRAY_SIZE(inv_smd_attributes);
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+/*
+ * sysfs entries for authentication
+ */
+static ssize_t inv_auth_i_read(struct file *fp, struct kobject *kobj,
+		struct bin_attribute *attr, char *buf, loff_t pos, size_t count)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	return memory_read_from_buffer(buf, count, &pos,
+			st->auth_i, sizeof(st->auth_i));
+}
+
+static ssize_t inv_auth_i_write(struct file *fp, struct kobject *kobj,
+		struct bin_attribute *attr, char *buf, loff_t pos, size_t count)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (count > sizeof(st->auth_i) - pos)
+		return -EINVAL;
+
+	memcpy(st->auth_i + pos, buf, count);
+
+	return count;
+}
+
+static ssize_t inv_auth_o_read(struct file *fp, struct kobject *kobj,
+		struct bin_attribute *attr, char *buf, loff_t pos, size_t count)
+{
+	int result = 0;
+	size_t copied;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (st->auth_i[8] > 0 && pos == 0) {
+		/* perform authentication */
+		mutex_lock(&st->lock);
+		result = inv_run_auth(st);
+		set_inv_enable(indio_dev);
+		mutex_unlock(&st->lock);
+	}
+
+	copied = memory_read_from_buffer(buf, count, &pos,
+			st->auth_o, sizeof(st->auth_o));
+
+	return result ? result : copied;
+}
+
+static struct bin_attribute auth_i_bin_attrs = {
+	.attr = {
+		.name = "misc_bin_auth_i",
+		.mode = S_IRUGO | S_IWUSR },
+	.read = inv_auth_i_read,
+	.write = inv_auth_i_write,
+};
+
+static struct bin_attribute auth_o_bin_attrs = {
+	.attr = {
+		.name = "misc_bin_auth_o",
+		.mode = S_IRUGO },
+	.read = inv_auth_o_read,
+	.write = NULL,
+};
+
+static int inv_create_auth_bin_sysfs(struct iio_dev *ind)
+{
+	int result = 0;
+
+	struct inv_mpu_state *st = iio_priv(ind);
+
+	if (st->chip_type == ICM42600) {
+		auth_i_bin_attrs.size = sizeof(st->auth_i);
+		auth_o_bin_attrs.size = sizeof(st->auth_o);
+		result = sysfs_create_bin_file(&ind->dev.kobj, &auth_i_bin_attrs);
+		if (result)
+			return result;
+		result = sysfs_create_bin_file(&ind->dev.kobj, &auth_o_bin_attrs);
+		if (result)
+			return result;
+	}
+
+	return result;
+}
+
+/*
+ * This is not dmp sysfs for ICM426xx but simply reuse
+ * an existing function for authentication
+ */
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	int result;
+
+	result = inv_create_auth_bin_sysfs(ind);
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM40xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_iio_reg_42600.h b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_iio_reg_42600.h
new file mode 100644
index 000000000000..ee4836cee1ad
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_iio_reg_42600.h
@@ -0,0 +1,647 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_42600_H_
+#define _INV_MPU_IIO_REG_42600_H_
+
+/* Comment out to use lower power feature
+ * by BIT_DMP_POWER_SAVE_EN
+ */
+#define NOT_SET_DMP_POWER_SAVE
+
+/* Comment out not to use lower power mode on accel */
+#define SUPPORT_ACCEL_LPM
+
+/* Uncommnet to enable RTC MODE (Only for ICM42622/42688) */
+//#define SUPPORT_RTC_MODE
+
+/* RTC(CLKIN) frequency in Hz (Only for ICM42622/42688) */
+#define RTC_FREQ_HZ			32768
+
+/* Registers and associated bit definitions */
+/* Bank 0 */
+#define REG_CHIP_CONFIG_REG		0x11
+#define REG_DRIVE_CONFIG		0x13
+#define REG_INT_CONFIG_REG		0x14
+#define REG_FIFO_CONFIG_REG		0x16
+#define REG_TEMP_DATA0_UI		0x1D
+#define REG_TEMP_DATA1_UI		0x1E
+#define REG_ACCEL_DATA_X0_UI		0x1F
+#define REG_ACCEL_DATA_X1_UI		0x20
+#define REG_ACCEL_DATA_Y0_UI		0x21
+#define REG_ACCEL_DATA_Y1_UI		0x22
+#define REG_ACCEL_DATA_Z0_UI		0x23
+#define REG_ACCEL_DATA_Z1_UI		0x24
+#define REG_GYRO_DATA_X0_UI		0x25
+#define REG_GYOR_DATA_X1_UI		0x26
+#define REG_GYRO_DATA_Y0_UI		0x27
+#define REG_GYRO_DATA_Y1_UI		0x28
+#define REG_GYRO_DATA_Z0_UI		0x29
+#define REG_GYRO_DATA_Z1_UI		0x2A
+#define REG_TMST_FSYNC1			0x2B
+#define REG_TMST_FSYNC2			0x2C
+#define REG_INT_STATUS			0x2D
+#define REG_FIFO_BYTE_COUNT1		0x2E
+#define REG_FIFO_BYTE_COUNT2		0x2F
+#define REG_FIFO_DATA_REG		0x30
+#define REG_APEX_DATA0			0x31
+#define REG_APEX_DATA1			0x32
+#define REG_APEX_DATA2			0x33
+#define REG_APEX_DATA3			0x34
+#define REG_APEX_DATA4			0x35
+#define REG_APEX_DATA5			0x36
+#define REG_INT_STATUS2			0x37
+#define REG_INT_STATUS3			0x38
+#define REG_SIGNAL_PATH_RESET		0x4B
+#define REG_INTF_CONFIG0		0x4C
+#define REG_INTF_CONFIG1		0x4D
+#define REG_PWR_MGMT_0			0x4E
+#define REG_GYRO_CONFIG0		0x4F
+#define REG_ACCEL_CONFIG0		0x50
+#define REG_GYRO_CONFIG1		0x51
+#define REG_GYRO_ACCEL_CONFIG0		0x52
+#define REG_ACCEL_CONFIG1		0x53
+#define REG_TMST_CONFIG			0x54
+#define REG_APEX_CONFIG0		0x56
+#define REG_SMD_CONFIG			0x57
+#define REG_FIFO_CONFIG1		0x5F
+#define REG_FIFO_CONFIG2		0x60
+#define REG_FIFO_CONFIG3		0x61
+#define REG_FSYNC_CONFIG		0x62
+#define REG_INT_CONFIG0			0x63
+#define REG_INT_CONFIG1			0x64
+#define REG_INT_SOURCE0			0x65
+#define REG_INT_SOURCE1			0x66
+#define REG_INT_SOURCE2			0x67
+#define REG_INT_SOURCE3			0x68
+#define REG_INT_SOURCE4			0x69
+#define REG_INT_SOURCE5			0x6A
+#define REG_SENSOR_SELFTEST_REG1	0x6B
+#define REG_FIFO_LOST_PKT0		0x6C
+#define REG_FIFO_LOST_PKT1		0x6D
+#define REG_SELF_TEST_CONFIG		0x70
+#define REG_MEM_BANK_SEL		0x72
+#define REG_MEM_START_ADDR		0x73
+#define REG_MEM_R_W			0x74
+#define REG_WHO_AM_I			0x75
+#define REG_REG_BANK_SEL		0x76
+
+/* Bank 1 */
+#define REG_GYRO_CONFIG_STATIC2		0x0B
+#define REG_XG_ST_DATA			0x5F
+#define REG_YG_ST_DATA			0x60
+#define REG_ZG_ST_DATA			0x61
+#define REG_TMSTVAL0			0x62
+#define REG_TMSTVAL1			0x63
+#define REG_TMSTVAL2			0x64
+#define REG_HTR_CONFIG			0x77
+#define REG_INTF_CONFIG2		0x78
+#define REG_INTF_CONFIG3		0x79
+#define REG_INTF_CONFIG4		0x7A
+#define REG_INTF_CONFIG5		0x7B
+#define REG_INTF_CONFIG6		0x7C
+#define REG_INTF_CONFIG7		0x7D
+#define REG_INTF_CONFIG8		0x7E
+#define REG_INTF_CONFIG9		0x7F
+
+/* Bank 2 */
+#define REG_XA_ST_DATA			0x3B
+#define REG_YA_ST_DATA			0x3C
+#define REG_ZA_ST_DATA			0x3D
+#define REG_AUX1_FIFO_DATA		0x3F
+#define REG_AUX1_FIFO_COUNT1		0x40
+#define REG_AUX1_FIFO_COUNT2		0x41
+#define REG_AUX1_FIFO_LOST_PKT0		0x42
+#define REG_AUX1_FIFO_LOST_PKT1		0x43
+#define REG_OIS1_CONFIG1		0x44
+#define REG_OIS1_CONFIG2		0x45
+#define REG_OIS1_CONFIG3		0x46
+#define REG_TEMP_DATA0_OIS1		0x47
+#define REG_TEMP_DATA1_OIS1		0x48
+#define REG_ACCEL_DATA_X0_OIS1		0x49
+#define REG_ACCEL_DATA_X1_OIS1		0x4A
+#define REG_ACCEL_DATA_Y0_OIS1		0x4B
+#define REG_ACCEL_DATA_Y1_OIS1		0x4C
+#define REG_ACCEL_DATA_Z0_OIS1		0x4D
+#define REG_ACCEL_DATA_Z1_OIS1		0x4E
+#define REG_GYRO_DATA_X0_OIS1		0x4F
+#define REG_GYRO_DATA_X1_OIS1		0x50
+#define REG_GYRO_DATA_Y0_OIS1		0x51
+#define REG_GYRO_DATA_Y1_OIS1		0x52
+#define REG_GYRO_DATA_Z0_OIS1		0x53
+#define REG_GYRO_DATA_Z1_OIS1		0x54
+#define REG_TMSTVAL0_OIS1		0x55
+#define REG_TMSTVAL1_OIS1		0x56
+#define REG_INT_STATUS_OIS1		0x57
+
+/* Bank 3 */
+#define REG_AFSR_CONFIG0		0x6E
+#define REG_AFSR_CONFIG1		0x6F
+#define REG_DMP_CONFIG			0x71
+#define REG_ABORT_RST_CONFIG		0x72
+#define REG_S4S_CONFIG			0x77
+#define REG_S4S_FREQ_RATIO1		0x79
+#define REG_S4S_FREQ_RATIO2		0x7A
+#define REG_S4S_GYRO_TPH1		0x7B
+#define REG_S4S_GYRO_TPH2		0x7C
+#define REG_S4S_ACCEL_TPH1		0x7D
+#define REG_S4S_ACCEL_TPH2		0x7E
+#define REG_S4S_RR			0x7F
+
+/* Bank 4 */
+#define REG_DRV_GYR_CFG0_REG		0x10
+#define REG_DRV_GYR_CFG1_REG		0x11
+#define REG_DRV_GYR_CFG2_REG		0x12
+#define REG_APEX_CONFIG1		0x40
+#define REG_APEX_CONFIG2		0x41
+#define REG_APEX_CONFIG3		0x42
+#define REG_APEX_CONFIG4		0x43
+#define REG_APEX_CONFIG5		0x44
+#define REG_APEX_CONFIG6		0x45
+#define REG_APEX_CONFIG7		0x46
+#define REG_APEX_CONFIG8		0x47
+#define REG_APEX_CONFIG9		0x48
+#define REG_APEX_CONFIG10		0x49
+#define REG_ACCEL_WOM_X_THR		0x4A
+#define REG_ACCEL_WOM_Y_THR		0x4B
+#define REG_ACCEL_WOM_Z_THR		0x4C
+#define REG_INT_SOURCE6			0x4D
+#define REG_INT_SOURCE7			0x4E
+#define REG_INT_SOURCE8			0x4F
+#define REG_INT_SOURCE9			0x50
+#define REG_INT_SOURCE10		0x51
+#define REG_INTF_CONFIG10		0x52
+#define REG_INTF_CONFIG11		0x53
+#define REG_COMM_ERR			0x54
+#define REG_AFSR_CONFIG2		0x70
+#define REG_GOS_USER0			0x77
+#define REG_GOS_USER1			0x78
+#define REG_GOS_USER2			0x79
+#define REG_GOS_USER3			0x7A
+#define REG_GOS_USER4			0x7B
+#define REG_GOS_USER5			0x7C
+#define REG_GOS_USER6			0x7D
+#define REG_GOS_USER7			0x7E
+#define REG_GOS_USER8			0x7F
+
+
+/* REG_REG_BANK_SEL */
+#define BIT_BANK_SEL_0			0x00
+#define BIT_BANK_SEL_1			0x01
+#define BIT_BANK_SEL_2			0x02
+#define BIT_BANK_SEL_3			0x03
+#define BIT_BANK_SEL_4			0x04
+
+/* Bank0 REG_WHO_AM_I */
+#define WHO_AM_I_ICM42602		0x41
+#define WHO_AM_I_ICM42605		0x42
+
+/* Bank0 REG_CHIP_CONFIG_REG */
+#define BIT_SOFT_RESET			0x01
+
+/* Bank0 REG_DRIVE_CONFIG */
+#define BIT_SPI_SLEW_RATE_12NS		0x01
+#define BIT_SPI_SLEW_RATE_2NS		0x05
+#define BIT_I2C_SLEW_RATE_20NS		0x00
+#define BIT_I2C_SLEW_RATE_12NS		0x08
+
+/* Bank0 REG_GYRO_CONFIG0/REG_ACCEL_CONFIG0 */
+#define SHIFT_GYRO_FS_SEL		5
+#define SHIFT_ACCEL_FS_SEL		5
+#define SHIFT_ODR_CONF			0
+
+/* Bank0 REG_GYRO_CONFIG1 */
+#define BIT_TEMP_FILT_BW_BYPASS		0x00
+#define BIT_TEMP_FILT_BW_170		0x20
+#define BIT_TEMP_FILT_BW_82		0x40
+#define BIT_TEMP_FILT_BW_40		0x60
+#define BIT_TEMP_FILT_BW_20		0x80
+#define BIT_TEMP_FILT_BW_10		0x90
+#define BIT_TEMP_FILT_BW_5		0xC0
+#define BIT_GYR_AVG_FLT_RATE_8KHZ	0x10
+#define BIT_GYR_AVG_FLT_RATE_1KHZ	0x00
+#define BIT_GYR_UI_FILT_ORD_IND_1	0x00
+#define BIT_GYR_UI_FILT_ORD_IND_2	0x04
+#define BIT_GYR_UI_FILT_ORD_IND_3	0x08
+#define BIT_GYR_DEC2_M2_ORD_1		0x00
+#define BIT_GYR_DEC2_M2_ORD_2		0x01
+#define BIT_GYR_DEC2_M2_ORD_3		0x02
+
+/* Bank0 REG_ACCEL_CONFIG1 */
+#define BIT_ACC_UI_FILT_ODR_IND_1	0x00
+#define BIT_ACC_UI_FILT_ODR_IND_2	0x08
+#define BIT_ACC_UI_FILT_ODR_IND_3	0x10
+#define BIT_ACC_DEC2_M2_ORD_1		0x00
+#define BIT_ACC_DEC2_M2_ORD_2		0x02
+#define BIT_ACC_DEC2_M2_ORD_3		0x04
+#define BIT_ACC_AVG_FLT_RATE_8KHZ	0x01
+#define BIT_ACC_AVG_FLT_RATE_1KHZ	0x00
+
+/* Bank0 REG_INT_CONFIG_REG */
+#define SHIFT_INT1_POLARITY		0
+#define SHIFT_INT1_DRIVE_CIRCUIT	1
+#define SHIFT_INT1_MODE			2
+
+/* Bank0 REG_PWR_MGMT_0 */
+#define BIT_TEMP_DIS			0x20
+#define BIT_IDLE			0x10
+#define BIT_GYRO_MODE_OFF		0x00
+#define BIT_GYRO_MODE_STBY		0x04
+#define BIT_GYRO_MODE_LPM		0x08
+#define BIT_GYRO_MODE_LNM		0x0C
+#define BIT_ACCEL_MODE_OFF		0x00
+#define BIT_ACCEL_MODE_LPM		0x02
+#define BIT_ACCEL_MODE_LNM		0x03
+
+/* Bank0 REG_SIGNAL_PATH_RESET */
+#define BIT_TEMP_RST			0x01
+#define BIT_FIFO_FLUSH			0x02
+#define BIT_TMST_STROBE			0x04
+#define BIT_ABORT_AND_RESET		0x08
+#define BIT_S4S_RESTART			0x10
+#define BIT_DMP_MEM_RESET_EN		0x20
+#define BIT_DMP_INIT_EN			0x40
+
+/* Bank0 REG_INTF_CONFIG0 */
+#define BIT_FIFO_COUNT_REC		0x40
+#define BIT_COUNT_BIG_ENDIAN		0x20
+#define BIT_SENS_DATA_BIG_ENDIAN	0x10
+#define BIT_UI_SIFS_DISABLE_SPI		0x02
+#define BIT_UI_SIFS_DISABLE_I2C		0x03
+
+/* Bank0 REG_INTF_CONFIG1 */
+#define BIT_GYRO_AFSR_MODE_LFS		0x00
+#define BIT_GYRO_AFSR_MODE_HFS		0x40
+#define BIT_GYRO_AFSR_MODE_DYN		0xC0
+#define BIT_ACCEL_AFSR_MODE_LFS		0x00
+#define BIT_ACCEL_AFSR_MODE_HFS		0x10
+#define BIT_ACCEL_AFSR_MODE_DYN		0x30
+#define BIT_ACCEL_LP_CLK_SEL		0x08
+#define BIT_RTC_MODE			0x04
+#define BIT_CLK_SEL_RC			0x00
+#define BIT_CLK_SEL_PLL			0x01
+#define BIT_CLK_SEL_DIS			0x03
+
+/* Bank0 REG_FIFO_CONFIG1 */
+#define BIT_FIFO_ACCEL_EN		0x01
+#define BIT_FIFO_GYRO_EN		0x02
+#define BIT_FIFO_TEMP_EN		0x04
+#define BIT_FIFO_TMST_FSYNC_EN		0x08
+#define BIT_FIFO_HIRES_EN		0x10
+#define BIT_FIFO_WM_TH			0x20
+#define BIT_FIFO_RESUME_PART_RD		0x40
+
+/* Bank0 REG_INT_CONFIG1 */
+#define BIT_INT_ASY_RST_DISABLE		0x10
+
+/* Bank0 REG_INT_SOURCE0 */
+#define BIT_INT_UI_AGC_RDY_INT1_EN	0x01
+#define BIT_INT_FIFO_FULL_INT1_EN	0x02
+#define BIT_INT_FIFO_THS_INT1_EN	0x04
+#define BIT_INT_UI_DRDY_INT1_EN		0x08
+#define BIT_INT_RESET_DONE_INT1_EN	0x10
+#define BIT_INT_PLL_RDY_INT1_EN		0x20
+#define BIT_INT_UI_FSYNC_INT1_EN	0x40
+
+/* Bank0 REG_INT_SOURCE1 */
+#define BIT_INT_WOM_X_INT1_EN		0x01
+#define BIT_INT_WOM_Y_INT1_EN		0x02
+#define BIT_INT_WOM_Z_INT1_EN		0x04
+#define BIT_INT_SMD_INT1_EN		0x08
+#define BIT_INT_WOM_XYZ_INT1_EN \
+	(BIT_INT_WOM_X_INT1_EN | BIT_INT_WOM_Y_INT1_EN | BIT_INT_WOM_Z_INT1_EN)
+
+/* Bank0 REG_SENSOR_SELFTEST_REG1 */
+#define BIT_ACCEL_SELF_TEST_PASS	0x08
+#define BIT_GYRO_SELF_TEST_PASS		0x04
+#define BIT_ACCEL_SELF_TEST_DONE	0x02
+#define BIT_GYRO_SELF_TEST_DONE		0x01
+
+/* Bank0 REG_SELF_TEST_CONFIG */
+#define BIT_SELF_TEST_REGULATOR_EN	0x40
+#define BIT_TEST_AZ_EN			0x20
+#define BIT_TEST_AY_EN			0x10
+#define BIT_TEST_AX_EN			0x08
+#define BIT_TEST_GZ_EN			0x04
+#define BIT_TEST_GY_EN			0x02
+#define BIT_TEST_GX_EN			0x01
+
+/* Bank0 REG_INT_STATUS */
+#define BIT_INT_STATUS_AGC_RDY		0x01
+#define BIT_INT_STATUS_FIFO_FULL	0x02
+#define BIT_INT_STATUS_FIFO_THS		0x04
+#define BIT_INT_STATUS_DRDY		0x08
+#define BIT_INT_STATUS_RESET_DONE	0x10
+#define BIT_INT_STATUS_PLL_DRY		0x20
+#define BIT_INT_STATUS_UI_FSYNC		0x40
+
+/* Bank0 REG_INT_STATUS2 */
+#define BIT_INT_STATUS_WOM_X		0x01
+#define BIT_INT_STATUS_WOM_Y		0x02
+#define BIT_INT_STATUS_WOM_Z		0x04
+#define BIT_INT_STATUS_SMD		0x08
+#define BIT_INT_STATUS_WOM_XYZ \
+	(BIT_INT_STATUS_WOM_X | BIT_INT_STATUS_WOM_Y | BIT_INT_STATUS_WOM_Z)
+
+/* Bank0 REG_INT_STATUS3 */
+#define BIT_INT_STATUS_TAP_DET		0x01
+#define BIT_INT_STATUS_SLEEP_DET	0x02
+#define BIT_INT_STATUS_RAISE_DET	0x04
+#define BIT_INT_STATUS_TILT_DET		0x08
+#define BIT_INT_STATUS_STEP_CNT_OVFL	0x10
+#define BIT_INT_STATUS_STEP_DET		0x20
+#define BIT_INT_STATUS_DMP_POWER_SAVE	0x40
+
+/* Bank0 REG_FIFO_CONFIG_REG */
+#define BIT_FIFO_MODE_BYPASS		0x00
+#define BIT_FIFO_MODE_STREAM		0x40
+#define BIT_FIFO_MODE_STOP_FULL		0x80
+
+/* Bank0 REG_GYRO_ACCEL_CONFIG0 */
+#define BIT_ACCEL_UI_LNM_BW_2_FIR	0x00
+#define BIT_ACCEL_UI_LNM_BW_4_IIR	0x10
+#define BIT_ACCEL_UI_LNM_BW_5_IIR	0x20
+#define BIT_ACCEL_UI_LNM_BW_8_IIR	0x30
+#define BIT_ACCEL_UI_LNM_BW_10_IIR	0x40
+#define BIT_ACCEL_UI_LNM_BW_16_IIR	0x50
+#define BIT_ACCEL_UI_LNM_BW_20_IIR	0x60
+#define BIT_ACCEL_UI_LNM_BW_40_IIR	0x70
+#define BIT_ACCEL_UI_LNM_AVG_1		0xF0
+#define BIT_ACCEL_UI_LPM_BW_2_FIR	0x00
+#define BIT_ACCEL_UI_LPM_AVG_1		0x10
+#define BIT_ACCEL_UI_LPM_AVG_2		0x20
+#define BIT_ACCEL_UI_LPM_AVG_3		0x30
+#define BIT_ACCEL_UI_LPM_AVG_4		0x40
+#define BIT_ACCEL_UI_LPM_AVG_8		0x50
+#define BIT_ACCEL_UI_LPM_AVG_16		0x60
+#define BIT_ACCEL_UI_LPM_AVG_32		0x70
+#define BIT_ACCEL_UI_LPM_AVG_64		0x80
+#define BIT_ACCEL_UI_LPM_AVG_128	0x90
+#define BIT_GYRO_UI_LNM_BW_2_FIR	0x00
+#define BIT_GYRO_UI_LNM_BW_4_IIR	0x01
+#define BIT_GYRO_UI_LNM_BW_5_IIR	0x02
+#define BIT_GYRO_UI_LNM_BW_8_IIR	0x03
+#define BIT_GYRO_UI_LNM_BW_10_IIR	0x04
+#define BIT_GYRO_UI_LNM_BW_16_IIR	0x05
+#define BIT_GYRO_UI_LNM_BW_20_IIR	0x06
+#define BIT_GYRO_UI_LNM_BW_40_IIR	0x07
+#define BIT_GYRO_UI_LNM_AVG_1		0xF0
+#define BIT_GYRO_UI_LPM_BW_2_FIR	0x00
+#define BIT_GYRO_UI_LPM_AVG_1		0x01
+#define BIT_GYRO_UI_LPM_AVG_2		0x02
+#define BIT_GYRO_UI_LPM_AVG_3		0x03
+#define BIT_GYRO_UI_LPM_AVG_4		0x04
+#define BIT_GYRO_UI_LPM_AVG_8		0x05
+#define BIT_GYRO_UI_LPM_AVG_16		0x06
+#define BIT_GYRO_UI_LPM_AVG_32		0x07
+#define BIT_GYRO_UI_LPM_AVG_64		0x08
+#define BIT_GYRO_UI_LPM_AVG_128		0x09
+
+/* Bank0 REG_SMD_CONFIG */
+#define BIT_WOM_INT_MODE_OR		0x00
+#define BIT_WOM_INT_MODE_AND		0x08
+#define BIT_WOM_MODE_INITIAL		0x00
+#define BIT_WOM_MODE_PREV		0x04
+#define BIT_SMD_MODE_OFF		0x00
+#define BIT_SMD_MODE_OLD		0x01
+#define BIT_SMD_MODE_SHORT		0x02
+#define BIT_SMD_MODE_LONG		0x03
+
+/* Bank0 REG_TMST_CONFIG */
+#define BIT_FIFO_RAM_ISO_ENA		0x40
+#define BIT_EN_DREG_FIFO_D2A		0x20
+#define BIT_TMST_TO_REGS_EN		0x10
+#define BIT_TMST_RESOL			0x08
+#define BIT_TMST_DELTA_EN		0x04
+#define BIT_TMST_FSYNC_EN		0x02
+#define BIT_TMST_EN			0x01
+
+/* Bank0 REG_APEX_CONFIG0 */
+#define BIT_DMP_ODR_25HZ		0x00
+#define BIT_DMP_ODR_50HZ		0x02
+#define BIT_DMP_ODR_100HZ		0x03
+#define BIT_RAISE_ENABLE		0x08
+#define BIT_TILT_ENABLE			0x10
+#define BIT_PEDO_ENABLE			0x20
+#define BIT_TAP_ENABLE			0x40
+#define BIT_DMP_POWER_SAVE_EN		0x80
+
+/* Bank0 REG_ACCEL_CONFIG0 */
+#define BIT_ACCEL_FSR			0xE0
+#define BIT_ACCEL_ODR			0x0F
+#define BIT_ACCEL_ODR_1000		0x06
+#define BIT_ACCEL_ODR_500		0x0F
+#define BIT_ACCEL_ODR_200		0x07
+#define BIT_ACCEL_ODR_100		0x08
+#define BIT_ACCEL_ODR_50		0x09
+#define BIT_ACCEL_ODR_25		0x0A
+#define BIT_ACCEL_ODR_12		0x0B
+#define BIT_ACCEL_ODR_6			0x0C
+#define BIT_ACCEL_ODR_3			0x0D
+#define BIT_ACCEL_ODR_1			0x0E
+
+/* Bank0 REG_GYRO_CONFIG0 */
+#define BIT_GYRO_FSR			0xE0
+#define BIT_GYRO_ODR			0x0F
+#define BIT_GYRO_ODR_1000		0x06
+#define BIT_GYRO_ODR_500		0x0F
+#define BIT_GYRO_ODR_200		0x07
+#define BIT_GYRO_ODR_100		0x08
+#define BIT_GYRO_ODR_50			0x09
+#define BIT_GYRO_ODR_25			0x0A
+#define BIT_GYRO_ODR_12			0x0B
+
+/* Bank1 REG_INTF_CONFIG4 */
+#define BIT_I3C_BUS_MODE		0x40
+
+/* Bank1 REG_INTF_CONFIG5 */
+#define BIT_PIN9_FUNC_INT2		0x00
+#define BIT_PIN9_FUNC_FSYNC		0x02
+#define BIT_PIN9_FUNC_CLKIN		0x04
+#define BIT_PIN9_FUNC_RSV		0x06
+
+/* Bank1 REG_INTF_CONFIG6 */
+#define BIT_I3C_SDR_EN			0x01
+#define BIT_I3C_DDR_EN			0x02
+#define BIT_I3C_IBI_EN			0x04
+#define BIT_I3C_IBI_BYTE_EN		0x08
+#define BIT_I3C_EN			0x10
+
+/* Bank4 REG_DRV_GYR_CFG0_REG */
+#define GYRO_DRV_TEST_FSMFORCE_D2A_LINEAR_START_MODE		0x0D
+#define GYRO_DRV_TEST_FSMFORCE_D2A_STEADY_STATE_AGC_REG_MODE	0x2A
+
+/* Bank4 REG_DRV_GYR_CFG2_REG */
+#define GYRO_DRV_SPARE2_D2A_EN		0x01
+
+/* Bank4 REG_INT_SOURCE6 */
+#define BIT_INT_TAP_DET_INT1_EN		0x01
+#define BIT_INT_SLEEP_DET_INT1_EN	0x02
+#define BIT_INT_RAISE_DET_INT1_EN	0x04
+#define BIT_INT_TILT_DET_INT1_EN	0x08
+#define BIT_INT_STEP_CNT_OVFL_INT1_EN	0x10
+#define BIT_INT_STEP_DET_INT1_EN	0x20
+#define BIT_INT_DMP_POWER_SAVE_INT1_EN	0x40
+
+/* Bank4 REG_INT_SOURCE7 */
+#define BIT_INT_TAP_DET_INT2_EN		0x01
+#define BIT_INT_HIGHG_DET_INT2_EN	0x02
+#define BIT_INT_LOWG_DET_INT2_EN	0x04
+#define BIT_INT_TILT_DET_INT2_EN	0x80
+#define BIT_INT_STEP_CNT_OVFL_INT2_EN	0x10
+#define BIT_INT_STEP_DET_INT2_EN	0x20
+#define BIT_INT_DMP_POWER_SAVE_INT2_EN	0x40
+
+/* Bank4 REG_INT_SOURCE8 */
+#define BIT_INT_AGC_RDY_IBI_EN		0x01
+#define BIT_INT_FIFO_FULL_IBI_EN	0x02
+#define BIT_INT_FIFO_THS_IBI_EN		0x04
+#define BIT_INT_UI_DRDY_IBI_EN		0x08
+#define BIT_INT_PLL_RDY_IBI_EN		0x10
+#define BIT_INT_FSYNC_IBI_EN		0x20
+#define BIT_INT_OIS1_DRDY_IBI_EN	0x40
+
+/* Bank4 REG_INT_SOURCE9 */
+#define BIT_INT_DMP_POWER_SAVE_IBI_EN	0x01
+#define BIT_INT_WOM_X_IBI_EN		0x02
+#define BIT_INT_WOM_Y_IBI_EN		0x04
+#define BIT_INT_WOM_Z_IBI_EN		0x08
+#define BIT_INT_SMD_IBI_EN		0x10
+
+/* Bank4 REG_INT_SOURCE10 */
+#define BIT_INT_TAP_DET_IBI_EN		0x01
+#define BIT_INT_HIGHG_DET_IBI_EN	0x02
+#define BIT_INT_LOWG_DET_IBI_EN		0x04
+#define BIT_INT_TILT_DET_IBI_EN		0x08
+#define BIT_INT_STEP_CNT_OVFL_IBI_EN	0x10
+#define BIT_INT_STEP_DET_IBI_EN		0x20
+
+
+/* fifo data packet header */
+#define BIT_FIFO_HEAD_MSG		0x80
+#define BIT_FIFO_HEAD_ACCEL		0x40
+#define BIT_FIFO_HEAD_GYRO		0x20
+#define BIT_FIFO_HEAD_20		0x10
+#define BIT_FIFO_HEAD_TMSP_ODR		0x08
+#define BIT_FIFO_HEAD_TMSP_NO_ODR	0x04
+#define BIT_FIFO_HEAD_TMSP_FSYNC	0x0C
+#define BIT_FIFO_HEAD_ODR_ACCEL		0x02
+#define BIT_FIFO_HEAD_ODR_GYRO		0x01
+
+/* data definitions */
+#define FIFO_PACKET_BYTE_SINGLE		8
+#define FIFO_PACKET_BYTE_6X		16
+#define FIFO_PACKET_BYTE_HIRES		20
+#define FIFO_COUNT_BYTE			2
+
+/* sensor startup time */
+#define INV_ICM42600_GYRO_START_TIME	100
+#define INV_ICM42600_ACCEL_START_TIME	50
+
+/* temperature sensor */
+/* scale by 100, 1LSB=1degC, 9447 */
+#define TEMP_SCALE			100
+/* 25 degC */
+#define TEMP_OFFSET			(25 * TEMP_SCALE)
+
+/* enum for sensor */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+#ifdef SUPPORT_RTC_MODE
+#define BASE_SAMPLE_RATE		(RTC_FREQ_HZ / 32)
+#else
+#define BASE_SAMPLE_RATE		1000
+#endif
+#define GESTURE_ACCEL_RATE		50
+#define ESI_GYRO_RATE			1000
+#define MPU_INIT_SENSOR_RATE_LNM	12	/* min Hz in LNM */
+#define MPU_INIT_SENSOR_RATE_LPM	3	/* min Hz in LPM */
+#define MAX_FIFO_PACKET_READ		16
+#define HARDWARE_FIFO_SIZE		2048
+ /* ~7/8 of hardware FIFO and a multiple of packet sizes 8/16/20 */
+#define FIFO_SIZE			1800
+#define LEFT_OVER_BYTES			128
+#define POWER_UP_TIME			100
+#define REG_UP_TIME_USEC		100
+#define IIO_BUFFER_BYTES		8
+#define REG_FIFO_COUNT_H		REG_FIFO_BYTE_COUNT1
+#define BYTES_PER_SENSOR		6
+#define BYTES_FOR_TEMP			1
+#define MAX_BATCH_FIFO_SIZE		FIFO_SIZE
+#define FIRST_DROP_SAMPLES_ACC_500HZ	20
+#define FIRST_DROP_SAMPLES_ACC_200HZ	10
+#define FIRST_DROP_SAMPLES_GYR_500HZ	20
+#define FIRST_DROP_SAMPLES_GYR_200HZ	10
+#define WOM_THRESHOLD			13 /* 1000 / 256 * 13 = 50.7mg */
+
+#define BIT_GYRO_FSR			0xE0
+#define BIT_GYRO_ODR			0x0F
+#define BIT_ACCEL_FSR			0xE0
+#define BIT_ACCEL_ODR			0x0F
+
+/*
+ * INT configurations
+ * Polarity: 0 -> Active Low, 1 -> Active High
+ * Drive circuit: 0 -> Open Drain, 1 -> Push-Pull
+ * Mode: 0 -> Pulse, 1 -> Latch
+ */
+#define INT_POLARITY			1
+#define INT_DRIVE_CIRCUIT		1
+#define INT_MODE			0
+
+#define ACC_LPM_MAX_RATE		(500)
+#define GYR_LPM_MAX_RATE		(200)
+
+typedef union {
+	unsigned char Byte;
+	struct {
+		unsigned char g_odr_change_bit:1;
+		unsigned char a_odr_change_bit:1;
+		unsigned char timestamp_bit:2;
+		unsigned char twentybits_bit:1;
+		unsigned char gyro_bit:1;
+		unsigned char accel_bit:1;
+		unsigned char msg_bit:1;
+	} bits;
+} icm406xx_fifo_header_t;
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+
+/* chip specific functions */
+struct inv_mpu_state;
+int inv_get_42600_pedometer_steps(struct inv_mpu_state *st,
+	int *ped, int *update);
+bool inv_get_apex_enabled(struct inv_mpu_state *st);
+int inv_get_apex_odr(struct inv_mpu_state *st);
+int inv_run_auth(struct inv_mpu_state *st);
+
+#endif /* #ifndef _INV_MPU_IIO_REG_42600_H_ */
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_init_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_init_42600.c
new file mode 100644
index 000000000000..2660ca5d5089
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_init_42600.c
@@ -0,0 +1,531 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_vr = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_vr = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_vr = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data;
+
+	result = inv_plat_read(st, REG_GYRO_CONFIG0, 1, &data);
+	if (result)
+		return result;
+	data &= ~BIT_GYRO_FSR;
+	if (st->chip_type == ICM42686)
+		data |= (4 - st->chip_config.fsr) << SHIFT_GYRO_FS_SEL;
+	else
+		data |= (3 - st->chip_config.fsr) << SHIFT_GYRO_FS_SEL;
+
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG0, data);
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data;
+
+	result = inv_plat_read(st, REG_ACCEL_CONFIG0, 1, &data);
+	if (result)
+		return result;
+	data &= ~BIT_ACCEL_FSR;
+	if (st->chip_type == ICM42686 || st->chip_type == ICM40609D)
+		data |= (4 - st->chip_config.accel_fs) << SHIFT_ACCEL_FS_SEL;
+	else
+		data |= (3 - st->chip_config.accel_fs) << SHIFT_ACCEL_FS_SEL;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG0, data);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	int result = 0;
+	int accel_rate;
+	int8_t val;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+
+	if (st->eng_info[ENGINE_ACCEL].divider)
+		accel_rate = 1000 / st->eng_info[ENGINE_ACCEL].divider;
+	else {
+		/* use dummy rate */
+#ifdef SUPPORT_ACCEL_LPM
+		accel_rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+		accel_rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	}
+
+	if (accel_rate > 50)
+		val = WOM_THRESHOLD / (accel_rate / 50);
+	else
+		val = WOM_THRESHOLD;
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_X_THR, val);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Y_THR, val);
+	result |= inv_plat_single_write(st, REG_ACCEL_WOM_Z_THR, val);
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_config_apex_gestures(struct inv_mpu_state *st)
+{
+	int result = 0;
+	int8_t rw;
+	int8_t mount_matrix = 0;
+	int8_t tilt_wait_time = 0x01;
+	int8_t pedo_low_energy_amp_th = 0xA;
+	int8_t pedo_amp_th_sel = 0x8;
+	int8_t pedo_step_cnt_th_sel = 0x5;
+	int8_t pedo_hi_enrgy_th_sel = 0x1;
+	int8_t pedo_sb_timer_th_sel = 0x4;
+	int8_t pedo_step_det_th_sel = 0x2;
+	int8_t pedo_sensitivity_mode = 0x0;
+	int8_t tap_tmax = 0x2;
+	int8_t tap_tmin = 0x3;
+	int8_t tap_tavg = 0x3;
+	int8_t tap_min_jerk_thr = 0x11;
+	int8_t tap_max_peak_tol = 0x1;
+	int8_t sleep_time_out = 0x4;
+	int8_t sleep_gesture_delay = 0x4;
+
+	/* mount matrix */
+	if (st->plat_data.orientation[1] && st->plat_data.orientation[3])
+		mount_matrix |= 0x04; /* swap(x,y) */
+	if (st->plat_data.orientation[0] < 0 || st->plat_data.orientation[1] < 0)
+		mount_matrix |= 0x02; /* x = -x */
+	if (st->plat_data.orientation[3] < 0 || st->plat_data.orientation[4] < 0)
+		mount_matrix |= 0x01; /* y = -y */
+
+	/* SRAM reset */
+	result = inv_plat_read(st, REG_PWR_MGMT_0, 1, &rw);
+	if (result)
+		return result;
+	result |= inv_plat_single_write(st, REG_PWR_MGMT_0, rw | BIT_IDLE);
+	usleep_range(200, 220);
+	result |= inv_plat_single_write(st, REG_SIGNAL_PATH_RESET,
+		BIT_DMP_MEM_RESET_EN);
+	usleep_range(1000, 1100);
+	result |= inv_plat_single_write(st, REG_PWR_MGMT_0, rw);
+	usleep_range(200, 220);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+
+	/* APEX_CONFIG1 */
+	result = inv_plat_read(st, REG_APEX_CONFIG1, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0x0f;
+	rw |= (pedo_low_energy_amp_th << 4) & 0xf0;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG1, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG2 */
+	rw = 0x00;
+	rw |= (pedo_amp_th_sel << 4) & 0xf0;
+	rw |= pedo_step_cnt_th_sel & 0x0f;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG2, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG2 */
+	rw = 0x00;
+	rw |= (pedo_step_det_th_sel << 5) & 0xe0;
+	rw |= (pedo_sb_timer_th_sel << 2) & 0x1c;
+	rw |= pedo_hi_enrgy_th_sel & 0x03;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG3, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG4 */
+	result = inv_plat_read(st, REG_APEX_CONFIG4, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0x07;
+	rw |= (tilt_wait_time << 6) & 0xc0;
+	rw |= (sleep_time_out << 3) & 0x38;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG4, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG5 */
+	result = inv_plat_read(st, REG_APEX_CONFIG5, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0xf8;
+	rw |= mount_matrix & 0x07;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG5, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG6 */
+	result = inv_plat_read(st, REG_APEX_CONFIG6, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0xf8;
+	rw |= sleep_gesture_delay & 0x07;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG6, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG7 */
+	rw = 0x00;
+	rw |= (tap_min_jerk_thr << 2) & 0xfc;
+	rw |= tap_max_peak_tol & 0x03;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG7, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG8 */
+	result = inv_plat_read(st, REG_APEX_CONFIG8, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0x80;
+	rw |= (tap_tmax << 5) & 0x60;
+	rw |= (tap_tmin << 3) & 0x18;
+	rw |= tap_tavg & 0x07;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG8, rw);
+	if (result)
+		goto restore_bank;
+	/* APEX_CONFIG9 */
+	result = inv_plat_read(st, REG_APEX_CONFIG9, 1, &rw);
+	if (result)
+		goto restore_bank;
+	rw &= 0xfe;
+	rw |= pedo_sensitivity_mode & 0x01;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG9, rw);
+
+restore_bank:
+	if (result)
+		pr_err("failed to access apex config register\n");
+
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+#ifdef NOT_SET_DMP_POWER_SAVE
+	result = inv_plat_single_write(st, REG_APEX_CONFIG0,
+		BIT_DMP_ODR_50HZ);
+#else
+	result = inv_plat_single_write(st, REG_APEX_CONFIG0,
+		BIT_DMP_ODR_50HZ | BIT_DMP_POWER_SAVE_EN);
+#endif
+
+	return result;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+#ifdef SUPPORT_ACCEL_LPM
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	st->sensor[SENSOR_GYRO].rate = MPU_INIT_SENSOR_RATE_LNM;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = BYTE_MODE;
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	if (st->apex_supported) {
+		res =  inv_config_apex_gestures(st);
+		if (res)
+			return res;
+	}
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_read(st, REG_CHIP_CONFIG_REG, 1, &v);
+	if (result)
+		return result;
+	v |= BIT_SOFT_RESET;
+	result = inv_plat_single_write(st, REG_CHIP_CONFIG_REG, v);
+	if (result)
+		return result;
+	msleep(100);
+
+#ifdef SUPPORT_RTC_MODE
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	result |= inv_plat_single_write(st, REG_INTF_CONFIG5,
+			BIT_PIN9_FUNC_CLKIN);
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+#endif
+
+	v = BIT_GYRO_AFSR_MODE_HFS | BIT_ACCEL_AFSR_MODE_HFS | BIT_CLK_SEL_PLL;
+#ifdef SUPPORT_RTC_MODE
+	v |= BIT_RTC_MODE;
+#endif
+	result = inv_plat_single_write(st, REG_INTF_CONFIG1, v);
+	if (result)
+		return result;
+
+	/* 215 */
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_3);
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, 0x2e, 1, &v);
+	if (result)
+		goto skip_215;
+	result = inv_plat_single_write(st, 0x2e, v & 0xfd);
+	if (result)
+		goto skip_215;
+	result = inv_plat_read(st, 0x32, 1, &v);
+	if (result)
+		goto skip_215;
+	result = inv_plat_single_write(st, 0x32, v & 0x9f);
+	if (result)
+		goto skip_215;
+	result = inv_plat_read(st, 0x37, 1, &v);
+	if (result)
+		goto skip_215;
+	result = inv_plat_single_write(st, 0x37, v & 0x9f);
+	if (result)
+		goto skip_215;
+	result = inv_plat_read(st, 0x3c, 1, &v);
+	if (result)
+		goto skip_215;
+	result = inv_plat_single_write(st, 0x3c, v & 0x9f);
+	if (result)
+		goto skip_215;
+
+skip_215:
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* enable chip timestamp */
+	v = BIT_EN_DREG_FIFO_D2A |
+		BIT_TMST_TO_REGS_EN |
+		BIT_TMST_EN;
+	result = inv_plat_single_write(st, REG_TMST_CONFIG, v);
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_INTF_CONFIG0, 1, &v);
+	if (result)
+		return result;
+	v |= st->i2c_dis;
+	result = inv_plat_single_write(st, REG_INTF_CONFIG0, v);
+	if (result)
+		return result;
+
+	v = (INT_POLARITY << SHIFT_INT1_POLARITY) |
+		(INT_DRIVE_CIRCUIT << SHIFT_INT1_DRIVE_CIRCUIT) |
+		(INT_MODE << SHIFT_INT1_MODE);
+	result = inv_plat_single_write(st, REG_INT_CONFIG_REG, v);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+        if (result)
+                return result;
+
+	if (st->bus_type == BUS_I2C)
+		v = BIT_I3C_EN;
+	else
+		v = BIT_I3C_SDR_EN | BIT_I3C_DDR_EN | BIT_I3C_EN;
+	result = inv_plat_single_write(st, REG_INTF_CONFIG6, v);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+        if (result)
+                return result;
+
+	if (st->bus_type == BUS_I2C)
+		v = BIT_SPI_SLEW_RATE_12NS | BIT_I2C_SLEW_RATE_12NS;
+	else
+		v = BIT_SPI_SLEW_RATE_2NS | BIT_I2C_SLEW_RATE_20NS;
+	result = inv_plat_single_write(st, REG_DRIVE_CONFIG, v);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_FIFO_CONFIG_REG,
+		BIT_FIFO_MODE_BYPASS);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_INT_CONFIG1, 0);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0, 0);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_misc_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_misc_42600.c
new file mode 100644
index 000000000000..43be5616c770
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_misc_42600.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2018-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/**
+ * inv_get_apex_enabled() - Check if any APEX feature is enabled
+ * @st: struct inv_mpu_state.
+ *
+ * Return: true when any is enabled, otherwise false.
+ */
+bool inv_get_apex_enabled(struct inv_mpu_state *st)
+{
+	if (!(st->apex_supported))
+		return false;
+
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on ||
+		st->step_counter_l_on ||
+		st->step_counter_wake_l_on)
+		return true;
+	if (st->chip_config.tilt_enable)
+		return true;
+	if (st->chip_config.tap_enable)
+		return true;
+	if (st->chip_config.pick_up_enable)
+		return true;
+	if (st->smd.on)
+		return true;
+
+	return false;
+}
+
+/**
+ * inv_get_apex_odr() - Get min accel ODR according to enabled APEX feature
+ * @st: struct inv_mpu_state.
+ *
+ * Return: min accel ODR in Hz
+ */
+int inv_get_apex_odr(struct inv_mpu_state *st)
+{
+	int odr_hz;
+
+#ifdef SUPPORT_ACCEL_LPM
+	odr_hz = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	odr_hz = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	if (st->apex_supported) {
+		/* returns min accel rate for each algorithm */
+		if (st->chip_config.tap_enable)
+			odr_hz = 200;
+		else if (st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->step_counter_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.tilt_enable ||
+			st->chip_config.pick_up_enable ||
+			st->smd.on)
+			odr_hz = 50;
+	}
+
+	return odr_hz;
+}
+
+/**
+ * inv_run_auth() - Run authentication
+ * @st: struct inv_mpu_state.
+ *
+ * Return: 0 when no error, otherwise errno
+ */
+int inv_run_auth(struct inv_mpu_state *st)
+{
+#define REG_SCAN0		0x71	/* bank 0 */
+#define REG_SEC_AUTH0		0x6F	/* bank 1 */
+#define REG_OTP_SEC_STATUS	0x70	/* bank 1 */
+
+	int i;
+	u8 data;
+	u8 reg_pwr_mgmt_0, reg_scan0, reg_sec_auth0;
+	int ret = 0;
+
+	pr_info("auth: start\n");
+
+	/* check variables */
+	if (st->auth_i[8] > (int)sizeof(st->auth_o) ||
+			st->auth_i[8] > (int)sizeof(st->auth_i) - 9) {
+		pr_err("auth: invalid input data\n");
+		return -EINVAL;
+	}
+
+	/* save registers */
+	ret |= inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+	ret |= inv_plat_read(st, REG_SCAN0, 1, &reg_scan0);
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	ret |= inv_plat_read(st, REG_SEC_AUTH0, 1, &reg_sec_auth0);
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	/* disable all ensors and set idle mode */
+	ret |= inv_plat_single_write(st, REG_PWR_MGMT_0, BIT_IDLE);
+	usleep_range(1000, 1200);
+
+	/* enable write access to memory from serial if */
+	ret |= inv_plat_single_write(st, REG_SCAN0,
+			0x04 /* mem_otp_access_en */ |
+			0x01 /* fifo_mem_wr_ser */);
+
+	/* enable auth mode */
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	ret |= inv_plat_single_write(st, REG_SEC_AUTH0,
+			0x02 /* sec_auth_mode=1 */);
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	/* write data to memory 1 */
+	ret |= inv_plat_single_write(st, REG_MEM_BANK_SEL, 0);
+	ret |= inv_plat_single_write(st, REG_MEM_START_ADDR, 0);
+	for (i = 0; i < 9; i++)
+		ret |= inv_plat_single_write(st, REG_MEM_R_W, st->auth_i[i]);
+
+	/* write data to memory 2 */
+	for (i = 0; i < st->auth_i[8]; i++)
+		ret |= inv_plat_single_write(st, REG_MEM_R_W, st->auth_i[9 + i]);
+
+	/* wait for a while after writing to memory */
+	usleep_range(100, 120);
+
+	/* enable read access to memory from system */
+	ret |= inv_plat_single_write(st, REG_SCAN0,
+			0x04 /* mem_otp_access_en */ |
+			0x02 /* fifo_mem_rd_sys */);
+
+	/* trigger authentication */
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	ret |= inv_plat_single_write(st, REG_SEC_AUTH0,
+			0x02 /* sec_auth_mode=1 */ |
+			0x01 /* sec_start=1 */);
+
+	/* manually reset start bit */
+	ret |= inv_plat_single_write(st, REG_SEC_AUTH0,
+			0x02 /* sec_auth_mode=1, sec_start=0 */);
+
+	/* wait for a while, 30ms should be good enough */
+	usleep_range(30 * 1000, 50 * 1000);
+
+	/* check status */
+	ret |= inv_plat_read(st, REG_OTP_SEC_STATUS, 1, &data);
+	if (!(data & 0x02 /* sec_done */)) {
+		pr_info("auth: timeout 0x%02x\n", data);
+		ret = -ETIME;
+		goto auth_done;
+	}
+	pr_info("auth: done\n");
+
+	/* enable read access to memory from system */
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	ret |= inv_plat_single_write(st, REG_SCAN0,
+			0x04 /* mem_otp_access_en */);
+
+	/* read response */
+	ret |= inv_plat_single_write(st, REG_MEM_BANK_SEL, 0);
+	for (i = 0; i < st->auth_i[8]; i++) {
+		ret |= inv_plat_single_write(st, REG_MEM_START_ADDR, i);
+		ret |= inv_plat_read(st, REG_MEM_R_W, 1, &st->auth_o[i]);
+	}
+
+auth_done:
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	/* restore settings */
+	ret |= inv_plat_single_write(st, REG_SCAN0, reg_scan0);
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	ret |= inv_plat_single_write(st, REG_SEC_AUTH0, reg_sec_auth0);
+	ret |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	ret |= inv_plat_single_write(st, REG_PWR_MGMT_0, reg_pwr_mgmt_0);
+
+	pr_info("auth: end with %d\n", ret);
+
+	return ret;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_parsing_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_parsing_42600.c
new file mode 100644
index 000000000000..0330986df485
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_parsing_42600.c
@@ -0,0 +1,582 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_check_fsync(struct inv_mpu_state *st)
+{
+	u8 data[1];
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+	inv_plat_read(st, REG_INT_STATUS, 1, data);
+	if (data[0] & BIT_INT_STATUS_UI_FSYNC) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	}
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, s32 *raw)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	s32 calib[3] = { 0, 0, 0 };
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st);
+		break;
+	case SENSOR_GYRO:
+		inv_push_gyro_data(indio_dev, raw, calib, t);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static bool inv_validate_fifo_data(s16 *lsb)
+{
+	bool ret = true;
+
+	if ((lsb[0] == -32768) && (lsb[1] == -32768) && (lsb[2] == -32768))
+		ret = false;
+
+	return ret;
+}
+
+static int inv_push_42600_data(struct iio_dev *indio_dev, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	icm406xx_fifo_header_t header;
+	s16 acc_lsb[3] = { 0, 0, 0 };
+	s16 gyr_lsb[3] = { 0, 0, 0 };
+	s32 acc[3], gyr[3];
+	bool valid_acc = false;
+	bool valid_gyr = false;
+
+	header.Byte = *d;
+
+	/* skip 1 byte header */
+	if (header.bits.msg_bit)
+		return 0;
+
+	if (header.bits.accel_bit && !header.bits.gyro_bit) {
+		/* only accel */
+		acc_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		acc_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		acc_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		valid_acc = inv_validate_fifo_data(acc_lsb);
+	} else if (!header.bits.accel_bit && header.bits.gyro_bit) {
+		/* only gyro */
+		gyr_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		gyr_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		gyr_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		valid_gyr = inv_validate_fifo_data(gyr_lsb);
+	} else if ((header.bits.accel_bit && header.bits.gyro_bit) ||
+			header.bits.twentybits_bit) {
+		/* accel and gyro */
+		acc_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		acc_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		acc_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		gyr_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[7]));
+		gyr_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[9]));
+		gyr_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[11]));
+		valid_acc = inv_validate_fifo_data(acc_lsb);
+		valid_gyr = inv_validate_fifo_data(gyr_lsb);
+	} else
+		return 0;
+
+	if (header.bits.twentybits_bit) {
+		/* high resolution mode */
+		acc[0] = (acc_lsb[0] << 4) | ((d[17] >> 4) & 0xf);
+		acc[1] = (acc_lsb[1] << 4) | ((d[18] >> 4) & 0xf);
+		acc[2] = (acc_lsb[2] << 4) | ((d[19] >> 4) & 0xf);
+		gyr[0] = (gyr_lsb[0] << 4) | (d[17] & 0xf);
+		gyr[1] = (gyr_lsb[1] << 4) | (d[18] & 0xf);
+		gyr[2] = (gyr_lsb[2] << 4) | (d[19] & 0xf);
+	} else {
+		/* normal resolution mode */
+		acc[0] = acc_lsb[0];
+		acc[1] = acc_lsb[1];
+		acc[2] = acc_lsb[2];
+		gyr[0] = gyr_lsb[0];
+		gyr[1] = gyr_lsb[1];
+		gyr[2] = gyr_lsb[2];
+	}
+
+	/* send accel data */
+	if (header.bits.accel_bit) {
+		if (st->sensor[SENSOR_ACCEL].on && valid_acc) {
+			inv_get_dmp_ts(st, SENSOR_ACCEL);
+			if (st->sensor[SENSOR_ACCEL].send &&
+					(!st->ts_algo.first_drop_samples[SENSOR_ACCEL])) {
+				st->sensor[SENSOR_ACCEL].sample_calib++;
+				inv_push_sensor(indio_dev, SENSOR_ACCEL,
+						st->sensor[SENSOR_ACCEL].ts, acc);
+			}
+			if (st->ts_algo.first_drop_samples[SENSOR_ACCEL])
+				st->ts_algo.first_drop_samples[SENSOR_ACCEL]--;
+		}
+	}
+
+	/* send gyro data */
+	if (header.bits.gyro_bit) {
+		if (st->sensor[SENSOR_GYRO].on && valid_gyr) {
+			inv_get_dmp_ts(st, SENSOR_GYRO);
+			if (st->sensor[SENSOR_GYRO].send &&
+					(!st->ts_algo.first_drop_samples[SENSOR_GYRO])) {
+				st->sensor[SENSOR_GYRO].sample_calib++;
+				inv_push_sensor(indio_dev, SENSOR_GYRO,
+						st->sensor[SENSOR_GYRO].ts, gyr);
+			}
+			if (st->ts_algo.first_drop_samples[SENSOR_GYRO])
+				st->ts_algo.first_drop_samples[SENSOR_GYRO]--;
+		}
+	}
+
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_prescan_fifo_data(struct inv_mpu_state *st, u8 *data, int len)
+{
+	int i;
+	u8 *dptr;
+	icm406xx_fifo_header_t header;
+
+	dptr = data;
+	while (dptr < (data + len)) {
+		if (st->batch.pk_size >= 8)
+			pr_debug("FIFO 0x00: %x %x %x %x %x %x %x %x\n",
+				 dptr[0], dptr[1], dptr[2], dptr[3],
+				 dptr[4], dptr[5], dptr[6], dptr[7]);
+		if (st->batch.pk_size >= 16)
+			pr_debug("FIFO 0x08: %x %x %x %x %x %x %x %x\n",
+				 dptr[8], dptr[9], dptr[10], dptr[11],
+				 dptr[12], dptr[13], dptr[14], dptr[15]);
+		if (st->batch.pk_size >= 20)
+			pr_debug("FIFO 0x10: %x %x %x %x\n",
+				 dptr[16], dptr[17], dptr[18], dptr[19]);
+		dptr += st->batch.pk_size;
+	}
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].count = 0;
+
+	dptr = data;
+	while (dptr < (data + len)) {
+		/* count the number of valid samples
+		 * in the buffer for accel and gyro
+		 */
+		header.Byte = *dptr;
+		if (header.bits.msg_bit) {
+			pr_warn("Unexpected FIFO msg bit\n");
+			return 0;
+		}
+		/* header */
+		dptr++;
+		/* accel */
+		if (header.bits.accel_bit) {
+			st->sensor[SENSOR_ACCEL].count++;
+			dptr += st->sensor[SENSOR_ACCEL].sample_size;
+		}
+		/* gyro */
+		if (header.bits.gyro_bit) {
+			st->sensor[SENSOR_GYRO].count++;
+			dptr += st->sensor[SENSOR_GYRO].sample_size;
+		}
+		/* temperature */
+		if (header.bits.twentybits_bit)
+			dptr += 2;
+		else
+			dptr += 1;
+		/* timestamp */
+		if ((header.bits.accel_bit && header.bits.gyro_bit) ||
+				header.bits.twentybits_bit)
+			dptr += 2;
+		/* high resolution data */
+		if (header.bits.twentybits_bit)
+			dptr += 3;
+	}
+
+	return 0;
+}
+
+static int inv_process_42600_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 data[2];
+	bool done_flag;
+
+	res = inv_plat_read(st, REG_INT_STATUS2, 1, data);
+	if (res)
+		return res;
+	if (st->smd.on && (data[0] & BIT_INT_STATUS_SMD)) {
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_smd");
+		st->smd.on = false;
+		st->trigger_state = EVENT_TRIGGER;
+		inv_check_sensor_on(st);
+		res = set_inv_enable(indio_dev);
+		if (res)
+			return res;
+		st->wake_sensor_received = true;
+	}
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		pr_debug("ges cnt=%d, statu=%x\n",
+			st->gesture_int_count, data[0]);
+		if (data[0] & (BIT_INT_STATUS_WOM_XYZ)) {
+			if (!st->gesture_int_count) {
+				res = inv_plat_read(st,
+					REG_INT_SOURCE0, 1, data);
+				if (res)
+					return res;
+				data[0] |= BIT_INT_UI_DRDY_INT1_EN;
+				res = inv_plat_single_write(st,
+					REG_INT_SOURCE0, data[0]);
+				if (res)
+					return res;
+				data[0] = 0;
+				if (st->chip_config.gyro_enable ||
+					st->chip_config.accel_enable)
+					data[0] |= (BIT_FIFO_ACCEL_EN |
+						BIT_FIFO_GYRO_EN |
+						BIT_FIFO_WM_TH);
+				res = inv_plat_single_write(st,
+					REG_FIFO_CONFIG1, data[0]);
+				if (res)
+					return res;
+				/*
+				 * First time wake up from WOM
+				 * we don't need data in the FIFO
+				 */
+				res = inv_reset_fifo(st, true);
+				if (res)
+					return res;
+				if (st->chip_config.stationary_detect_enable) {
+					st->gesture_int_count =
+						STATIONARY_DELAY_THRESHOLD;
+				} else {
+					st->gesture_int_count =
+						WOM_DELAY_THRESHOLD;
+				}
+				return res;
+			}
+			if (st->chip_config.stationary_detect_enable) {
+				st->gesture_int_count =
+					STATIONARY_DELAY_THRESHOLD;
+			} else {
+				st->gesture_int_count =
+					WOM_DELAY_THRESHOLD;
+			}
+		} else {
+			if (!st->gesture_int_count) {
+				res = inv_plat_single_write(st,
+					REG_FIFO_CONFIG1, 0);
+				if (res)
+					return res;
+				res = inv_plat_read(st,
+					REG_INT_SOURCE0, 1, data);
+				if (res)
+					return res;
+				data[0] &= ~BIT_INT_UI_DRDY_INT1_EN;
+				res = inv_plat_single_write(st,
+					REG_INT_SOURCE0, data[0]);
+				if (res)
+					return res;
+
+				return res;
+			}
+			st->gesture_int_count--;
+		}
+	}
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE - st->batch.pk_size) /
+				st->batch.pk_size) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n",
+			fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_DATA_REG, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+
+	dptr = d;
+	total_bytes = fifo_count;
+
+	inv_prescan_fifo_data(st, dptr, total_bytes);
+
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		pr_debug("total%d, pk=%d\n", total_bytes, pk_size);
+		if (total_bytes >= pk_size) {
+			res = inv_push_42600_data(indio_dev, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+int inv_get_42600_pedometer_steps(struct inv_mpu_state *st,
+	int *ped, int *update)
+{
+	u8 r[2];
+	uint32_t cur_step_cnt;
+	int result;
+
+	*update = false;
+	result = inv_plat_read(st,
+		REG_APEX_DATA0, 2, &r[0]);
+	if (result)
+		return result;
+
+	cur_step_cnt = (uint32_t)((r[1] << 8) | r[0]);
+	if (st->apex_data.step_reset_last_val) {
+		st->apex_data.step_reset_last_val = false;
+		st->apex_data.step_cnt_last_val = cur_step_cnt;
+	}
+	if (cur_step_cnt !=
+		st->apex_data.step_cnt_last_val) {
+		if (cur_step_cnt < st->apex_data.step_cnt_last_val) {
+			/* overflow */
+			st->apex_data.step_cnt_total +=
+				cur_step_cnt + (0xFFFF - st->apex_data.step_cnt_last_val);
+		} else {
+			st->apex_data.step_cnt_total +=
+				cur_step_cnt - st->apex_data.step_cnt_last_val;
+		}
+	}
+	st->apex_data.step_cnt_last_val = cur_step_cnt;
+	*ped = st->apex_data.step_cnt_total;
+	*update = true;
+
+	return result;
+}
+
+static int inv_process_apex_gesture(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 r[2], int_status3, apex_data4;
+	s16 s[3] = {0,};
+	u64 t;
+	uint32_t cur_step_cnt;
+	u8 tap_dir, tap_axis, tap_num;
+	int ped_update;
+	int result;
+
+	if (inv_get_apex_enabled(st)) {
+		t = get_time_ns();
+		result = inv_plat_read(st, REG_APEX_DATA4, 1, &r[0]);
+		if (result)
+			return result;
+		apex_data4 = r[0];
+		tap_dir = apex_data4 & 0x01;
+		tap_axis = (apex_data4 & 0x06) >> 1;
+		if (tap_axis > 2)
+			tap_axis = 2;
+		tap_num = (apex_data4 & 0x18) >> 3;
+		result = inv_plat_read(st, REG_INT_STATUS3, 1, &r[0]);
+		if (result)
+			return result;
+		int_status3 = r[0];
+		if (int_status3 & BIT_INT_STATUS_TILT_DET) {
+			sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_tilt");
+			st->wake_sensor_received = true;
+		}
+		if (int_status3 & BIT_INT_STATUS_RAISE_DET) {
+			sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_pick_up");
+			st->chip_config.pick_up_enable = 0;
+			inv_check_sensor_on(st);
+			set_inv_enable(indio_dev);
+			st->wake_sensor_received = true;
+		}
+		if (int_status3 & BIT_INT_STATUS_STEP_DET) {
+			if (st->step_detector_l_on) {
+				inv_push_8bytes_buffer(indio_dev,
+					STEP_DETECTOR_HDR, t, s);
+			}
+			if (st->step_detector_wake_l_on) {
+				inv_push_8bytes_buffer(indio_dev,
+					STEP_DETECTOR_WAKE_HDR, t, s);
+				st->wake_sensor_received = true;
+			}
+			if (st->ped.int_mode &&
+				(st->step_counter_l_on || st->step_counter_wake_l_on)) {
+				result = inv_get_42600_pedometer_steps(st,
+					&cur_step_cnt, &ped_update);
+				if (result)
+					return result;
+				if (ped_update)
+					inv_send_steps(indio_dev, st->apex_data.step_cnt_total, t);
+				if (st->step_counter_wake_l_on)
+					st->wake_sensor_received = true;
+			}
+		}
+		if (int_status3 & BIT_INT_STATUS_TAP_DET && tap_num == 2) {
+			s[tap_axis] = (tap_dir ? -1 : 1);
+			inv_push_8bytes_buffer(indio_dev, TAP_HDR, t, s);
+			st->wake_sensor_received = true;
+		}
+	}
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+	st->wake_sensor_received = false;
+
+	if (st->apex_supported) {
+		result = inv_process_apex_gesture(indio_dev);
+		if (result)
+			goto err_reset_fifo;
+	}
+
+	result = inv_process_42600_data(indio_dev);
+	if (result)
+		goto err_reset_fifo;
+	mutex_unlock(&st->lock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable) &&
+		(!inv_get_apex_enabled(st))) {
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable ||
+		inv_get_apex_enabled(st)) {
+		st->wake_sensor_received = false;
+		inv_process_42600_data(indio_dev);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_selftest_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_selftest_42600.c
new file mode 100644
index 000000000000..0d2e3ab27af0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_selftest_42600.c
@@ -0,0 +1,694 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+static u8 reg_backup[128];
+static u8 reg_backup_offset[9];
+static u8 reg_backup_int6;
+
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define SELF_TEST_ODR			6   /* 1000Hz */
+#define SELF_TEST_ODR_LP		7   /* 200Hz */
+#define SELF_TEST_ACC_BW_IND		BIT_ACCEL_UI_LNM_BW_10_IIR
+#define SELF_TEST_ACC_LPM_AVG		BIT_ACCEL_UI_LPM_AVG_16
+#define SELF_TEST_GYR_BW_IND		BIT_GYRO_UI_LNM_BW_10_IIR
+#define SELF_TEST_GYR_LPM_AVG		BIT_GYRO_UI_LPM_AVG_16
+#define SELF_TEST_PRECISION		1000
+#define SELF_TEST_SAMPLE_NB		200
+#define SELF_TEST_MIN_ACC_MG		50   /* mg */
+#define SELF_TEST_MAX_ACC_MG		1200 /* mg */
+#define SELF_TEST_MIN_GYR_DPS		60  /* dps */
+#define SELF_TEST_MAX_GYR_DPS		20  /* dps */
+#define SELF_TEST_ACC_SHIFT_DELTA_INF	500 /* = 0.5 */
+#define SELF_TEST_ACC_SHIFT_DELTA_SUP	1500 /* = 1.5 */
+#define SELF_TEST_GYR_SHIFT_DELTA_INF	500 /* = 0.5 */
+#define SELF_TEST_GYR_SHIFT_DELTA_SUP	1500 /* = 1.5 */
+
+#define SELF_TEST_LN_MODE		false
+#define SELF_TEST_LP_MODE		true
+#define SELF_TEST_ACC_POWER_MODE	SELF_TEST_LP_MODE /* low power mode is default */
+#define SELF_TEST_GYRO_POWER_MODE	SELF_TEST_LN_MODE /* low noise mode is default */
+
+static u8 self_test_acc_fs;		/* accel FS value to register */
+static u8 self_test_gyr_fs;		/* gyro FS value to register */
+
+static u8 acc_st_bias_scale;		/* scale to make st_bias 2g FSR */
+static u8 gyr_st_bias_scale;		/* scale to make st_bias 250dps FSR */
+
+static int self_test_min_acc;		/* pass/fail threshold for accel */
+static int self_test_max_acc;		/* pass/fail threshold for accel */
+static int self_test_min_gyr;		/* pass/fail threshold for gyro */
+static int self_test_max_gyr;		/* pass/fail threshold for gyro */
+
+static const uint16_t *SelfTestEquationGyro;	/* lookup talbe for ST_OTP */
+static const uint16_t *SelfTestEquationAccel;	/* lookup talbe for ST_OTP */
+
+static const uint16_t SelfTestEquation_2g_250dps[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static const uint16_t SelfTestEquation_16g_2000dps[256] = {
+	327, 330, 334, 337, 340, 344, 347, 351,
+	354, 358, 361, 365, 369, 372, 376, 380,
+	384, 387, 391, 395, 399, 403, 407, 411,
+	415, 419, 424, 428, 432, 437, 441, 445,
+	450, 454, 459, 463, 468, 473, 477, 482,
+	487, 492, 497, 502, 507, 512, 517, 522,
+	528, 533, 538, 544, 549, 554, 560, 566,
+	571, 577, 583, 589, 594, 600, 606, 612,
+	619, 625, 631, 637, 644, 650, 657, 663,
+	670, 677, 683, 690, 697, 704, 711, 718,
+	725, 733, 740, 747, 755, 763, 770, 778,
+	786, 793, 801, 809, 818, 826, 834, 842,
+	851, 859, 868, 877, 885, 894, 903, 912,
+	921, 931, 940, 949, 959, 968, 978, 988,
+	998, 1008, 1018, 1028, 1038, 1049, 1059, 1070,
+	1080, 1091, 1102, 1113, 1124, 1136, 1147, 1158,
+	1170, 1182, 1193, 1205, 1217, 1230, 1242, 1254,
+	1267, 1280, 1292, 1305, 1318, 1332, 1345, 1358,
+	1372, 1386, 1400, 1414, 1428, 1442, 1456, 1471,
+	1486, 1501, 1516, 1531, 1546, 1561, 1577, 1593,
+	1609, 1625, 1641, 1658, 1674, 1691, 1708, 1725,
+	1742, 1760, 1777, 1795, 1813, 1831, 1849, 1868,
+	1887, 1905, 1924, 1944, 1963, 1983, 2003, 2023,
+	2043, 2063, 2084, 2105, 2126, 2147, 2169, 2190,
+	2212, 2234, 2257, 2279, 2302, 2325, 2348, 2372,
+	2395, 2419, 2444, 2468, 2493, 2518, 2543, 2568,
+	2594, 2620, 2646, 2673, 2699, 2726, 2754, 2781,
+	2809, 2837, 2865, 2894, 2923, 2952, 2982, 3012,
+	3042, 3072, 3103, 3134, 3165, 3197, 3229, 3261,
+	3294, 3327, 3360, 3394, 3428, 3462, 3497, 3531,
+	3567, 3602, 3639, 3675, 3712, 3749, 3786, 3824,
+	3862, 3901, 3940, 3979, 4019, 4059, 4100
+};
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result, i;
+
+	/* bank 0 */
+	for (i = 0; i <= REG_SELF_TEST_CONFIG; i++) {
+		if ((i == REG_MEM_R_W) || (i == REG_FIFO_DATA_REG)) {
+			reg_backup[i] = 0;
+		} else {
+			result = inv_plat_read(st, i, 1, &reg_backup[i]);
+			if (result)
+				return result;
+		}
+	}
+
+	/* bank 4 */
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+	for (i = REG_GOS_USER0 ; i <= REG_GOS_USER8; i++) {
+		result = inv_plat_read(st, i, 1,
+				&reg_backup_offset[i - REG_GOS_USER0]);
+		if (result)
+			goto restore_bank;
+	}
+	result = inv_plat_read(st, REG_INT_SOURCE6, 1, &reg_backup_int6);
+	if (result)
+		goto restore_bank;
+
+restore_bank:
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result, i;
+
+	/* bank 0 */
+	for (i = 0; i <= REG_SELF_TEST_CONFIG; i++) {
+		if (i == REG_CHIP_CONFIG_REG ||
+			(i >= REG_TEMP_DATA0_UI && i <= REG_SIGNAL_PATH_RESET))
+			continue;
+		result = inv_plat_single_write(st, i, reg_backup[i]);
+		if (result)
+			return result;
+	}
+
+	/* bank 4 */
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+	for (i = REG_GOS_USER0 ; i <= REG_GOS_USER8; i++) {
+		result = inv_plat_single_write(st, i,
+				reg_backup_offset[i - REG_GOS_USER0]);
+		if (result)
+			goto restore_bank;
+	}
+	result = inv_plat_single_write(st, REG_INT_SOURCE6, reg_backup_int6);
+	if (result)
+		goto restore_bank;
+
+restore_bank:
+	result |= inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	return result;
+}
+
+static int inv_reset_offset_reg(struct inv_mpu_state *st)
+{
+	int result = 0;
+	u8 databuf;
+
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+	databuf = 0x00;
+	result = inv_plat_single_write(st, REG_GOS_USER0, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER1, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER2, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER3, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER4, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER5, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER6, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER7, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GOS_USER8, databuf);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+	return result;
+}
+
+static int  inv_init_selftest(struct inv_mpu_state *st,
+	int sensor, bool mode, bool lp_mode)
+{
+	int result = 0;
+	u8 databuf;
+
+	/* Disable Interrupt */
+	result = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_SOURCE1, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_SOURCE6, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (result)
+		return result;
+	/* reset offset registers */
+	result = inv_reset_offset_reg(st);
+	if (result)
+		return result;
+	/* stop FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_CONFIG_REG, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_CONFIG1, 0);
+	if (result)
+		return result;
+	/* self-test mode set */
+	databuf = 0;
+	if (mode) {
+		if (sensor == SENSOR_ACCEL) {
+			databuf |= (BIT_TEST_AX_EN |
+				BIT_TEST_AY_EN |
+				BIT_TEST_AZ_EN);
+			databuf |= BIT_SELF_TEST_REGULATOR_EN;
+		} else if (sensor == SENSOR_GYRO) {
+			databuf |= (BIT_TEST_GX_EN |
+				BIT_TEST_GY_EN |
+				BIT_TEST_GZ_EN);
+		}
+	}
+	result = inv_plat_single_write(st, REG_SELF_TEST_CONFIG, databuf);
+	if (result)
+		return result;
+	/* set rate */
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG0,
+			(self_test_gyr_fs << SHIFT_GYRO_FS_SEL) |
+			(SELF_TEST_ODR_LP << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+			(self_test_acc_fs << SHIFT_ACCEL_FS_SEL) |
+			(SELF_TEST_ODR_LP << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+	} else {
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG0,
+			(self_test_gyr_fs << SHIFT_GYRO_FS_SEL) |
+			(SELF_TEST_ODR << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+			(self_test_acc_fs << SHIFT_ACCEL_FS_SEL) |
+			(SELF_TEST_ODR << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+	}
+	/* set filter */
+	databuf = 0;
+	if (sensor == SENSOR_ACCEL) {
+		if (lp_mode) {
+			result = inv_plat_single_write(st, REG_ACCEL_CONFIG1, 0x05);
+			if (result)
+				return result;
+			databuf |= SELF_TEST_ACC_LPM_AVG;
+		} else {
+			result = inv_plat_single_write(st, REG_ACCEL_CONFIG1, 0x10);
+			if (result)
+				return result;
+			databuf |= SELF_TEST_ACC_BW_IND;
+		}
+	} else if (sensor == SENSOR_GYRO) {
+		if (lp_mode) {
+			result = inv_plat_single_write(st, REG_GYRO_CONFIG1, 0x02);
+			if (result)
+				return result;
+			databuf |= SELF_TEST_GYR_LPM_AVG;
+		} else {
+			result = inv_plat_single_write(st, REG_GYRO_CONFIG1, 0x08);
+			if (result)
+				return result;
+			databuf |= SELF_TEST_GYR_BW_IND;
+		}
+	}
+	result = inv_plat_single_write(st, REG_GYRO_ACCEL_CONFIG0, databuf);
+	if (result)
+		return result;
+	/* turn on sensors */
+	databuf = 0;
+	if (sensor == SENSOR_ACCEL) {
+		if (lp_mode)
+			databuf |= BIT_ACCEL_MODE_LPM;
+		else
+			databuf |= BIT_ACCEL_MODE_LNM;
+	} else if (sensor == SENSOR_GYRO) {
+		if (lp_mode)
+			databuf |= BIT_GYRO_MODE_LPM;
+		else
+			databuf |= BIT_GYRO_MODE_LNM;
+	}
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0, databuf);
+	if (result)
+		return result;
+	msleep(200);
+	return result;
+}
+
+static int inv_accel_calc_avg_with_samples(struct inv_mpu_state *st,
+	int avg[3], int count, bool lp_mode)
+{
+	int result = 0;
+	int i, nAxis;
+	u8 sensor_data[6];
+	s32 sum[3] = { 0, 0, 0 };
+
+	for (i = 0; i < count; i++) {
+		result = inv_plat_read(st, REG_ACCEL_DATA_X0_UI,
+			6, sensor_data);
+		if (result)
+			return result;
+		/*	convert 8-bit to 16-bit */
+		for (nAxis = 0; nAxis < 3; nAxis++) {
+			sum[nAxis] +=
+				(s16) be16_to_cpup((__be16 *) (&sensor_data[nAxis*2]));
+		}
+		if (lp_mode) {
+			/* data register updated @200hz */
+			usleep_range(5000, 5001);
+		} else {
+			/* data register updated @1khz */
+			usleep_range(1000, 1001);
+		}
+	}
+	for (nAxis = 0; nAxis < 3; nAxis++)
+		avg[nAxis] = (int)(sum[nAxis] / count * SELF_TEST_PRECISION);
+	return result;
+}
+
+static int inv_gyro_calc_avg_with_samples(struct inv_mpu_state *st,
+	int avg[3], int count, bool lp_mode)
+{
+	int result = 0;
+	int i, nAxis;
+	u8 sensor_data[6];
+	s32 sum[3] = { 0, 0, 0 };
+
+	for (i = 0; i < count; i++) {
+		result = inv_plat_read(st, REG_GYRO_DATA_X0_UI, 6, sensor_data);
+		if (result)
+			return result;
+		/*	convert 8-bit to 16-bit */
+		for (nAxis = 0; nAxis < 3; nAxis++) {
+			sum[nAxis] +=
+				(s16) be16_to_cpup((__be16 *) (&sensor_data[nAxis*2]));
+		}
+		if (lp_mode) {
+			/* data register updated @200hz */
+			usleep_range(5000, 5001);
+		} else {
+			/* data register updated @1khz */
+			usleep_range(1000, 1001);
+		}
+	}
+	for (nAxis = 0; nAxis < 3; nAxis++)
+		avg[nAxis] = (int)(sum[nAxis] / count * SELF_TEST_PRECISION);
+	return result;
+}
+
+static uint16_t inv_accel_do_selftest(struct inv_mpu_state *st,
+	int *accel_result, bool lp_mode)
+{
+	u16 ret = 0;
+	u8 reg_data = 0x0;
+	int lsb[3] = {0}, lsb_st[3] = {0}, lsb_lp[3] = {0};
+	int st_otp[3];
+	u8 otp_st_data_acc[3];
+	bool pass = true;
+	bool otp_value_zero = false;
+	int i;
+	int st_res;
+
+	ret = inv_init_selftest(st, SENSOR_ACCEL, false, false);
+	if (ret)
+		return ret;
+	ret = inv_accel_calc_avg_with_samples(st, lsb,
+		SELF_TEST_SAMPLE_NB, false);
+	if (ret)
+		return ret;
+	if (lp_mode) {
+		ret = inv_init_selftest(st, SENSOR_ACCEL, false, true);
+		if (ret)
+			return ret;
+		ret = inv_accel_calc_avg_with_samples(st, lsb_lp,
+			SELF_TEST_SAMPLE_NB, true);
+		if (ret)
+			return ret;
+		for (i = 0 ; i < 3 ; i++)
+			accel_result[i] = lsb_lp[i];
+	} else {
+		for (i = 0 ; i < 3 ; i++)
+			accel_result[i] = lsb[i];
+	}
+	ret = inv_init_selftest(st, SENSOR_ACCEL, true, false);
+	if (ret)
+		return ret;
+	/* wait 20ms for oscillations to stabilize */
+	msleep(20);
+	ret = inv_accel_calc_avg_with_samples(st, lsb_st,
+		SELF_TEST_SAMPLE_NB, false);
+	if (ret)
+		return ret;
+	/* set selftest off */
+	reg_data = 0x00;
+	ret = inv_plat_single_write(st, REG_SELF_TEST_CONFIG, reg_data);
+	if (ret)
+		return ret;
+	/* wait 20ms for oscillations to stabilize */
+	msleep(20);
+	/* read OTP */
+	ret = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_2);
+	if (ret)
+		return ret;
+	ret = inv_plat_read(st, REG_XA_ST_DATA, 3, otp_st_data_acc);
+	if (ret)
+		return ret;
+	ret = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (ret)
+		return ret;
+	/* calculate ST results OTP based on the equation */
+	for (i = 0; i < 3; i++) {
+		if (otp_st_data_acc[i] != 0)
+			st_otp[i] = SelfTestEquationAccel[otp_st_data_acc[i] - 1];
+		else
+			otp_value_zero = true;
+	}
+	if (!otp_value_zero) {
+		/* criteria a */
+		for (i = 0; i < 3; i++) {
+			st_res = lsb_st[i] - lsb[i];
+			if (st_res <= st_otp[i] * SELF_TEST_ACC_SHIFT_DELTA_INF ||
+			    st_res >= st_otp[i] * SELF_TEST_ACC_SHIFT_DELTA_SUP) {
+				pr_warn("error accel[%d] : st_res = %d, st_otp = %d\n",
+					i, st_res, st_otp[i]);
+				pass = false;
+			}
+		}
+	} else {
+		/* criteria b */
+		for (i = 0; i < 3; i++) {
+			st_res = abs(lsb_st[i] - lsb[i]);
+			if (st_res < self_test_min_acc ||
+				st_res > self_test_max_acc) {
+				pr_warn("error accel[%d] : st_res = %d, min = %d, max = %d\n",
+					i, st_res,
+					self_test_min_acc,
+					self_test_max_acc);
+				pass = false;
+			}
+		}
+	}
+	return !pass;
+}
+
+static uint16_t inv_gyro_do_selftest(struct inv_mpu_state *st,
+	int *gyro_result, bool lp_mode)
+{
+	u16 ret = 0;
+	u8 reg_data = 0x0;
+	int lsb[3] = {0}, lsb_st[3] = {0}, lsb_lp[3] = {0};
+	u8 otp_st_data_gyro[3];
+	int st_otp[3];
+	bool pass = true;
+	bool otp_value_zero = false;
+	int i;
+	int st_res, gyro_bias;
+
+	ret = inv_init_selftest(st, SENSOR_GYRO, false, false);
+	if (ret)
+		return ret;
+	ret = inv_gyro_calc_avg_with_samples(st, lsb,
+		SELF_TEST_SAMPLE_NB, false);
+	if (ret)
+		return ret;
+	if (lp_mode) {
+		ret = inv_init_selftest(st, SENSOR_GYRO, false, true);
+		if (ret)
+			return ret;
+		ret = inv_gyro_calc_avg_with_samples(st, lsb_lp,
+			SELF_TEST_SAMPLE_NB, true);
+		if (ret)
+			return ret;
+		for (i = 0 ; i < 3 ; i++)
+			gyro_result[i] = lsb_lp[i];
+	} else {
+		for (i = 0 ; i < 3 ; i++)
+			gyro_result[i] = lsb[i];
+	}
+	ret = inv_init_selftest(st, SENSOR_GYRO, true, false);
+	if (ret)
+		return ret;
+	/* wait 20ms for oscillations to stabilize */
+	msleep(20);
+	/* Read 200 Samples with selftest on */
+	ret = inv_gyro_calc_avg_with_samples(st, lsb_st,
+		SELF_TEST_SAMPLE_NB, false);
+	if (ret)
+		return ret;
+	/* set selftest off */
+	reg_data = 0x00;
+	ret = inv_plat_single_write(st, REG_SELF_TEST_CONFIG, reg_data);
+	if (ret)
+		return ret;
+	/* wait 20ms for oscillations to stabilize */
+	msleep(20);
+	/* read OTP */
+	ret = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_1);
+	if (ret)
+		return ret;
+	ret = inv_plat_read(st, REG_XG_ST_DATA, 3, otp_st_data_gyro);
+	if (ret)
+		return ret;
+	ret = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	if (ret)
+		return ret;
+	/* calculate ST_OTP */
+	for (i = 0; i < 3; i++) {
+		if (otp_st_data_gyro[i] != 0)
+			st_otp[i] = SelfTestEquationGyro[otp_st_data_gyro[i] - 1];
+		else
+			otp_value_zero = true;
+	}
+	if (!otp_value_zero) {
+		/* criteria a */
+		for (i = 0; i < 3; i++) {
+			st_res = lsb_st[i] - lsb[i];
+			if (st_res <= st_otp[i] * SELF_TEST_GYR_SHIFT_DELTA_INF ||
+			    st_res >= st_otp[i] * SELF_TEST_GYR_SHIFT_DELTA_SUP) {
+				pr_warn("error gyro[%d] : st_res = %d, st_otp = %d\n",
+					i, st_res, st_otp[i]);
+				pass = false;
+			}
+		}
+	} else {
+		/* criteria b */
+		for (i = 0; i < 3; i++) {
+			st_res = abs(lsb_st[i] - lsb[i]);
+			if (st_res < self_test_min_gyr) {
+				pr_warn("error gyro[%d] : st_res = %d, min = %d\n",
+					i, st_res, self_test_min_gyr);
+				pass = false;
+			}
+		}
+	}
+	if (pass) {
+		/* criteria c */
+		for (i = 0; i < 3; i++) {
+			gyro_bias = abs(lsb[i]);
+			if (gyro_bias > self_test_max_gyr) {
+				pr_warn("error gyro[%d] = %d, max = %d\n",
+					i, gyro_bias, self_test_max_gyr);
+				pass = false;
+			}
+		}
+	}
+	return !pass;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias[3] = {0};
+	int accel_bias[3] = {0};
+	int accel_result = 0;
+	int gyro_result = 0;
+	int i;
+	int mg_to_lsb, dps_to_lsb;
+
+	/* fsr and scaling for self-test */
+	if (st->chip_type == ICM42686) {
+		self_test_acc_fs = 4; /* 2g */
+		self_test_gyr_fs = 4; /* 250dps */
+		mg_to_lsb = (32768 / (32 >> self_test_acc_fs) / 1000);
+		dps_to_lsb = (32768 / (4000 >> self_test_gyr_fs));
+		SelfTestEquationGyro = SelfTestEquation_2g_250dps;
+		SelfTestEquationAccel = SelfTestEquation_2g_250dps;
+		acc_st_bias_scale = 1;
+		gyr_st_bias_scale = 1;
+	} else if (st->chip_type == ICM40609D) {
+		self_test_acc_fs = 1; /* 16g */
+		self_test_gyr_fs = 3; /* 250dps */
+		mg_to_lsb = (32768 / (32 >> self_test_acc_fs) / 1000);
+		dps_to_lsb = (32768 / (2000 >> self_test_gyr_fs));
+		SelfTestEquationGyro = SelfTestEquation_2g_250dps;
+		SelfTestEquationAccel = SelfTestEquation_16g_2000dps;
+		acc_st_bias_scale = 8; /* 16g / 2g */
+		gyr_st_bias_scale = 1;
+	} else {
+		self_test_acc_fs = 3; /* 2g */
+		self_test_gyr_fs = 3; /* 250dps */
+		mg_to_lsb = (32768 / (16 >> self_test_acc_fs) / 1000);
+		dps_to_lsb = (32768 / (2000 >> self_test_gyr_fs));
+		SelfTestEquationGyro = SelfTestEquation_2g_250dps;
+		SelfTestEquationAccel = SelfTestEquation_2g_250dps;
+		acc_st_bias_scale = 1;
+		gyr_st_bias_scale = 1;
+	}
+
+	/* min/max threshold for self-test */
+	self_test_min_acc = SELF_TEST_MIN_ACC_MG * mg_to_lsb * SELF_TEST_PRECISION;
+	self_test_max_acc = SELF_TEST_MAX_ACC_MG * mg_to_lsb * SELF_TEST_PRECISION;
+	self_test_min_gyr = SELF_TEST_MIN_GYR_DPS * dps_to_lsb * SELF_TEST_PRECISION;
+	self_test_max_gyr = SELF_TEST_MAX_GYR_DPS * dps_to_lsb * SELF_TEST_PRECISION;
+
+	result = inv_save_setting(st);
+	if (result)
+		goto test_fail;
+	result = inv_accel_do_selftest(st, accel_bias, SELF_TEST_ACC_POWER_MODE);
+	if (!result) {
+		/* pass */
+		accel_result = 1;
+		/* output bias (LSB at 2g FSR) */
+		for (i = 0; i < 3; i++)
+			st->accel_st_bias[i] =
+				accel_bias[i] * acc_st_bias_scale / SELF_TEST_PRECISION;
+	}
+	result = inv_gyro_do_selftest(st, gyro_bias, SELF_TEST_GYRO_POWER_MODE);
+	if (!result) {
+		/* pass */
+		gyro_result = 1;
+		/* output bias (LSB at 250dps FSR) */
+		for (i = 0; i < 3; i++)
+			st->gyro_st_bias[i] =
+				gyro_bias[i] * gyr_st_bias_scale / SELF_TEST_PRECISION;
+	}
+test_fail:
+	inv_recover_setting(st);
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_setup_42600.c b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_setup_42600.c
new file mode 100644
index 000000000000..0ac4338f4168
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm42600/inv_mpu_setup_42600.c
@@ -0,0 +1,837 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_get_actual_duration(int rate)
+{
+	int duration_ns;
+
+	if (rate > 500)
+		duration_ns = 1000000;
+	else if (rate > 200)
+		duration_ns = 2000000;
+	else if (rate > 100)
+		duration_ns = 5000000;
+	else if (rate > 50)
+		duration_ns = 10000000;
+	else if (rate > 25)
+		duration_ns = 20000000;
+	else if (rate > 12)
+		duration_ns = 40000000;
+	else if (rate > 6)
+		duration_ns = 80000000;
+	else if (rate > 3)
+		duration_ns = 160000000;
+	else
+		duration_ns = 320000000;
+
+	return duration_ns;
+}
+
+static int inv_calc_engine_dur(struct inv_mpu_state *st,
+				struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+int inv_turn_off_fifo(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st,
+		REG_FIFO_CONFIG_REG, BIT_FIFO_MODE_BYPASS);
+	if (res)
+		return res;
+
+	return 0;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 int0_en, int1_en, fifo_en, smd;
+	u8 int6_en;
+	uint8_t burst_read[3];
+	int r;
+
+	r = inv_plat_single_write(st,
+		REG_FIFO_CONFIG_REG, BIT_FIFO_MODE_BYPASS);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_CONFIG1, 0);
+	if (r)
+		return r;
+	r = inv_plat_read(st, REG_FIFO_BYTE_COUNT1, 2, burst_read);
+	if (r)
+		return r;
+	r = inv_plat_read(st, REG_FIFO_DATA_REG, 3, burst_read);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st,
+		REG_FIFO_CONFIG_REG, BIT_FIFO_MODE_STREAM);
+	if (r)
+		return r;
+	int0_en = 0;
+	int1_en = 0;
+	smd = 0;
+	if (inv_get_apex_enabled(st)) {
+		/* for saving power when apex gesture is enabled */
+		smd |= BIT_WOM_INT_MODE_AND |
+			BIT_WOM_MODE_PREV |
+			BIT_SMD_MODE_OLD;
+	}
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		if (st->chip_config.stationary_detect_enable)
+			st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+		else
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		int1_en |= BIT_INT_WOM_XYZ_INT1_EN;
+		smd = BIT_WOM_INT_MODE_AND |
+			BIT_WOM_MODE_PREV |
+			BIT_SMD_MODE_OLD;
+	}
+	if (st->smd.on && st->smd_supported) {
+		int1_en |= BIT_INT_SMD_INT1_EN;
+		smd |= BIT_WOM_INT_MODE_AND |
+			BIT_WOM_MODE_PREV |
+			BIT_SMD_MODE_LONG;
+	}
+	if (smd) {
+		r = inv_set_accel_intel(st);
+		if (r)
+			return r;
+	}
+	if (st->sensor[SENSOR_GYRO].on ||
+		st->sensor[SENSOR_ACCEL].on) {
+		if (st->batch.timeout) {
+			if (!st->batch.fifo_wm_th)
+				int0_en = BIT_INT_UI_DRDY_INT1_EN;
+			else
+				int0_en = BIT_INT_FIFO_THS_INT1_EN |
+				BIT_INT_FIFO_FULL_INT1_EN;
+		} else {
+			int0_en = BIT_INT_UI_DRDY_INT1_EN;
+			if (st->chip_config.eis_enable)
+				int0_en |= BIT_INT_UI_FSYNC_INT1_EN;
+		}
+	}
+	fifo_en = 0;
+	if (st->sensor[SENSOR_GYRO].on ||
+		st->sensor[SENSOR_ACCEL].on) {
+		fifo_en |= (BIT_FIFO_ACCEL_EN |
+		BIT_FIFO_GYRO_EN |
+		BIT_FIFO_WM_TH);
+		if (st->chip_config.high_res_mode)
+			fifo_en |= BIT_FIFO_HIRES_EN;
+	}
+	r = inv_plat_single_write(st, REG_FIFO_CONFIG1, fifo_en);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_SOURCE0, int0_en);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_SOURCE1, int1_en);
+	if (r)
+		return r;
+	int6_en = 0;
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on ||
+		st->step_counter_wake_l_on ||
+		(st->step_counter_l_on && st->ped.int_mode))
+		int6_en |= BIT_INT_STEP_DET_INT1_EN;
+	if (st->chip_config.tilt_enable)
+		int6_en |= BIT_INT_TILT_DET_INT1_EN;
+	if (st->chip_config.tap_enable)
+		int6_en |= BIT_INT_TAP_DET_INT1_EN;
+	if (st->chip_config.pick_up_enable)
+		int6_en |= BIT_INT_RAISE_DET_INT1_EN;
+	/* enable apex gesture interrupt */
+	if (int6_en) {
+		r = inv_plat_single_write(st,
+			REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+		if (r)
+			return r;
+		r = inv_plat_single_write(st, REG_INT_SOURCE6, int6_en);
+		if (r)
+			return r;
+		r = inv_plat_single_write(st,
+			REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+	}
+	r = inv_plat_single_write(st, REG_SMD_CONFIG, smd);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int accel_rate, gyro_rate;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	accel_rate = 1000 / st->eng_info[ENGINE_ACCEL].divider;
+	gyro_rate = 1000 / st->eng_info[ENGINE_GYRO].divider;
+
+	if (accel_rate >= 500)
+		ts_algo->first_drop_samples[SENSOR_ACCEL] =
+			FIRST_DROP_SAMPLES_ACC_500HZ;
+	else if (accel_rate >= 200)
+		ts_algo->first_drop_samples[SENSOR_ACCEL] =
+			FIRST_DROP_SAMPLES_ACC_200HZ;
+	else
+		ts_algo->first_drop_samples[SENSOR_ACCEL] = 1;
+
+	if (gyro_rate >= 500)
+		ts_algo->first_drop_samples[SENSOR_GYRO] =
+			FIRST_DROP_SAMPLES_GYR_500HZ;
+	else if (gyro_rate >= 200)
+		ts_algo->first_drop_samples[SENSOR_GYRO] =
+			FIRST_DROP_SAMPLES_GYR_200HZ;
+	else
+		ts_algo->first_drop_samples[SENSOR_GYRO] = 1;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int r;
+	unsigned int wait_ms;
+	int accel_rate, gyro_rate;
+
+	accel_rate = 1000 / st->eng_info[ENGINE_ACCEL].divider;
+	gyro_rate = 1000 / st->eng_info[ENGINE_GYRO].divider;
+	r = inv_plat_read(st, REG_PWR_MGMT_0, 1, &v);
+	if (r)
+		return r;
+	w = v & ~(BIT_GYRO_MODE_LNM|BIT_ACCEL_MODE_LNM);
+	if (st->chip_config.gyro_enable) {
+		/* gyro support low noise mode only */
+		w |= BIT_GYRO_MODE_LNM;
+	}
+	if (st->chip_config.accel_enable ||
+		inv_get_apex_enabled(st)) {
+#ifdef SUPPORT_ACCEL_LPM
+		if (accel_rate > ACC_LPM_MAX_RATE)
+			w |= BIT_ACCEL_MODE_LNM;
+		else
+			w |= BIT_ACCEL_MODE_LPM;
+#else
+		w |= BIT_ACCEL_MODE_LNM;
+#endif
+	}
+	r = inv_plat_single_write(st, REG_PWR_MGMT_0, w);
+	if (r)
+		return r;
+	usleep_range(1000, 1001);
+	wait_ms = 0;
+	if (st->chip_config.gyro_enable && !(v & BIT_GYRO_MODE_LNM))
+		wait_ms = INV_ICM42600_GYRO_START_TIME;
+	if ((v & BIT_GYRO_MODE_LNM) && !st->chip_config.gyro_enable) {
+		if (wait_ms < 150)
+			wait_ms = 150;
+	}
+	if ((st->chip_config.accel_enable || inv_get_apex_enabled(st)) &&
+		!(v & BIT_ACCEL_MODE_LNM)) {
+		if (wait_ms < INV_ICM42600_ACCEL_START_TIME)
+			wait_ms = INV_ICM42600_ACCEL_START_TIME;
+	}
+	if (wait_ms)
+		msleep(wait_ms);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur;
+			st->sensor[i].div = 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st)
+{
+	u8 ga_cfg0, g_cfg1, a_cfg1;
+	int accel_rate, gyro_rate;
+	int result = 0;
+
+	ga_cfg0 = 0;
+	a_cfg1 = BIT_ACC_UI_FILT_ODR_IND_3 | BIT_ACC_DEC2_M2_ORD_3;
+	g_cfg1 = BIT_TEMP_FILT_BW_BYPASS | BIT_GYR_UI_FILT_ORD_IND_3 |
+		BIT_GYR_DEC2_M2_ORD_3;
+	accel_rate = 1000 / st->eng_info[ENGINE_ACCEL].divider;
+	/* filter needs to be matched with HAL rate */
+	if (accel_rate < 25) {
+		if (st->sensor_l[SENSOR_L_ACCEL].on) {
+			accel_rate =
+				min(accel_rate,
+				st->sensor_l[SENSOR_L_ACCEL].rate);
+		}
+		if (st->sensor_l[SENSOR_L_ACCEL_WAKE].on) {
+			accel_rate =
+				min(accel_rate,
+				st->sensor_l[SENSOR_L_ACCEL_WAKE].rate);
+		}
+	}
+	gyro_rate = 1000 / st->eng_info[ENGINE_GYRO].divider;
+#ifdef SUPPORT_ACCEL_LPM
+	if (accel_rate > ACC_LPM_MAX_RATE) {
+		ga_cfg0 |= BIT_ACCEL_UI_LNM_BW_2_FIR;
+	} else {
+		if (inv_get_apex_enabled(st) &&
+			!st->chip_config.accel_enable &&
+			!st->gesture_only_on) {
+			/* for saving power when apex gesture is enabled */
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_1;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		} else if (accel_rate <= 6) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_128;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_1KHZ;
+		} else if (accel_rate <= 12) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_64;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_1KHZ;
+		} else if (accel_rate <= 25) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_32;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_1KHZ;
+		} else if (accel_rate <= 50) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_128;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		} else if (accel_rate <= 100) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_64;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		} else if (accel_rate <= 200) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_16;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		} else if (accel_rate <= 500) {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_4;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		} else {
+			ga_cfg0 |= BIT_ACCEL_UI_LPM_AVG_1;
+			a_cfg1 |= BIT_ACC_AVG_FLT_RATE_8KHZ;
+		}
+	}
+#else /* SUPPORT_ACCEL_LPM */
+	ga_cfg0 |= BIT_ACCEL_UI_LNM_BW_2_FIR;
+#endif
+	ga_cfg0 |= BIT_GYRO_UI_LNM_BW_2_FIR;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG1, g_cfg1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG1, a_cfg1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_ACCEL_CONFIG0, ga_cfg0);
+
+	return result;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	u8 databuf;
+	int result;
+
+	result = inv_plat_read(st, REG_ACCEL_CONFIG0, 1, &databuf);
+	if (result)
+		return result;
+	databuf &= ~BIT_ACCEL_ODR;
+	if ((1000 / (a_d + 1)) > 500)
+		databuf |= BIT_ACCEL_ODR_1000;
+	else if ((1000 / (a_d + 1)) > 200)
+		databuf |= BIT_ACCEL_ODR_500;
+	else if ((1000 / (a_d + 1)) > 100)
+		databuf |= BIT_ACCEL_ODR_200;
+	else if ((1000 / (a_d + 1)) > 50)
+		databuf |= BIT_ACCEL_ODR_100;
+	else if ((1000 / (a_d + 1)) > 25)
+		databuf |= BIT_ACCEL_ODR_50;
+	else if ((1000 / (a_d + 1)) > 12)
+		databuf |= BIT_ACCEL_ODR_25;
+	else if ((1000 / (a_d + 1)) > 6)
+		databuf |= BIT_ACCEL_ODR_12;
+	else {
+#ifdef SUPPORT_ACCEL_LPM
+		/* low power mode */
+		if ((1000 / (a_d + 1)) > 3)
+			databuf |= BIT_ACCEL_ODR_6;
+		else
+			databuf |= BIT_ACCEL_ODR_3;
+#else
+		/* low noise mode */
+		databuf |= BIT_ACCEL_ODR_12;
+#endif
+	}
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG0, databuf);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG0, 1, &databuf);
+	if (result)
+		return result;
+	databuf &= ~BIT_GYRO_ODR;
+	if ((1000 / (g_d + 1)) > 500)
+		databuf |= BIT_GYRO_ODR_1000;
+	else if ((1000 / (g_d + 1)) > 200)
+		databuf |= BIT_GYRO_ODR_500;
+	else if ((1000 / (g_d + 1)) > 100)
+		databuf |= BIT_GYRO_ODR_200;
+	else if ((1000 / (g_d + 1)) > 50)
+		databuf |= BIT_GYRO_ODR_100;
+	else if ((1000 / (g_d + 1)) > 25)
+		databuf |= BIT_GYRO_ODR_50;
+	else if ((1000 / (g_d + 1)) > 12)
+		databuf |= BIT_GYRO_ODR_25;
+	else
+		databuf |= BIT_GYRO_ODR_12;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG0, databuf);
+	if (result)
+		return result;
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+	int res = 0;
+	u32 w;
+	u32 running_rate;
+
+	if (st->sensor[SENSOR_ACCEL].on || st->sensor[SENSOR_GYRO].on) {
+		if (st->chip_config.high_res_mode)
+			st->batch.pk_size = 20;
+		else
+			st->batch.pk_size = 16;
+	} else
+		st->batch.pk_size = 0;
+	if (st->sensor[SENSOR_GYRO].on && !st->sensor[SENSOR_ACCEL].on)
+		running_rate = st->eng_info[ENGINE_GYRO].running_rate;
+	else if (!st->sensor[SENSOR_GYRO].on && st->sensor[SENSOR_ACCEL].on)
+		running_rate = st->eng_info[ENGINE_ACCEL].running_rate;
+	else
+		running_rate = st->eng_info[ENGINE_GYRO].running_rate;
+	if (st->batch.timeout) {
+		w = st->batch.timeout * running_rate
+					* st->batch.pk_size / 1000;
+		if (w > MAX_BATCH_FIFO_SIZE)
+			w = MAX_BATCH_FIFO_SIZE;
+	} else {
+		w = 0;
+	}
+	st->batch.fifo_wm_th = w;
+	pr_debug("running= %d, pksize=%d, to=%d w=%d\n",
+		running_rate, st->batch.pk_size, st->batch.timeout, w);
+
+	res = inv_plat_single_write(st, REG_FIFO_CONFIG2, w & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_FIFO_CONFIG3, (w >> 8) & 0xff);
+
+	return res;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st);
+	if (result)
+		return result;
+
+	inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_enable_apex_gestures(struct inv_mpu_state *st)
+{
+	int result;
+	u8 w, r;
+	u8 pwr_mgmt;
+	unsigned int wait_ms = 0;
+
+	result = inv_plat_read(st, REG_APEX_CONFIG0, 1, &r);
+	if (result)
+		return result;
+
+#ifdef NOT_SET_DMP_POWER_SAVE
+	w = BIT_DMP_ODR_50HZ;
+#else
+	w = BIT_DMP_POWER_SAVE_EN | BIT_DMP_ODR_50HZ;
+#endif
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on ||
+		st->step_counter_l_on ||
+		st->step_counter_wake_l_on)
+		w |= BIT_PEDO_ENABLE;
+	if (st->chip_config.tilt_enable)
+		w |= BIT_TILT_ENABLE;
+	if (st->chip_config.tap_enable)
+		w |= BIT_TAP_ENABLE;
+	if (st->chip_config.pick_up_enable)
+		w |= BIT_RAISE_ENABLE;
+
+	if (r != w) {
+		if (!(r & BIT_PEDO_ENABLE) && (w & BIT_PEDO_ENABLE))
+			wait_ms = 50;
+		if (!(r & (BIT_PEDO_ENABLE | BIT_TILT_ENABLE | BIT_RAISE_ENABLE)) &&
+				(w & (BIT_PEDO_ENABLE | BIT_TILT_ENABLE | BIT_RAISE_ENABLE))) {
+			result = inv_plat_single_write(st, REG_SIGNAL_PATH_RESET, BIT_DMP_INIT_EN);
+			if (result)
+				return result;
+			msleep(50);
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0, w);
+			if (result)
+				return result;
+			if (wait_ms)
+				msleep(wait_ms);
+		} else if (!(w & (BIT_PEDO_ENABLE | BIT_TILT_ENABLE | BIT_RAISE_ENABLE))) {
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0, w);
+			if (result)
+				return result;
+			/* SRAM reset */
+			result = inv_plat_read(st, REG_PWR_MGMT_0, 1, &pwr_mgmt);
+			if (result)
+				return result;
+			result |= inv_plat_single_write(st, REG_PWR_MGMT_0, pwr_mgmt | BIT_IDLE);
+			usleep_range(200, 220);
+			result |= inv_plat_single_write(st, REG_SIGNAL_PATH_RESET,
+				BIT_DMP_MEM_RESET_EN);
+			usleep_range(1000, 1100);
+			result |= inv_plat_single_write(st, REG_PWR_MGMT_0, pwr_mgmt);
+			usleep_range(200, 220);
+			if (result)
+				return result;
+		} else {
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0, w);
+			if (result)
+				return result;
+			if (wait_ms)
+				msleep(wait_ms);
+		}
+
+		if (!(r & BIT_PEDO_ENABLE) && (w & BIT_PEDO_ENABLE))
+			st->apex_data.step_reset_last_val = true;
+		else
+			st->apex_data.step_reset_last_val = false;
+	}
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	gyro_rate = MPU_INIT_SENSOR_RATE_LNM;
+#ifdef SUPPORT_ACCEL_LPM
+	accel_rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	accel_rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	/*
+	 * loop the streaming sensors to see which engine needs to be turned on
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	if (g_en)
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	else
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+
+	/* engine divider for pressure and compass is set later */
+	if (st->chip_config.eis_enable) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		/* need to update rate and div for 1khz mode */
+		for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+					    ((BASE_SAMPLE_RATE /
+						 st->eng_info[ENGINE_GYRO].divider) /
+						 st->sensor_l[i].rate);
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider =
+			inv_get_actual_duration(st->eng_info[ENGINE_GYRO].running_rate) / 1000000;
+		st->eng_info[ENGINE_ACCEL].divider =
+			inv_get_actual_duration(st->eng_info[ENGINE_ACCEL].running_rate) / 1000000;
+	}
+
+	for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 w;
+
+	inv_stop_interrupt(st);
+	inv_turn_off_fifo(st);
+	inv_determine_engine(st);
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	/* enable chip timestamp */
+	w = BIT_EN_DREG_FIFO_D2A |
+		BIT_TMST_TO_REGS_EN |
+		BIT_TMST_EN;
+	result = inv_plat_single_write(st, REG_TMST_CONFIG, w);
+	if (result)
+		return result;
+
+	w = BIT_GYRO_AFSR_MODE_HFS |
+		BIT_ACCEL_AFSR_MODE_HFS |
+		BIT_CLK_SEL_PLL;
+	if (st->chip_config.accel_enable && st->chip_config.gyro_enable)
+		w |= BIT_ACCEL_LP_CLK_SEL;
+#ifdef SUPPORT_RTC_MODE
+	w |= BIT_RTC_MODE;
+#endif
+	result = inv_plat_single_write(st, REG_INTF_CONFIG1, w);
+	if (result)
+		return result;
+	if (w & BIT_ACCEL_LP_CLK_SEL)
+		msleep(st->eng_info[ENGINE_ACCEL].divider);
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+
+	if (st->apex_supported) {
+		result = inv_enable_apex_gestures(st);
+		if (result) {
+			pr_err("inv_enable_apex_gestures error\n");
+			return result;
+		}
+	}
+
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!inv_get_apex_enabled(st))) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_SOURCE0, 1, &st->int_en);
+	if (res)
+		return res;
+	res = inv_plat_read(st, REG_INT_SOURCE1, 1, &st->int_en_2);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (res)
+		return res;
+	res = inv_plat_read(st, REG_INT_SOURCE6, 1, &st->int_en_6);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE1, 0);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE6, 0);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, st->int_en);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE1, st->int_en_2);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_4);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE6, st->int_en_6);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_REG_BANK_SEL, BIT_BANK_SEL_0);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+
+	return res;
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, st->int_en);
+
+	return res;
+}
+
+/* dummy function for 20608D */
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	return 0;
+}
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	return 0;
+}
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_core_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_core_43600.c
new file mode 100644
index 000000000000..d1f1b75f4ef2
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_core_43600.c
@@ -0,0 +1,1363 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM43600] = {128, "icm43600"},
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static char debug_reg_addr = 0x6;
+#endif
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int result = 0;
+	u8 w;
+	int bias;
+
+	/*
+	 * accel_bias is 2g scaled by 1<<16
+	 * convert to 16g
+	 */
+	bias = -(accel_bias / 8 / 65536);
+
+	switch (axis) {
+	case 0:
+		/*
+		 * X
+		 * REG_GOS_USER4_MREG_TOP1 : AX[11:8] / GZ[11:8]
+		 * REG_GOS_USER5_MREG_TOP1 : AX[7:0]
+		 */
+		result = inv_mreg_read(st, REG_GOS_USER4_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_mreg_single_write(st, REG_GOS_USER4_MREG_TOP1, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER5_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	case 1:
+		/*
+		 * Y
+		 * REG_GOS_USER6_MREG_TOP1: AY[7:0]
+		 * REG_GOS_USER7_MREG_TOP1: AZ[11:8] / AY[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER6_MREG_TOP1, w);
+		if (result)
+			return result;
+		result = inv_mreg_read(st, REG_GOS_USER7_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_mreg_single_write(st, REG_GOS_USER7_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	case 2:
+		/*
+		 * Z
+		 * REG_GOS_USER7_MREG_TOP1: AZ[11:8] / AY[11:8]
+		 * REG_GOS_USER8_MREG_TOP1: AZ[7:0]
+		 */
+		result = inv_mreg_read(st, REG_GOS_USER7_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_mreg_single_write(st, REG_GOS_USER7_MREG_TOP1, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER8_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	default:
+		result = -EINVAL;
+	}
+
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int result = 0;
+	u8 w;
+	int bias;
+
+	/*
+	 * gyro_bias is 2000dps scaled by 1<<16.
+	 * convert to 1000dps
+	 */
+	bias = -(gyro_bias * 2 / 65536);
+
+	switch (axis) {
+	case 0:
+		/*
+		 * X
+		 * REG_GOS_USER0_MREG_TOP1: GX[7:0]
+		 * REG_GOS_USER1_MREG_TOP1: GY[11:8] / GX[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER0_MREG_TOP1, w);
+		if (result)
+			return result;
+		result = inv_mreg_read(st, REG_GOS_USER1_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_mreg_single_write(st, REG_GOS_USER1_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	case 1:
+		/*
+		 * Y
+		 * REG_GOS_USER1_MREG_TOP1: GY[11:8] / GX[11:8]
+		 * REG_GOS_USER2_MREG_TOP1: GY[7:0]
+		 */
+		result = inv_mreg_read(st, REG_GOS_USER1_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0x0f;
+		w |= (bias >> 4) & 0xf0;
+		result = inv_mreg_single_write(st, REG_GOS_USER1_MREG_TOP1, w);
+		if (result)
+			return result;
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER2_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	case 2:
+		/*
+		 * Z
+		 * REG_GOS_USER3_MREG_TOP1: GZ[7:0]
+		 * REG_GOS_USER4_MREG_TOP1: AX[11:8] / GZ[11:8]
+		 */
+		w = bias & 0xff;
+		result = inv_mreg_single_write(st, REG_GOS_USER3_MREG_TOP1, w);
+		if (result)
+			return result;
+		result = inv_mreg_read(st, REG_GOS_USER4_MREG_TOP1, 1, &w);
+		if (result)
+			return result;
+		w &= 0xf0;
+		w |= (bias >> 8) & 0x0f;
+		result = inv_mreg_single_write(st, REG_GOS_USER4_MREG_TOP1, w);
+		if (result)
+			return result;
+		break;
+	default:
+		result = -EINVAL;
+	}
+
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	}
+	return count;
+}
+#endif
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_INT_MODE:
+		st->ped.int_mode = !!data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int rate = st->sensor_l[this_attr->address].rate;
+
+	switch (rate) {
+	case 12:
+		rate = 12500;
+		break;
+	case 6:
+		rate = 6250;
+		break;
+	case 3:
+		rate = 3125;
+		break;
+	default:
+		rate *= 1000;
+		break;
+	}
+
+	return snprintf(buf, MAX_WR_SZ, "%d.%03d\n", rate / 1000, rate % 1000);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, fract, rate, ind;
+	int result;
+
+	result = iio_str_to_fixpoint(buf, 1000, &data, &fract);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+		st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&st->lock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _send_pedo_steps(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int step;
+	int update;
+
+	result = inv_get_43600_pedometer_steps(st,
+		&step, &update);
+	if (result) {
+		pr_info("Failed to read step count\n");
+		return result;
+	}
+	inv_send_steps(indio_dev, step, get_time_ns());
+	st->prev_steps = step;
+
+	return 0;
+}
+
+static int inv_send_pedo_steps(struct iio_dev *indio_dev)
+{
+	_send_pedo_steps(indio_dev);
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+	bool send_ped = false;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		if ((!!data) == st->smd.on) {
+			pr_debug("SMD is %s\n  Same",
+						st->smd.on ? "On" : "Off");
+			return count;
+		}
+		st->smd.on = !!data;
+		pr_debug("SMD is %s\n", st->smd.on ? "On" : "Off");
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.stationary_detect_enable)
+			return count;
+		st->chip_config.stationary_detect_enable = !!data;
+		pr_info("Stationary Detect %s\n",
+			st->chip_config.stationary_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		if ((!!data) == st->chip_config.motion_detect_enable)
+			return count;
+		st->chip_config.motion_detect_enable = !!data;
+		pr_info("Motion Detect %s\n",
+			st->chip_config.motion_detect_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0,
+					sizeof(struct spi_transfer));
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		if (st->step_counter_l_on)
+			send_ped = true;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		if (st->step_counter_wake_l_on)
+			send_ped = true;
+		break;
+	case ATTR_DMP_STEP_COUNTER_SEND:
+		if (st->step_counter_l_on || st->step_counter_wake_l_on)
+			inv_send_pedo_steps(indio_dev);
+		return count;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	case ATTR_HIGH_RES_MODE:
+		if (!!data == st->chip_config.high_res_mode)
+			return count;
+		st->chip_config.high_res_mode = !!data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	/* send the first step count after all configuration is done */
+	if (send_ped)
+		inv_send_pedo_steps(indio_dev);
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store()
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	result = _basic_attr_store(dev, attr, buf, count);
+	mutex_unlock(&st->lock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show()
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+			s16 fsr;
+
+			/* fifo data will be 2000dps FSR regardless of
+			 * FSR configuration when high resolution mode
+			 */
+			if (st->chip_config.high_res_mode)
+				fsr = 2000;
+			else
+				fsr = gyro_scale[st->chip_config.fsr];
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", fsr);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+			s16 fsr;
+
+			/* fifo data will be 16g FSR regardless of
+			 * FSR configuration when high resolution mode
+			 */
+			if (st->chip_config.high_res_mode)
+				fsr = 16;
+			else
+				fsr = accel_scale[st->chip_config.accel_fs];
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", fsr);
+		}
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.accel_enable);
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_INT_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_mode);
+	case ATTR_DMP_SMD_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->smd.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_STATIONARY_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.stationary_detect_enable);
+	case ATTR_DMP_MOTION_DETECT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.motion_detect_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.eis_enable);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_wake_l_on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[2]);
+	case ATTR_HIGH_RES_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.high_res_mode);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&st->lock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&st->lock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+/*
+ * inv_smd_show() -  calling this function showes smd interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_smd_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return -ENODEV;
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_tilt_show() -  calling this function showes tilt interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+#endif
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int i;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&st->lock);
+
+	/* BANK 0 */
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "BANK 0\n");
+	for (i = 0; i <= 0x7F; i++) {
+		/* don't read fifo r/w register */
+		if (i == REG_FIFO_DATA_REG)
+			data = 0;
+		else
+			inv_plat_read(st, i, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed,
+				"%#2x: %#2x\n", i, data);
+	}
+
+	/* MREG TOP1 */
+	inv_set_idle(st);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "\nMREG TOP1\n");
+	for (i = REG_TMST_CONFIG1_MREG_TOP1; i <= REG_ST_STATUS2_MREG_TOP1; i++) {
+		inv_mreg_read(st, i, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed,
+				"%#4x: %#2x\n", i, data);
+	}
+	inv_reset_idle(st);
+
+	mutex_unlock(&st->lock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&st->lock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&st->lock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	{
+		.type = IIO_ACCEL,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 64,
+			.storagebits = 64,
+		},
+	},
+};
+
+static DEVICE_ATTR(poll_smd, S_IRUGO,
+			inv_smd_show, NULL);
+static DEVICE_ATTR(poll_pedometer, S_IRUGO,
+			inv_ped_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO,
+			inv_tilt_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR,
+			inv_reg_dump_show, NULL);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+#endif
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR,
+			inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO,
+			inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR,
+			NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show,
+			inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_GYRO_SCALE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_store,
+			ATTR_DEBUG_REG_ADDR);
+#endif
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_send, S_IRUGO | S_IWUSR,
+		NULL, inv_basic_attr_store,
+		ATTR_DMP_STEP_COUNTER_SEND);
+static IIO_DEVICE_ATTR(event_smd_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_SMD_ENABLE);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_stationary_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STATIONARY_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_motion_detect_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_MOTION_DETECT_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+
+static IIO_DEVICE_ATTR(in_high_res_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_HIGH_RES_MODE);
+
+static IIO_DEVICE_ATTR(params_pedometer_int_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_ON);
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+static IIO_DEVICE_ATTR(params_pedometer_int_mode, S_IRUGO | S_IWUSR,
+		inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_MODE);
+#endif
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&dev_attr_out_temperature.attr,
+#endif
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_high_res_mode.dev_attr.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_tilt.attr,
+	&iio_dev_attr_params_pedometer_int_on.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_mode.dev_attr.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_stationary_detect_enable.dev_attr.attr,
+	&iio_dev_attr_event_motion_detect_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_send.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_smd_attributes[] = {
+	&dev_attr_poll_smd.attr,
+	&iio_dev_attr_event_smd_enable.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_debug_attributes) +
+#endif
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_pedometer_attributes) +
+#endif
+					ARRAY_SIZE(inv_smd_attributes) +
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm43600")) {
+		st->chip_type = ICM43600;
+		st->apex_supported = true;
+		st->smd_supported = true;
+	} else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_smd_attributes,
+				sizeof(inv_smd_attributes));
+	t_ind += ARRAY_SIZE(inv_smd_attributes);
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	/* dummy */
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM40xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_iio_reg_43600.h b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_iio_reg_43600.h
new file mode 100644
index 000000000000..bbabe600ecf2
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_iio_reg_43600.h
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_43600_H_
+#define _INV_MPU_IIO_REG_43600_H_
+
+/* Comment out to use lower power feature
+ * by BIT_DMP_POWER_SAVE_EN
+ */
+#define NOT_SET_DMP_POWER_SAVE
+
+/* Comment out not to use lower power mode on accel */
+#define SUPPORT_ACCEL_LPM
+
+/* Registers and associated bit definitions */
+/* Bank 0 */
+#define REG_MISC_1				0x00
+#define REG_CHIP_CONFIG_REG			0x01
+#define REG_SIGNAL_PATH_RESET			0x02
+#define REG_DRIVE_CONFIG_REG1			0x03
+#define REG_DRIVE_CONFIG_REG2			0x04
+#define REG_DRIVE_CONFIG_REG3			0x05
+#define REG_INT_CONFIG_REG			0x06
+#define REG_ODRGRID0				0x07
+#define REG_ODRGRID1				0x08
+#define REG_TEMP_DATA0_UI			0x09
+#define REG_TEMP_DATA1_UI			0x0a
+#define REG_ACCEL_DATA_X0_UI			0x0b
+#define REG_ACCEL_DATA_X1_UI			0x0c
+#define REG_ACCEL_DATA_Y0_UI			0x0d
+#define REG_ACCEL_DATA_Y1_UI			0x0e
+#define REG_ACCEL_DATA_Z0_UI			0x0f
+#define REG_ACCEL_DATA_Z1_UI			0x10
+#define REG_GYRO_DATA_X0_UI			0x11
+#define REG_GYRO_DATA_X1_UI			0x12
+#define REG_GYRO_DATA_Y0_UI			0x13
+#define REG_GYRO_DATA_Y1_UI			0x14
+#define REG_GYRO_DATA_Z0_UI			0x15
+#define REG_GYRO_DATA_Z1_UI			0x16
+#define REG_TMST_FSYNC1				0x17
+#define REG_TMST_FSYNC2				0x18
+#define REG_ODR_LP_STATUS			0x19
+#define REG_PWR_MGMT_0				0x1f
+#define REG_GYRO_CONFIG0			0x20
+#define REG_ACCEL_CONFIG0			0x21
+#define REG_TEMP_CONFIG0			0x22
+#define REG_GYRO_CONFIG1			0x23
+#define REG_ACCEL_CONFIG1			0x24
+#define REG_APEX_CONFIG0			0x25
+#define REG_APEX_CONFIG1			0x26
+#define REG_WOM_CONFIG				0x27
+#define REG_FIFO_CONFIG1			0x28
+#define REG_FIFO_CONFIG2			0x29
+#define REG_FIFO_CONFIG3			0x2a
+#define REG_INT_SOURCE0				0x2b
+#define REG_INT_SOURCE1				0x2c
+#define REG_INT_SOURCE3				0x2d
+#define REG_INT_SOURCE4				0x2e
+#define REG_FIFO_LOST_PKT0			0x2f
+#define REG_FIFO_LOST_PKT1			0x30
+#define REG_APEX_DATA0				0x31
+#define REG_APEX_DATA1				0x32
+#define REG_APEX_DATA2				0x33
+#define REG_APEX_DATA3				0x34
+#define REG_INTF_CONFIG0			0x35
+#define REG_INTF_CONFIG1			0x36
+#define REG_INT_STATUS_DRDY			0x39
+#define REG_INT_STATUS				0x3a
+#define REG_INT_STATUS2				0x3b
+#define REG_INT_STATUS3				0x3c
+#define REG_FIFO_BYTE_COUNT1			0x3d
+#define REG_FIFO_BYTE_COUNT2			0x3e
+#define REG_FIFO_DATA_REG			0x3f
+#define REG_S4S_GYRO_TPH1			0x40
+#define REG_S4S_GYRO_TPH2			0x41
+#define REG_S4S_ACCEL_TPH1			0x42
+#define REG_S4S_ACCEL_TPH2			0x43
+#define REG_S4S_RR				0x44
+#define REG_GYR_BIAS_CFG1			0x46
+#define REG_WHO_AM_I				0x75
+#define REG_S4S_ST				0x76
+#define REG_S4S_ST_CLONE			0x77
+#define REG_S4S_DT				0x78
+#define REG_BLK_SEL_W				0x79
+#define REG_MADDR_W				0x7a
+#define REG_M_W					0x7b
+#define REG_BLK_SEL_R				0x7c
+#define REG_MADDR_R				0x7d
+#define REG_M_R					0x7e
+
+/* MREG_TOP1 */
+#define REG_TMST_CONFIG1_MREG_TOP1		0x00
+#define REG_FIFO_CONFIG5_MREG_TOP1		0x01
+#define REG_FIFO_CONFIG6_MREG_TOP1		0x02
+#define REG_FSYNC_CONFIG_MREG_TOP1		0x03
+#define REG_INT_CONFIG0_MREG_TOP1		0x04
+#define REG_INT_CONFIG1_MREG_TOP1		0x05
+#define REG_AFSR_CONFIG0_MREG_TOP1		0x07
+#define REG_AFSR_CONFIG1_MREG_TOP1		0x08
+#define REG_TBC_RCOSC_MREG_TOP1			0x0d
+#define REG_TBC_PLL_MREG_TOP1			0x0e
+#define REG_ST_CONFIG_MREG_TOP1			0x13
+#define REG_SELFTEST_MREG_TOP1			0x14
+#define REG_PADS_CONFIG3_MREG_TOP1		0x17
+#define REG_TEMP_CONFIG1_MREG_TOP1		0x1c
+#define REG_TEMP_CONFIG3_MREG_TOP1		0x1e
+#define REG_S4S_CONFIG1_MREG_TOP1		0x1f
+#define REG_S4S_CONFIG2_MREG_TOP1		0x20
+#define REG_S4S_FREQ_RATIO1_MREG_TOP1		0x21
+#define REG_S4S_FREQ_RATIO2_MREG_TOP1		0x22
+#define REG_INTF_CONFIG6_MREG_TOP1		0x23
+#define REG_INTF_CONFIG10_MREG_TOP1		0x25
+#define REG_INTF_CONFIG7_MREG_TOP1		0x28
+#define REG_OTP_CONFIG_MREG_TOP1		0x2b
+#define REG_INT_SOURCE6_MREG_TOP1		0x2f
+#define REG_INT_SOURCE7_MREG_TOP1		0x30
+#define REG_INT_SOURCE8_MREG_TOP1		0x31
+#define REG_INT_SOURCE9_MREG_TOP1		0x32
+#define REG_INT_SOURCE10_MREG_TOP1		0x33
+#define REG_GYRO_PWR_CFG0_MREG_TOP1		0x38
+#define REG_ACCEL_CP_CFG0_MREG_TOP1		0x39
+#define REG_APEX_CONFIG2_MREG_TOP1		0x44
+#define REG_APEX_CONFIG3_MREG_TOP1		0x45
+#define REG_APEX_CONFIG4_MREG_TOP1		0x46
+#define REG_APEX_CONFIG5_MREG_TOP1		0x47
+#define REG_APEX_CONFIG9_MREG_TOP1		0x48
+#define REG_APEX_CONFIG10_MREG_TOP1		0x49
+#define REG_APEX_CONFIG11_MREG_TOP1		0x4a
+#define REG_APEX_CONFIG12_MREG_TOP1		0x67
+#define REG_ACCEL_WOM_X_THR_MREG_TOP1		0x4b
+#define REG_ACCEL_WOM_Y_THR_MREG_TOP1		0x4c
+#define REG_ACCEL_WOM_Z_THR_MREG_TOP1		0x4d
+#define REG_GOS_USER0_MREG_TOP1			0x4e
+#define REG_GOS_USER1_MREG_TOP1			0x4f
+#define REG_GOS_USER2_MREG_TOP1			0x50
+#define REG_GOS_USER3_MREG_TOP1			0x51
+#define REG_GOS_USER4_MREG_TOP1			0x52
+#define REG_GOS_USER5_MREG_TOP1			0x53
+#define REG_GOS_USER6_MREG_TOP1			0x54
+#define REG_GOS_USER7_MREG_TOP1			0x55
+#define REG_GOS_USER8_MREG_TOP1			0x56
+#define REG_ST_STATUS1_MREG_TOP1		0x63
+#define REG_ST_STATUS2_MREG_TOP1		0x64
+
+/* MMEM_TOP */
+#define REG_XG_ST_DATA_MMEM_TOP			0x5000
+#define REG_YG_ST_DATA_MMEM_TOP			0x5001
+#define REG_ZG_ST_DATA_MMEM_TOP			0x5002
+#define REG_XA_ST_DATA_MMEM_TOP			0x5003
+#define REG_YA_ST_DATA_MMEM_TOP			0x5004
+#define REG_ZA_ST_DATA_MMEM_TOP			0x5005
+
+/* MREG_OTP */
+#define REG_OTP_CTRL7_MREG_OTP			0x2806
+
+
+/* Bank0 REG_GYRO_CONFIG0/REG_ACCEL_CONFIG0 */
+#define SHIFT_GYRO_FS_SEL			5
+#define SHIFT_ACCEL_FS_SEL			5
+#define SHIFT_ODR_CONF				0
+#define BIT_GYRO_FSR				0x60
+#define BIT_GYRO_ODR				0x0F
+#define BIT_ACCEL_FSR				0x60
+#define BIT_ACCEL_ODR				0x0F
+#define BIT_SENSOR_ODR_800HZ			0x06
+#define BIT_SENSOR_ODR_400HZ			0x07
+#define BIT_SENSOR_ODR_200HZ			0x08
+#define BIT_SENSOR_ODR_100HZ			0x09
+#define BIT_SENSOR_ODR_50HZ			0x0A
+#define BIT_SENSOR_ODR_25HZ			0x0B
+#define BIT_SENSOR_ODR_12HZ			0x0C
+#define BIT_SENSOR_ODR_6HZ			0x0D
+#define BIT_SENSOR_ODR_3HZ			0x0E
+
+/* Bank0 REG_GYRO_CONFIG1 */
+#define BIT_GYR_UI_FLT_BW_BYPASS		0x00
+#define BIT_GYR_UI_FLT_BW_180HZ			0x01
+#define BIT_GYR_UI_FLT_BW_121HZ			0x02
+#define BIT_GYR_UI_FLT_BW_73HZ			0x03
+#define BIT_GYR_UI_FLT_BW_53HZ			0x04
+#define BIT_GYR_UI_FLT_BW_34HZ			0x05
+#define BIT_GYR_UI_FLT_BW_25HZ			0x06
+#define BIT_GYR_UI_FLT_BW_16HZ			0x07
+#define BIT_GYR_UI_AVG_IND_2X			0x00
+#define BIT_GYR_UI_AVG_IND_4X			0x10
+#define BIT_GYR_UI_AVG_IND_8X			0x20
+#define BIT_GYR_UI_AVG_IND_16X			0x30
+#define BIT_GYR_UI_AVG_IND_32X			0x40
+#define BIT_GYR_UI_AVG_IND_64X			0x50
+
+/* Bank0 REG_ACCEL_CONFIG1 */
+#define BIT_ACC_FILT_BW_IND_BYPASS		0x00
+#define BIT_ACC_FILT_BW_IND_180HZ		0x01
+#define BIT_ACC_FILT_BW_IND_121HZ		0x02
+#define BIT_ACC_FILT_BW_IND_73HZ		0x03
+#define BIT_ACC_FILT_BW_IND_53HZ		0x04
+#define BIT_ACC_FILT_BW_IND_34HZ		0x05
+#define BIT_ACC_FILT_BW_IND_25HZ		0x06
+#define BIT_ACC_FILT_BW_IND_16HZ		0x07
+#define BIT_ACC_UI_AVG_IND_2X			0x00
+#define BIT_ACC_UI_AVG_IND_4X			0x10
+#define BIT_ACC_UI_AVG_IND_8X			0x20
+#define BIT_ACC_UI_AVG_IND_16X			0x30
+#define BIT_ACC_UI_AVG_IND_32X			0x40
+#define BIT_ACC_UI_AVG_IND_64X			0x50
+
+/* Bank0 REG_INT_CONFIG_REG */
+#define SHIFT_INT1_MODE				0x02
+#define SHIFT_INT1_DRIVE_CIRCUIT		0x01
+#define SHIFT_INT1_POLARITY			0x00
+
+/* Bank0 REG_PWR_MGMT_0 */
+#define BIT_ACCEL_MODE_OFF			0x00
+#define BIT_ACCEL_MODE_LPM			0x02
+#define BIT_ACCEL_MODE_LNM			0x03
+#define BIT_ACCEL_MODE_MASK			0x03
+#define BIT_GYRO_MODE_OFF			0x00
+#define BIT_GYRO_MODE_STBY			0x04
+#define BIT_GYRO_MODE_LPM			0x08
+#define BIT_GYRO_MODE_LNM			0x0c
+#define BIT_GYRO_MODE_MASK			0x0c
+#define BIT_IDLE				0x10
+#define BIT_ACCEL_LP_CLK_SEL			0x80
+
+/* Bank0 REG_SIGNAL_PATH_RESET */
+#define BIT_FIFO_FLUSH				0x04
+#define BIT_SOFT_RESET_CHIP_CONFIG		0x10
+
+/* Bank0 REG_INTF_CONFIG0 */
+#define BIT_SIFS_CFG_I2C_ONLY			0x02
+#define BIT_SIFS_CFG_SPI_ONLY			0x03
+#define BIT_SENSOR_DATA_ENDIAN			0x10
+#define BIT_FIFO_COUNT_ENDIAN			0x20
+#define BIT_FIFO_COUNT_FORMAT			0x40
+#define BIT_FIFO_SREG_INVALID_IND_DIS		0x80
+
+/* Bank0 REG_INTF_CONFIG1 */
+#define BIT_CLK_SEL_RC				0x00
+#define BIT_CLK_SEL_PLL				0x01
+#define BIT_CLK_SEL_DIS				0x03
+#define BIT_I3C_DDR_EN				0x04
+#define BIT_I3C_SDR_EN				0x08
+#define BIT_GYRO_AFSR_MODE_LFS			0x00
+#define BIT_GYRO_AFSR_MODE_HFS			0x20
+#define BIT_GYRO_AFSR_MODE_DYN			0x40
+
+/* Bank0 REG_FIFO_CONFIG1 */
+#define BIT_FIFO_MODE_NO_BYPASS			0x00
+#define BIT_FIFO_MODE_BYPASS			0x01
+#define BIT_FIFO_MODE_STREAM			0x00
+#define BIT_FIFO_MODE_STOPFULL			0x02
+
+/* Bank 0 REG_INT_SOURCE0 */
+#define BIT_INT_AGC_RDY_INT1_EN			0x01
+#define BIT_INT_FIFO_FULL_INT1_EN		0x02
+#define BIT_INT_FIFO_THS_INT1_EN		0x04
+#define BIT_INT_DRDY_INT_EN			0x08
+#define BIT_INT_RESET_DONE_INT1_EN		0x10
+#define BIT_INT_PLL_RDY_INT1_EN			0x20
+#define BIT_INT_FSYNC_INT1_EN			0x40
+#define BIT_INT_ST_DONE_INT1_EN			0x80
+
+/* Bank 0 REG_INT_SOURCE1 */
+#define BIT_INT_WOM_X_INT1_EN			0x01
+#define BIT_INT_WOM_Y_INT1_EN			0x02
+#define BIT_INT_WOM_Z_INT1_EN			0x04
+#define BIT_INT_WOM_XYZ_INT1_EN (BIT_INT_WOM_X_INT1_EN | \
+		BIT_INT_WOM_Y_INT1_EN | BIT_INT_WOM_Z_INT1_EN)
+#define BIT_INT_SMD_INT1_EN			0x08
+#define BIT_INT_I3C_PROTCL_ERR_INT1_EN		0x40
+
+/* Bank0 REG_INT_STATUS_DRDY */
+#define BIT_INT_STATUS_DRDY			0x01
+
+/* Bank0 REG_INT_STATUS */
+#define BIT_INT_STATUS_AGC_RDY			0x01
+#define BIT_INT_STATUS_FIFO_FULL		0x02
+#define BIT_INT_STATUS_FIFO_THS			0x04
+#define BIT_INT_STATUS_RESET_DONE		0x10
+#define BIT_INT_STATUS_PLL_RDY			0x20
+#define BIT_INT_STATUS_FSYNC			0x40
+#define BIT_INT_STATUS_ST_DONE			0x80
+
+/* Bank0 REG_INT_STATUS2 */
+#define BIT_INT_STATUS_WOM_Z			0x01
+#define BIT_INT_STATUS_WOM_Y			0x02
+#define BIT_INT_STATUS_WOM_X			0x04
+#define BIT_INT_STATUS_WOM_XYZ (BIT_INT_STATUS_WOM_X | \
+		BIT_INT_STATUS_WOM_Y | BIT_INT_STATUS_WOM_Z)
+#define BIT_INT_STATUS_SMD			0x08
+
+/* Bank 0 REG_INT_STATUS3 */
+#define BIT_INT_STATUS_LOWG_DET			0x02
+#define BIT_INT_STATUS_FF_DET			0x04
+#define BIT_INT_STATUS_TILT_DET			0x08
+#define BIT_INT_STATUS_STEP_CNT_OVFL		0x10
+#define BIT_INT_STATUS_STEP_DET			0x20
+
+/* Bank0 REG_WOM_CONFIG */
+#define BIT_WOM_EN_OFF				0x00
+#define BIT_WOM_EN_ON				0x01
+#define BIT_WOM_MODE_INITIAL			0x00
+#define BIT_WOM_MODE_PREV			0x02
+#define BIT_WOM_INT_MODE_OR			0x00
+#define BIT_WOM_INT_MODE_AND			0x04
+#define BIT_WOM_INT_DUR_LEGACY			0x00
+#define BIT_WOM_INT_DUR_2ND			0x08
+#define BIT_WOM_INT_DUR_3RD			0x10
+#define BIT_WOM_INT_DUR_4TH			0x18
+
+/* Bank0 REG_APEX_CONFIG0 */
+#define BIT_DMP_SRAM_RESET_APEX			0x01
+#define BIT_DMP_INIT_EN				0x04
+#define BIT_DMP_POWER_SAVE_EN			0x08
+
+/* Bank0 REG_APEX_CONFIG1 */
+#define BIT_DMP_ODR_25HZ			0x00
+#define BIT_DMP_ODR_50HZ			0x02
+#define BIT_DMP_ODR_100HZ			0x03
+#define BIT_DMP_PEDO_EN				0x08
+#define BIT_DMP_TILT_EN				0x10
+#define BIT_DMP_FF_EN				0x20
+#define BIT_DMP_SMD_EN				0x40
+
+/* REG_OTP_CONFIG_MREG_TOP1 */
+#define BIT_OTP_COPY_NORMAL			0x04
+#define BIT_OTP_COPY_ST_DATA			0x0C
+#define OTP_COPY_MODE_MASK                      0x0C
+
+/* REG_INT_SOURCE6_MREG_TOP1 */
+#define BIT_INT_TLT_DET_INT1_EN			0x08
+#define BIT_INT_STEP_CNT_OVFL_INT1_EN		0x10
+#define BIT_INT_STEP_DET_INT1_EN		0x20
+#define BIT_INT_LOWG_INT1_EN			0x40
+#define BIT_INT_FF_INT1_EN			0x80
+
+/* REG_TMST_CONFIG1_MREG_TOP1 */
+#define BIT_TMST_EN				0x01
+#define BIT_TMST_FSYNC_EN			0x02
+#define BIT_TMST_DELTA_EN			0x04
+#define BIT_TMST_RESOL				0x08
+#define BIT_TMST_ON_SREG_EN			0x10
+#define BIT_ODR_EN_WITHOUT_SENSOR		0x40
+
+/* REG_FIFO_CONFIG5_MREG_TOP1 */
+#define BIT_FIFO_ACCEL_EN			0x01
+#define BIT_FIFO_GYRO_EN			0x02
+#define BIT_FIFO_TMST_FSYNC_EN			0x04
+#define BIT_FIFO_HIRES_EN			0x08
+#define BIT_RESUME_PARTIAL_RD			0x10
+#define BIT_WM_GT_TH				0x20
+
+/* REG_SELFTEST_MREG_TOP1 */
+#define BIT_EN_AX_ST				0x01
+#define BIT_EN_AY_ST				0x02
+#define BIT_EN_AZ_ST				0x04
+#define BIT_EN_GX_ST				0x08
+#define BIT_EN_GY_ST				0x10
+#define BIT_EN_GZ_ST				0x20
+#define BIT_ACCEL_ST_EN				0x40
+#define BIT_GYRO_ST_EN				0x80
+
+/* REG_ST_CONFIG_MREG_TOP1 */
+#define BIT_PD_ACCEL_CP45_ST_REG		0x80
+#define SHIFT_GYRO_ST_LIM			0
+#define SHIFT_ACCEL_ST_LIM			3
+#define SHIFT_ST_NUM_SAMPLE			6
+
+/* REG_ST_STATUS1_MREG_TOP1 */
+#define BIT_DMP_AX_ST_PASS			0x02
+#define BIT_DMP_AY_ST_PASS			0x04
+#define BIT_DMP_AZ_ST_PASS			0x08
+#define BIT_DMP_ACCEL_ST_DONE			0x10
+#define BIT_DMP_ACCEL_ST_PASS			0x20
+
+/* REG_ST_STATUS2_MREG_TOP1 */
+#define BIT_DMP_GX_ST_PASS			0x02
+#define BIT_DMP_GY_ST_PASS			0x04
+#define BIT_DMP_GZ_ST_PASS			0x08
+#define BIT_DMP_GYRO_ST_DONE			0x10
+#define BIT_DMP_GYRO_ST_PASS			0x20
+#define BIT_DMP_ST_INCOMPLETE			0x40
+
+/* REG_OTP_CTRL7_MREG_OTP */
+#define BIT_OTP_RELOAD				0x08
+#define BIT_OTP_PWR_DOWN			0x02
+
+
+/* fifo data packet header */
+#define BIT_FIFO_HEAD_MSG			0x80
+#define BIT_FIFO_HEAD_ACCEL			0x40
+#define BIT_FIFO_HEAD_GYRO			0x20
+#define BIT_FIFO_HEAD_20			0x10
+#define BIT_FIFO_HEAD_TMSP_ODR			0x08
+#define BIT_FIFO_HEAD_TMSP_NO_ODR		0x04
+#define BIT_FIFO_HEAD_TMSP_FSYNC		0x0C
+#define BIT_FIFO_HEAD_ODR_ACCEL			0x02
+#define BIT_FIFO_HEAD_ODR_GYRO			0x01
+
+/* data definitions */
+#define FIFO_PACKET_BYTE_SINGLE			8
+#define FIFO_PACKET_BYTE_6X			16
+#define FIFO_PACKET_BYTE_HIRES			20
+#define FIFO_COUNT_BYTE				2
+
+/* sensor startup time */
+#define INV_ICM43600_GYRO_START_TIME		100
+#define INV_ICM43600_ACCEL_START_TIME		100
+
+/* sensor stop time */
+#define INV_ICM43600_GYRO_STOP_TIME		20
+
+/* M-reg access wait tile */
+#define INV_ICM43600_MCLK_WAIT_US		20
+#define INV_ICM43600_BLK_SEL_WAIT_US		10
+#define INV_ICM43600_MADDR_WAIT_US		10
+#define INV_ICM43600_M_RW_WAIT_US		10
+
+/* temperature sensor */
+#define TEMP_SCALE				100 /* scale by 100 */
+#define TEMP_LSB_PER_DEG			2   /* 2LSB=1degC */
+#define TEMP_OFFSET				25  /* 25 degC */
+
+
+/* enum for sensor */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+#define BASE_SAMPLE_RATE		800
+#define GESTURE_ACCEL_RATE		50
+#define ESI_GYRO_RATE			800
+#define MPU_INIT_SENSOR_RATE_LNM	12	/* min Hz in LNM */
+#define MPU_INIT_SENSOR_RATE_LPM	3	/* min Hz in LPM */
+#define MAX_FIFO_PACKET_READ		16
+#define HARDWARE_FIFO_SIZE		1024
+/* ~7/8 of hardware FIFO and a multiple of packet sizes 8/16/20 */
+#define FIFO_SIZE			880
+#define LEFT_OVER_BYTES			128
+#define POWER_UP_TIME			100
+#define REG_UP_TIME_USEC		100
+#define IIO_BUFFER_BYTES		8
+#define REG_FIFO_COUNT_H		REG_FIFO_BYTE_COUNT1
+#define BYTES_PER_SENSOR		6
+#define BYTES_FOR_TEMP			1
+#define MAX_BATCH_FIFO_SIZE		FIFO_SIZE
+#define FIRST_DROP_SAMPLES_ACC_800HZ	20
+#define FIRST_DROP_SAMPLES_ACC_200HZ	10
+#define FIRST_DROP_SAMPLES_GYR_800HZ	20
+#define FIRST_DROP_SAMPLES_GYR_200HZ	10
+#define WOM_THRESHOLD			13 /* 1000 / 256 * 13 = 50.7mg */
+
+
+/*
+ * INT configurations
+ * Polarity: 0 -> Active Low, 1 -> Active High
+ * Drive circuit: 0 -> Open Drain, 1 -> Push-Pull
+ * Mode: 0 -> Pulse, 1 -> Latch
+ */
+#define INT_POLARITY			1
+#define INT_DRIVE_CIRCUIT		1
+#define INT_MODE			0
+
+#define ACC_LPM_MAX_RATE		(400)
+
+typedef union {
+	unsigned char Byte;
+	struct {
+		unsigned char g_odr_change_bit:1;
+		unsigned char a_odr_change_bit:1;
+		unsigned char timestamp_bit:2;
+		unsigned char twentybits_bit:1;
+		unsigned char gyro_bit:1;
+		unsigned char accel_bit:1;
+		unsigned char msg_bit:1;
+	} bits;
+} icm4x6xx_fifo_header_t;
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM42688,
+	ICM40609D,
+	ICM43600,
+	INV_NUM_PARTS,
+};
+
+/* chip specific functions */
+struct inv_mpu_state;
+int inv_get_43600_pedometer_steps(struct inv_mpu_state *st,
+	int *ped, int *update);
+int inv_set_idle(struct inv_mpu_state *st);
+int inv_reset_idle(struct inv_mpu_state *st);
+int inv_mreg_single_write(struct inv_mpu_state *st, int addr, u8 data);
+int inv_mreg_read(struct inv_mpu_state *st, int addr, int len, u8 *data);
+bool inv_get_apex_enabled(struct inv_mpu_state *st);
+int inv_get_apex_odr(struct inv_mpu_state *st);
+
+#endif /* _INV_MPU_IIO_REG_43600_H_ */
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_init_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_init_43600.c
new file mode 100644
index 000000000000..920e9d8fe825
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_init_43600.c
@@ -0,0 +1,473 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_vr = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_vr = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_vr = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data;
+
+	result = inv_plat_read(st, REG_GYRO_CONFIG0, 1, &data);
+	if (result)
+		return result;
+	data &= ~BIT_GYRO_FSR;
+	data |= (3 - st->chip_config.fsr) << SHIFT_GYRO_FS_SEL;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG0,
+				   data);
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data;
+
+	result = inv_plat_read(st, REG_ACCEL_CONFIG0, 1, &data);
+	if (result)
+		return result;
+	data &= ~BIT_ACCEL_FSR;
+	data |= (3 - st->chip_config.accel_fs) << SHIFT_ACCEL_FS_SEL;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+			   data);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	int result = 0;
+	int8_t val, accel_rate;
+
+	if (st->eng_info[ENGINE_ACCEL].divider) {
+		accel_rate = 800 / st->eng_info[ENGINE_ACCEL].divider;
+	} else {
+		/* use dummy rate */
+#ifdef SUPPORT_ACCEL_LPM
+		accel_rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+		accel_rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	}
+
+	if (accel_rate > 50)
+		val = WOM_THRESHOLD / (accel_rate / 50);
+	else
+		val = WOM_THRESHOLD;
+	result |= inv_mreg_single_write(st, REG_ACCEL_WOM_X_THR_MREG_TOP1, val);
+	result |= inv_mreg_single_write(st, REG_ACCEL_WOM_Y_THR_MREG_TOP1, val);
+	result |= inv_mreg_single_write(st, REG_ACCEL_WOM_Z_THR_MREG_TOP1, val);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_config_apex_gestures(struct inv_mpu_state *st)
+{
+	int result = 0;
+	int8_t rw;
+	int8_t dmp_power_save_time = 2;
+	int8_t low_energy_amp_th = 10;
+	int8_t pedo_amp_th_sel = 8;
+	int8_t pedo_step_cnt_th_sel = 5;
+	int8_t pedo_step_det_th_sel = 2;
+	int8_t pedo_sb_timer_th_sel = 4;
+	int8_t pedo_hi_enrgy_th_sel = 1;
+	int8_t tilt_wait_time = 1; /* default: 2 */
+	int8_t smd_sensitivity = 0;
+	int8_t sensitivity_mode = 0;
+
+	/* REG_APEX_CONFIG2_MREG_TOP1 */
+	rw = dmp_power_save_time & 0x0f;
+	rw |= (low_energy_amp_th << 4) & 0xf0;
+	result = inv_mreg_single_write(st, REG_APEX_CONFIG2_MREG_TOP1, rw);
+	if (result)
+		return result;
+
+	/* REG_APEX_CONFIG3_MREG_TOP1 */
+	rw = (pedo_amp_th_sel << 4) & 0xf0;
+	rw |= pedo_step_cnt_th_sel & 0x0f;
+	result = inv_mreg_single_write(st, REG_APEX_CONFIG3_MREG_TOP1, rw);
+	if (result)
+		return result;
+
+	/* REG_APEX_CONFIG4_MREG_TOP1 */
+	rw = (pedo_step_det_th_sel << 5) & 0xe0;
+	rw |= (pedo_sb_timer_th_sel << 2) & 0x1c;
+	rw |= pedo_hi_enrgy_th_sel & 0x03;
+	result = inv_mreg_single_write(st, REG_APEX_CONFIG4_MREG_TOP1, rw);
+	if (result)
+		return result;
+
+	/* REG_APEX_CONFIG5_MREG_TOP1 */
+	result = inv_mreg_read(st, REG_APEX_CONFIG5_MREG_TOP1, 1, &rw);
+	if (result)
+		return result;
+	rw &= 0x3f;
+	rw |= (tilt_wait_time << 6) & 0xc0;
+	result = inv_mreg_single_write(st, REG_APEX_CONFIG5_MREG_TOP1, rw);
+	if (result)
+		return result;
+
+	/* REG_APEX_CONFIG9_MREG_TOP1 */
+	result = inv_mreg_read(st, REG_APEX_CONFIG9_MREG_TOP1, 1, &rw);
+	if (result)
+		return result;
+	rw &= 0xf0;
+	rw |= (smd_sensitivity << 1) & 0x0e;
+	rw |= (sensitivity_mode << 0) & 0x01;
+	result = inv_mreg_single_write(st, REG_APEX_CONFIG9_MREG_TOP1, rw);
+
+	return result;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+#ifdef SUPPORT_ACCEL_LPM
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	st->sensor[SENSOR_GYRO].rate = MPU_INIT_SENSOR_RATE_LNM;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = BYTE_MODE;
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	if (st->apex_supported) {
+		res =  inv_config_apex_gestures(st);
+		if (res)
+			return res;
+	}
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+/*
+ * OTP reload procedure.
+ */
+static int inv_otp_reload(struct inv_mpu_state *st)
+{
+	int res;
+	u8 rb;
+
+	/* set idle bit */
+	res = inv_set_idle(st);
+	if (res)
+		return res;
+
+	/* Set OTP_COPY_MODE to 2'b01 */
+	res = inv_mreg_read(st, REG_OTP_CONFIG_MREG_TOP1, 1, &rb);
+	if (res)
+		return res;
+	rb &= ~OTP_COPY_MODE_MASK;
+	rb |= BIT_OTP_COPY_NORMAL;
+	res = inv_mreg_single_write(st, REG_OTP_CONFIG_MREG_TOP1, rb);
+	if (res)
+		return res;
+
+	/* set OTP_PWR_DOWN to 1'b0 and wait for 300us */
+	res = inv_mreg_read(st, REG_OTP_CTRL7_MREG_OTP, 1, &rb);
+	if (res)
+		return res;
+	rb &= ~BIT_OTP_PWR_DOWN;
+	res = inv_mreg_single_write(st, REG_OTP_CTRL7_MREG_OTP, rb);
+	if (res)
+		return res;
+	usleep_range(300, 400);
+
+	/* set OTP_RELOAD to 1'b1 and wait for 280us */
+	res = inv_mreg_read(st, REG_OTP_CTRL7_MREG_OTP, 1, &rb);
+	if (res)
+		return res;
+	rb |= BIT_OTP_RELOAD;
+	res = inv_mreg_single_write(st, REG_OTP_CTRL7_MREG_OTP, rb);
+	if (res)
+		return res;
+	usleep_range(280, 380);
+
+	return 0;
+}
+
+/*
+ * write POR value
+ */
+static int inv_set_default_register(struct inv_mpu_state *st)
+{
+	int status = 0;
+
+	status |= inv_plat_single_write(st, REG_GYRO_CONFIG0, 0x06);
+	status |= inv_plat_single_write(st, REG_ACCEL_CONFIG0, 0x06);
+	status |= inv_plat_single_write(st, REG_APEX_CONFIG0, 0x08);
+	status |= inv_plat_single_write(st, REG_APEX_CONFIG1, 0x02);
+	status |= inv_plat_single_write(st, REG_WOM_CONFIG, 0);
+	status |= inv_plat_single_write(st, REG_FIFO_CONFIG1, 0x01);
+	status |= inv_plat_single_write(st, REG_FIFO_CONFIG2, 0);
+	status |= inv_plat_single_write(st, REG_FIFO_CONFIG3, 0);
+	status |= inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, 0x20);
+	status |= inv_mreg_single_write(st, REG_ST_CONFIG_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_INT_SOURCE7_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_INT_SOURCE8_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_INT_SOURCE9_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_INT_SOURCE10_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG2_MREG_TOP1, 0xA2);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG3_MREG_TOP1, 0x85);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG4_MREG_TOP1, 0x51);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG5_MREG_TOP1, 0x80);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG9_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG10_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG11_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_ACCEL_WOM_X_THR_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_ACCEL_WOM_Y_THR_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_ACCEL_WOM_Z_THR_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER0_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER1_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER2_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER3_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER4_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER5_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER6_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER7_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_GOS_USER8_MREG_TOP1, 0);
+	status |= inv_mreg_single_write(st, REG_APEX_CONFIG12_MREG_TOP1, 0);
+
+	if (status)
+		return -EIO;
+ 
+	return 0;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	inv_otp_reload(st);
+
+	inv_set_default_register(st);
+
+	/* SPI or I2C only
+	 * FIFO count  : byte mode, big endian
+	 * sensor data : big endian
+	 */
+	v = st->i2c_dis;
+	v |= BIT_FIFO_COUNT_ENDIAN;
+	v |= BIT_SENSOR_DATA_ENDIAN;
+	result = inv_plat_single_write(st, REG_INTF_CONFIG0, v);
+	if (result)
+		return result;
+
+	/* configure clock */
+	v = BIT_GYRO_AFSR_MODE_DYN | BIT_CLK_SEL_PLL;
+	if (st->i2c_dis != BIT_SIFS_CFG_I2C_ONLY)
+		v |= BIT_I3C_SDR_EN | BIT_I3C_DDR_EN;
+	result = inv_plat_single_write(st, REG_INTF_CONFIG1, v);
+	if (result)
+		return result;
+
+	/* initialize DMP */
+	v = BIT_DMP_SRAM_RESET_APEX;
+#ifndef NOT_SET_DMP_POWER_SAVE
+	v |= BIT_DMP_POWER_SAVE_EN;
+#endif
+	result = inv_plat_single_write(st, REG_APEX_CONFIG0, v);
+	if (result)
+		return result;
+	usleep_range(1000, 1001);
+
+	v = BIT_DMP_ODR_50HZ;
+	result = inv_plat_single_write(st, REG_APEX_CONFIG1, v);
+	if (result)
+		return result;
+
+	/* enable chip timestamp */
+	v = BIT_TMST_EN;
+	result = inv_mreg_single_write(st, REG_TMST_CONFIG1_MREG_TOP1, v);
+	if (result)
+		return result;
+
+	/* INT pin configuration */
+	v = (INT_POLARITY << SHIFT_INT1_POLARITY) |
+		(INT_DRIVE_CIRCUIT << SHIFT_INT1_DRIVE_CIRCUIT) |
+		(INT_MODE << SHIFT_INT1_MODE);
+	result = inv_plat_single_write(st, REG_INT_CONFIG_REG, v);
+	if (result)
+		return result;
+
+	/* disable FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_CONFIG1,
+		BIT_FIFO_MODE_BYPASS);
+	if (result)
+		return result;
+	result = inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, 0);
+	if (result)
+		return result;
+
+	/* disable sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0, 0);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_misc_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_misc_43600.c
new file mode 100644
index 000000000000..756ea4cc7d88
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_misc_43600.c
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2018-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/delay.h>
+#include "../inv_mpu_iio.h"
+
+/**
+ * inv_set_idle() - Set Idle bit in PWR_MGMT_0 register
+ * @st: struct inv_mpu_state.
+ *
+ * Set ACCEL_LP_CLK_SEL as well when necessary with a proper wait
+ *
+ * Return: 0 when successful.
+ */
+int inv_set_idle(struct inv_mpu_state *st)
+{
+	int ret;
+	u8 reg_pwr_mgmt_0;
+	u8 d;
+	unsigned long delay_us;
+
+	ret = inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+	if (ret)
+		return ret;
+
+	/* set Idle bit.
+	 * when accel LPM is already enabled, set ACCEL_LP_CLK_SEL bit as well.
+	 */
+	d = reg_pwr_mgmt_0;
+	d |= BIT_IDLE;
+	if ((d & BIT_ACCEL_MODE_MASK) == BIT_ACCEL_MODE_LPM &&
+			(d & BIT_GYRO_MODE_MASK) == 0) {
+		d |= BIT_ACCEL_LP_CLK_SEL;
+		delay_us = USEC_PER_SEC /
+			st->eng_info[ENGINE_ACCEL].running_rate;
+	} else
+		delay_us = INV_ICM43600_MCLK_WAIT_US;
+
+	if (reg_pwr_mgmt_0 != d) {
+		ret = inv_plat_single_write(st, REG_PWR_MGMT_0, d);
+		usleep_range(delay_us, delay_us + 10);
+	}
+
+	return ret;
+}
+
+/**
+ * inv_reset_idle() - Reset Idle bit in PWR_MGMT_0 register
+ * @st: struct inv_mpu_state.
+ *
+ * Reset ACCEL_LP_CLK_SEL as well
+ *
+ * Return: 0 when successful.
+ */
+int inv_reset_idle(struct inv_mpu_state *st)
+{
+	int ret;
+	u8 reg_pwr_mgmt_0;
+	u8 d;
+
+	ret = inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+	if (ret)
+		return ret;
+
+	/* reset Idle bit.
+	 * note that ACCEL_LP_CLK_SEL bit is reset as well here.
+	 */
+	d = reg_pwr_mgmt_0;
+	d &= ~(BIT_IDLE | BIT_ACCEL_LP_CLK_SEL);
+	if (reg_pwr_mgmt_0 != d)
+		ret = inv_plat_single_write(st, REG_PWR_MGMT_0, d);
+
+	return ret;
+}
+
+/**
+ * inv_mreg_single_write() - Single byte write to MREG area.
+ * @st: struct inv_mpu_state.
+ * @addr: MREG register address including bank in upper byte.
+ * @data: data to write.
+ *
+ * Return: 0 when successful.
+ */
+int inv_mreg_single_write(struct inv_mpu_state *st, int addr, u8 data)
+{
+	int ret;
+	u8 reg_pwr_mgmt_0;
+
+	ret = inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+	if (ret)
+		return ret;
+
+	ret = inv_set_idle(st);
+	if (ret)
+		return ret;
+
+	ret = inv_plat_single_write(st, REG_BLK_SEL_W, (addr >> 8) & 0xff);
+	usleep_range(INV_ICM43600_BLK_SEL_WAIT_US,
+			INV_ICM43600_BLK_SEL_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+	ret = inv_plat_single_write(st, REG_MADDR_W, addr & 0xff);
+	usleep_range(INV_ICM43600_MADDR_WAIT_US,
+			INV_ICM43600_MADDR_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+	ret = inv_plat_single_write(st, REG_M_W, data);
+	usleep_range(INV_ICM43600_M_RW_WAIT_US,
+			INV_ICM43600_M_RW_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+restore_bank:
+	ret |= inv_plat_single_write(st, REG_BLK_SEL_W, 0);
+	usleep_range(INV_ICM43600_BLK_SEL_WAIT_US,
+			INV_ICM43600_BLK_SEL_WAIT_US + 1);
+
+	ret |= inv_plat_single_write(st, REG_PWR_MGMT_0, reg_pwr_mgmt_0);
+
+	return ret;
+}
+
+/**
+ * inv_mreg_read() - Multiple byte read from MREG area.
+ * @st: struct inv_mpu_state.
+ * @addr: MREG register start address including bank in upper byte.
+ * @len: length to read in byte.
+ * @data: pointer to store read data.
+ *
+ * Return: 0 when successful.
+ */
+int inv_mreg_read(struct inv_mpu_state *st, int addr, int len, u8 *data)
+{
+	int ret;
+	u8 reg_pwr_mgmt_0;
+
+	ret = inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+	if (ret)
+		return ret;
+
+	ret = inv_set_idle(st);
+	if (ret)
+		return ret;
+
+	ret = inv_plat_single_write(st, REG_BLK_SEL_R, (addr >> 8) & 0xff);
+	usleep_range(INV_ICM43600_BLK_SEL_WAIT_US,
+			INV_ICM43600_BLK_SEL_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+	ret = inv_plat_single_write(st, REG_MADDR_R, addr & 0xff);
+	usleep_range(INV_ICM43600_MADDR_WAIT_US,
+			INV_ICM43600_MADDR_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+	ret = inv_plat_read(st, REG_M_R, len, data);
+	usleep_range(INV_ICM43600_M_RW_WAIT_US,
+			INV_ICM43600_M_RW_WAIT_US + 1);
+	if (ret)
+		goto restore_bank;
+
+restore_bank:
+	ret |= inv_plat_single_write(st, REG_BLK_SEL_R, 0);
+	usleep_range(INV_ICM43600_BLK_SEL_WAIT_US,
+			INV_ICM43600_BLK_SEL_WAIT_US + 1);
+
+	ret |= inv_plat_single_write(st, REG_PWR_MGMT_0, reg_pwr_mgmt_0);
+
+	return ret;
+}
+
+/**
+ * inv_get_apex_enabled() - Check if any APEX feature is enabled
+ * @st: struct inv_mpu_state.
+ *
+ * Return: true when any is enabled, otherwise false.
+ */
+bool inv_get_apex_enabled(struct inv_mpu_state *st)
+{
+	if (!(st->apex_supported))
+		return false;
+
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on ||
+		st->step_counter_l_on ||
+		st->step_counter_wake_l_on)
+		return true;
+	if (st->chip_config.tilt_enable)
+		return true;
+	if (st->smd.on)
+		return true;
+
+	return false;
+}
+
+/**
+ * inv_get_apex_odr() - Get min accel ODR according to enabled APEX feature
+ * @st: struct inv_mpu_state.
+ *
+ * Return: min accel ODR in Hz
+ */
+int inv_get_apex_odr(struct inv_mpu_state *st)
+{
+	int odr_hz = 0;
+
+#ifdef SUPPORT_ACCEL_LPM
+	odr_hz = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	odr_hz = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	if (st->apex_supported) {
+		/* returns min accel rate for each algorithm */
+		if (st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->step_counter_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.tilt_enable ||
+			st->smd.on)
+			odr_hz = 50;
+	}
+
+	return odr_hz;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_parsing_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_parsing_43600.c
new file mode 100644
index 000000000000..e319f19cd7db
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_parsing_43600.c
@@ -0,0 +1,611 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_check_fsync(struct inv_mpu_state *st)
+{
+	u8 data[1];
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+	inv_plat_read(st, REG_INT_STATUS, 1, data);
+	if (data[0] & BIT_INT_STATUS_FSYNC) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	}
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_push_sensor(struct iio_dev *indio_dev, int ind, u64 t, s32 *raw)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	s32 calib[3] = { 0, 0, 0 };
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		inv_push_16bytes_buffer(indio_dev, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st);
+		break;
+	case SENSOR_GYRO:
+		inv_push_gyro_data(indio_dev, raw, calib, t);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static bool inv_validate_fifo_data(s16 *lsb)
+{
+	bool ret = true;
+
+	if ((lsb[0] == -32768) && (lsb[1] == -32768) && (lsb[2] == -32768))
+		ret = false;
+
+	return ret;
+}
+
+static int inv_push_43600_data(struct iio_dev *indio_dev, u8 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	icm4x6xx_fifo_header_t header;
+	s16 acc_lsb[3] = { 0, 0, 0 };
+	s16 gyr_lsb[3] = { 0, 0, 0 };
+	s32 acc[3], gyr[3];
+	bool valid_acc = false;
+	bool valid_gyr = false;
+
+	header.Byte = *d;
+
+	/* skip 1 byte header */
+	if (header.bits.msg_bit)
+		return 0;
+
+	if (header.bits.accel_bit && !header.bits.gyro_bit) {
+		/* only accel */
+		acc_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		acc_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		acc_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		valid_acc = inv_validate_fifo_data(acc_lsb);
+	} else if (!header.bits.accel_bit && header.bits.gyro_bit) {
+		/* only gyro */
+		gyr_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		gyr_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		gyr_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		valid_gyr = inv_validate_fifo_data(gyr_lsb);
+	} else if ((header.bits.accel_bit && header.bits.gyro_bit) ||
+			header.bits.twentybits_bit) {
+		/* accel and gyro */
+		acc_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[1]));
+		acc_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[3]));
+		acc_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[5]));
+		gyr_lsb[0] = (s16)be16_to_cpup((__be16 *) (&d[7]));
+		gyr_lsb[1] = (s16)be16_to_cpup((__be16 *) (&d[9]));
+		gyr_lsb[2] = (s16)be16_to_cpup((__be16 *) (&d[11]));
+		valid_acc = inv_validate_fifo_data(acc_lsb);
+		valid_gyr = inv_validate_fifo_data(gyr_lsb);
+	} else
+		return 0;
+
+	if (header.bits.twentybits_bit) {
+		/* high resolution mode */
+		acc[0] = (acc_lsb[0] << 4) | ((d[17] >> 4) & 0xf);
+		acc[1] = (acc_lsb[1] << 4) | ((d[18] >> 4) & 0xf);
+		acc[2] = (acc_lsb[2] << 4) | ((d[19] >> 4) & 0xf);
+		gyr[0] = (gyr_lsb[0] << 4) | (d[17] & 0xf);
+		gyr[1] = (gyr_lsb[1] << 4) | (d[18] & 0xf);
+		gyr[2] = (gyr_lsb[2] << 4) | (d[19] & 0xf);
+	} else {
+		/* normal resolution mode */
+		acc[0] = acc_lsb[0];
+		acc[1] = acc_lsb[1];
+		acc[2] = acc_lsb[2];
+		gyr[0] = gyr_lsb[0];
+		gyr[1] = gyr_lsb[1];
+		gyr[2] = gyr_lsb[2];
+	}
+
+	/* send accel data */
+	if (header.bits.accel_bit) {
+		if (st->sensor[SENSOR_ACCEL].on && valid_acc) {
+			inv_get_dmp_ts(st, SENSOR_ACCEL);
+			if (st->sensor[SENSOR_ACCEL].send &&
+					(!st->ts_algo.first_drop_samples[SENSOR_ACCEL])) {
+				st->sensor[SENSOR_ACCEL].sample_calib++;
+				inv_push_sensor(indio_dev, SENSOR_ACCEL,
+						st->sensor[SENSOR_ACCEL].ts, acc);
+			}
+			if (st->ts_algo.first_drop_samples[SENSOR_ACCEL])
+				st->ts_algo.first_drop_samples[SENSOR_ACCEL]--;
+		}
+	}
+
+	/* send gyro data */
+	if (header.bits.gyro_bit) {
+		if (st->sensor[SENSOR_GYRO].on && valid_gyr) {
+			inv_get_dmp_ts(st, SENSOR_GYRO);
+			if (st->sensor[SENSOR_GYRO].send &&
+					(!st->ts_algo.first_drop_samples[SENSOR_GYRO])) {
+				st->sensor[SENSOR_GYRO].sample_calib++;
+				inv_push_sensor(indio_dev, SENSOR_GYRO,
+						st->sensor[SENSOR_GYRO].ts, gyr);
+			}
+			if (st->ts_algo.first_drop_samples[SENSOR_GYRO])
+				st->ts_algo.first_drop_samples[SENSOR_GYRO]--;
+		}
+	}
+
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_prescan_fifo_data(struct inv_mpu_state *st, u8 *data, int len)
+{
+	int i;
+	u8 *dptr;
+	icm4x6xx_fifo_header_t header;
+
+	dptr = data;
+	while (dptr < (data + len)) {
+		if (st->batch.pk_size >= 8)
+			pr_debug("FIFO 0x00: %x %x %x %x %x %x %x %x\n",
+				 dptr[0], dptr[1], dptr[2], dptr[3],
+				 dptr[4], dptr[5], dptr[6], dptr[7]);
+		if (st->batch.pk_size >= 16)
+			pr_debug("FIFO 0x08: %x %x %x %x %x %x %x %x\n",
+				 dptr[8], dptr[9], dptr[10], dptr[11],
+				 dptr[12], dptr[13], dptr[14], dptr[15]);
+		if (st->batch.pk_size >= 20)
+			pr_debug("FIFO 0x10: %x %x %x %x\n",
+				 dptr[16], dptr[17], dptr[18], dptr[19]);
+		dptr += st->batch.pk_size;
+	}
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].count = 0;
+
+	dptr = data;
+	while (dptr < (data + len)) {
+		/* count the number of valid samples
+		 * in the buffer for accel and gyro
+		 */
+		header.Byte = *dptr;
+		if (header.bits.msg_bit) {
+			pr_warn("Unexpected FIFO msg bit\n");
+			return 0;
+		}
+		/* header */
+		dptr++;
+		/* accel */
+		if (header.bits.accel_bit) {
+			st->sensor[SENSOR_ACCEL].count++;
+			dptr += st->sensor[SENSOR_ACCEL].sample_size;
+		}
+		/* gyro */
+		if (header.bits.gyro_bit) {
+			st->sensor[SENSOR_GYRO].count++;
+			dptr += st->sensor[SENSOR_GYRO].sample_size;
+		}
+		/* temperature */
+		if (header.bits.twentybits_bit)
+			dptr += 2;
+		else
+			dptr += 1;
+		/* timestamp */
+		if ((header.bits.accel_bit && header.bits.gyro_bit) ||
+				header.bits.twentybits_bit)
+			dptr += 2;
+		/* high resolution data */
+		if (header.bits.twentybits_bit)
+			dptr += 3;
+	}
+
+	return 0;
+}
+
+static int inv_process_43600_data(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 int_status2;
+	u8 data;
+	bool done_flag;
+	u8 reg_pwr_mgmt_0;
+	bool idle_set = false;
+
+	/* check INT_STATUS2 */
+	res = inv_plat_read(st, REG_INT_STATUS2, 1, &int_status2);
+	if (res)
+		return res;
+
+	/* SMD */
+	if (st->smd.on && (int_status2 & BIT_INT_STATUS_SMD)) {
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_smd");
+		st->smd.on = false;
+		st->trigger_state = EVENT_TRIGGER;
+		inv_check_sensor_on(st);
+		res = set_inv_enable(indio_dev);
+		if (res)
+			return res;
+		st->wake_sensor_received = true;
+	}
+
+	/* WOM */
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		pr_debug("ges cnt=%d, statu=%x\n",
+			st->gesture_int_count, int_status2);
+		if (int_status2 & BIT_INT_STATUS_WOM_XYZ) {
+			if (!st->gesture_int_count) {
+				res = inv_plat_read(st,
+					REG_INT_SOURCE0, 1, &data);
+				if (res)
+					return res;
+				data |= BIT_INT_DRDY_INT_EN;
+				res = inv_plat_single_write(st,
+					REG_INT_SOURCE0, data);
+				if (res)
+					return res;
+				data = 0;
+				if (st->chip_config.gyro_enable ||
+					st->chip_config.accel_enable)
+					data |= (BIT_FIFO_ACCEL_EN |
+						BIT_FIFO_GYRO_EN |
+						BIT_WM_GT_TH);
+				res = inv_mreg_single_write(st,
+					REG_FIFO_CONFIG5_MREG_TOP1, data);
+				if (res)
+					return res;
+				if (data) {
+					res = inv_plat_single_write(st,
+						REG_FIFO_CONFIG1, BIT_FIFO_MODE_NO_BYPASS);
+					if (res)
+						return res;
+				}
+				/*
+				 * First time wake up from WOM
+				 * we don't need data in the FIFO
+				 */
+				res = inv_reset_fifo(st, true);
+				if (res)
+					return res;
+				if (st->chip_config.stationary_detect_enable) {
+					st->gesture_int_count =
+						STATIONARY_DELAY_THRESHOLD;
+				} else {
+					st->gesture_int_count =
+						WOM_DELAY_THRESHOLD;
+				}
+				return res;
+			}
+			if (st->chip_config.stationary_detect_enable) {
+				st->gesture_int_count =
+					STATIONARY_DELAY_THRESHOLD;
+			} else {
+				st->gesture_int_count =
+					WOM_DELAY_THRESHOLD;
+			}
+		} else {
+			if (!st->gesture_int_count) {
+				res = inv_plat_single_write(st,
+						REG_FIFO_CONFIG1, BIT_FIFO_MODE_BYPASS);
+				if (res)
+					return res;
+				res = inv_mreg_single_write(st,
+					REG_FIFO_CONFIG5_MREG_TOP1, 0);
+				if (res)
+					return res;
+				res = inv_plat_read(st,
+					REG_INT_SOURCE0, 1, &data);
+				if (res)
+					return res;
+				data &= ~BIT_INT_DRDY_INT_EN;
+				res = inv_plat_single_write(st,
+					REG_INT_SOURCE0, data);
+				if (res)
+					return res;
+
+				return res;
+			}
+			st->gesture_int_count--;
+			if (st->gesture_int_count < 0)
+				st->gesture_int_count = 0;
+		}
+	}
+
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE / st->batch.pk_size)) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n",
+			fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+
+	if (total_bytes > pk_size * MAX_FIFO_PACKET_READ) {
+		/* set Idle bit when FIFO read will be
+		 * more than one transaction
+		 */
+		res = inv_plat_read(st, REG_PWR_MGMT_0, 1, &reg_pwr_mgmt_0);
+		if (res)
+			return res;
+		res = inv_plat_single_write(st, REG_PWR_MGMT_0,
+				reg_pwr_mgmt_0 | BIT_IDLE | BIT_ACCEL_LP_CLK_SEL);
+		if (res)
+			return res;
+		usleep_range(INV_ICM43600_MCLK_WAIT_US,
+				INV_ICM43600_MCLK_WAIT_US + 1);
+		idle_set = true;
+	}
+
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_DATA_REG, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+
+	if (idle_set) {
+		/* reset Idle bit */
+		res = inv_plat_single_write(st, REG_PWR_MGMT_0, reg_pwr_mgmt_0);
+		if (res)
+			return res;
+	}
+
+	dptr = d;
+	total_bytes = fifo_count;
+
+	inv_prescan_fifo_data(st, dptr, total_bytes);
+
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		pr_debug("total=%d, pk=%d\n", total_bytes, pk_size);
+		if (total_bytes >= pk_size) {
+			res = inv_push_43600_data(indio_dev, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+int inv_get_43600_pedometer_steps(struct inv_mpu_state *st,
+	int *ped, int *update)
+{
+	u8 r[2];
+	uint32_t cur_step_cnt;
+	int result;
+
+	*update = false;
+	result = inv_plat_read(st,
+		REG_APEX_DATA0, 2, &r[0]);
+	if (result)
+		return result;
+
+	cur_step_cnt = (uint32_t)((r[1] << 8) | r[0]);
+	if (st->apex_data.step_reset_last_val) {
+		st->apex_data.step_reset_last_val = false;
+		st->apex_data.step_cnt_last_val = cur_step_cnt;
+	}
+	if (cur_step_cnt !=
+		st->apex_data.step_cnt_last_val) {
+		if (cur_step_cnt < st->apex_data.step_cnt_last_val) {
+			/* overflow */
+			st->apex_data.step_cnt_total +=
+				cur_step_cnt + (0xFFFF - st->apex_data.step_cnt_last_val);
+		} else {
+			st->apex_data.step_cnt_total +=
+				cur_step_cnt - st->apex_data.step_cnt_last_val;
+		}
+	}
+	st->apex_data.step_cnt_last_val = cur_step_cnt;
+	*ped = st->apex_data.step_cnt_total;
+	*update = true;
+
+	return result;
+}
+
+static int inv_process_apex_gesture(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 int_status3;
+	s16 s[3] = {0,};
+	u64 t;
+	uint32_t cur_step_cnt;
+	int ped_update;
+	int result;
+
+	if (inv_get_apex_enabled(st)) {
+		t = get_time_ns();
+
+		/* check INT_STATUS3 */
+		result = inv_plat_read(st, REG_INT_STATUS3, 1, &int_status3);
+		if (result)
+			return result;
+
+		/* Tilt */
+		if (int_status3 & BIT_INT_STATUS_TILT_DET) {
+			if (st->chip_config.tilt_enable) {
+				sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_tilt");
+				st->wake_sensor_received = true;
+			}
+		}
+
+		/* Step detector */
+		if (int_status3 & BIT_INT_STATUS_STEP_DET) {
+			if (st->step_detector_l_on) {
+				inv_push_8bytes_buffer(indio_dev,
+					STEP_DETECTOR_HDR, t, s);
+			}
+			if (st->step_detector_wake_l_on) {
+				inv_push_8bytes_buffer(indio_dev,
+					STEP_DETECTOR_WAKE_HDR, t, s);
+				st->wake_sensor_received = true;
+			}
+			if (st->ped.int_mode &&
+				(st->step_counter_l_on || st->step_counter_wake_l_on)) {
+				result = inv_get_43600_pedometer_steps(st,
+					&cur_step_cnt, &ped_update);
+				if (result)
+					return result;
+				if (ped_update)
+					inv_send_steps(indio_dev, st->apex_data.step_cnt_total, t);
+				if (st->step_counter_wake_l_on)
+					st->wake_sensor_received = true;
+			}
+		}
+	}
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&st->lock);
+	st->wake_sensor_received = false;
+
+	if (st->apex_supported) {
+		result = inv_process_apex_gesture(indio_dev);
+		if (result)
+			goto err_reset_fifo;
+	}
+
+	result = inv_process_43600_data(indio_dev);
+	if (result)
+		goto err_reset_fifo;
+	mutex_unlock(&st->lock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable) &&
+		(!inv_get_apex_enabled(st))) {
+		mutex_unlock(&st->lock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	mutex_unlock(&st->lock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable ||
+		inv_get_apex_enabled(st)) {
+		st->wake_sensor_received = false;
+		inv_process_43600_data(indio_dev);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	}
+	inv_push_marker_to_buffer(indio_dev, END_MARKER, data);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_selftest_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_selftest_43600.c
new file mode 100644
index 000000000000..8a9f547e0194
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_selftest_43600.c
@@ -0,0 +1,580 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define DEBUG
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define SELF_TEST_ODR			6   /* 800Hz */
+#define SELF_TEST_ODR_LP		7   /* 400Hz */
+#define SELF_TEST_ACC_FS		3   /* +-2g */
+#define SELF_TEST_GYR_FS		3   /* +-250dps */
+#define SELF_TEST_ACC_BW_IND		BIT_ACC_FILT_BW_IND_180HZ
+#define SELF_TEST_ACC_LPM_AVG		BIT_ACC_UI_AVG_IND_2X
+#define SELF_TEST_GYR_BW_IND		BIT_GYR_UI_FLT_BW_180HZ
+#define SELF_TEST_GYR_LPM_AVG		BIT_GYR_UI_AVG_IND_2X
+#define SELF_TEST_PRECISION		1000
+#define SELF_TEST_SAMPLE_NB		200
+
+#define ST_OFF				0
+#define ST_ON				1
+#define SENS_LNM			0
+#define SENS_LPM			1
+
+#define RETRY_CNT_SELF_TEST_DMP		30
+#define RETRY_WAIT_MS_SELF_TEST_DMP	100
+#define SELF_TEST_GYRO_ST_LIM_DMP	7
+#define SELF_TEST_ACCEL_ST_LIM_DMP	7
+#define SELF_TEST_NUM_SAMPLE_DMP	0
+
+struct recover_regs {
+	/* Bank 0 */
+	u8 pwr_mgmt_0;		/* REG_PWR_MGMT_0 */
+	u8 int_source0;		/* REG_INT_SOURCE0 */
+	u8 int_soruce1;		/* REG_INT_SOURCE1 */
+	u8 gyro_config0;	/* REG_GYRO_CONFIG0 */
+	u8 accel_config0;	/* REG_ACCEL_CONFIG0 */
+	u8 gyro_config1;	/* REG_GYRO_CONFIG1 */
+	u8 accel_config1;	/* REG_ACCEL_CONFIG1 */
+	u8 fifo_config1;	/* REG_FIFO_CONFIG1 */
+	u8 apex_config0;	/* REG_APEX_CONFIG0 */
+	u8 apex_config1;	/* REG_APEX_CONFIG1 */
+	/* MREG TOP1 */
+	u8 fifo_config5;	/* REG_FIFO_CONFIG5_MREG_TOP1 */
+	u8 int_source6;		/* REG_INT_SOURCE6_MREG_TOP1 */
+	u8 st_config;		/* REG_ST_CONFIG_MREG_TOP1 */
+	u8 selftest;		/* REG_SELFTEST_MREG_TOP1 */
+
+	/* MREG TOP2 */
+	u8 gos_user0;		/* REG_GOS_USER0_MREG_TOP1 */
+	u8 gos_user1;		/* REG_GOS_USER1_MREG_TOP1 */
+	u8 gos_user2;		/* REG_GOS_USER2_MREG_TOP1 */
+	u8 gos_user3;		/* REG_GOS_USER3_MREG_TOP1 */
+	u8 gos_user4;		/* REG_GOS_USER4_MREG_TOP1 */
+	u8 gos_user5;		/* REG_GOS_USER5_MREG_TOP1 */
+	u8 gos_user6;		/* REG_GOS_USER6_MREG_TOP1 */
+	u8 gos_user7;		/* REG_GOS_USER7_MREG_TOP1 */
+	u8 gos_user8;		/* REG_GOS_USER8_MREG_TOP1 */
+};
+
+static struct recover_regs save_regs;
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result = 0;
+
+	/* Bank 0 */
+	result |= inv_plat_read(st, REG_PWR_MGMT_0, 1,
+			&save_regs.pwr_mgmt_0);
+	result |= inv_plat_read(st, REG_INT_SOURCE0, 1,
+			&save_regs.int_source0);
+	result |= inv_plat_read(st, REG_INT_SOURCE1, 1,
+			&save_regs.int_soruce1);
+	result |= inv_plat_read(st, REG_GYRO_CONFIG0, 1,
+			&save_regs.gyro_config0);
+	result |= inv_plat_read(st, REG_ACCEL_CONFIG0, 1,
+			&save_regs.accel_config0);
+	result |= inv_plat_read(st, REG_GYRO_CONFIG1, 1,
+			&save_regs.gyro_config1);
+	result |= inv_plat_read(st, REG_ACCEL_CONFIG1, 1,
+			&save_regs.accel_config1);
+	result |= inv_plat_read(st, REG_FIFO_CONFIG1, 1,
+			&save_regs.fifo_config1);
+	result |= inv_plat_read(st, REG_APEX_CONFIG0, 1,
+			&save_regs.apex_config0);
+	result |= inv_plat_read(st, REG_APEX_CONFIG1, 1,
+			&save_regs.apex_config1);
+
+	result |= inv_set_idle(st);
+
+	/* MREG TOP1 */
+	result |= inv_mreg_read(st, REG_FIFO_CONFIG5_MREG_TOP1, 1,
+			&save_regs.fifo_config5);
+	result |= inv_mreg_read(st, REG_INT_SOURCE6_MREG_TOP1, 1,
+			&save_regs.int_source6);
+	result |= inv_mreg_read(st, REG_ST_CONFIG_MREG_TOP1, 1,
+			&save_regs.st_config);
+	result |= inv_mreg_read(st, REG_SELFTEST_MREG_TOP1, 1,
+			&save_regs.selftest);
+
+	/* MREG TOP2 */
+	result |= inv_mreg_read(st, REG_GOS_USER0_MREG_TOP1, 1,
+			&save_regs.gos_user0);
+	result |= inv_mreg_read(st, REG_GOS_USER1_MREG_TOP1, 1,
+			&save_regs.gos_user1);
+	result |= inv_mreg_read(st, REG_GOS_USER2_MREG_TOP1, 1,
+			&save_regs.gos_user2);
+	result |= inv_mreg_read(st, REG_GOS_USER3_MREG_TOP1, 1,
+			&save_regs.gos_user3);
+	result |= inv_mreg_read(st, REG_GOS_USER4_MREG_TOP1, 1,
+			&save_regs.gos_user4);
+	result |= inv_mreg_read(st, REG_GOS_USER5_MREG_TOP1, 1,
+			&save_regs.gos_user5);
+	result |= inv_mreg_read(st, REG_GOS_USER6_MREG_TOP1, 1,
+			&save_regs.gos_user6);
+	result |= inv_mreg_read(st, REG_GOS_USER7_MREG_TOP1, 1,
+			&save_regs.gos_user7);
+	result |= inv_mreg_read(st, REG_GOS_USER8_MREG_TOP1, 1,
+			&save_regs.gos_user8);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result = 0;
+
+	result |= inv_set_idle(st);
+
+	/* MREG TOP1 */
+	result |= inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1,
+			save_regs.fifo_config5);
+	result |= inv_mreg_single_write(st, REG_INT_SOURCE6_MREG_TOP1,
+			save_regs.int_source6);
+	result |= inv_mreg_single_write(st, REG_ST_CONFIG_MREG_TOP1,
+			save_regs.st_config);
+	result |= inv_mreg_single_write(st, REG_SELFTEST_MREG_TOP1,
+			save_regs.selftest);
+
+	/* MREG TOP2 */
+	result |= inv_mreg_single_write(st, REG_GOS_USER0_MREG_TOP1,
+			save_regs.gos_user0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER1_MREG_TOP1,
+			save_regs.gos_user1);
+	result |= inv_mreg_single_write(st, REG_GOS_USER2_MREG_TOP1,
+			save_regs.gos_user2);
+	result |= inv_mreg_single_write(st, REG_GOS_USER3_MREG_TOP1,
+			save_regs.gos_user3);
+	result |= inv_mreg_single_write(st, REG_GOS_USER4_MREG_TOP1,
+			save_regs.gos_user4);
+	result |= inv_mreg_single_write(st, REG_GOS_USER5_MREG_TOP1,
+			save_regs.gos_user5);
+	result |= inv_mreg_single_write(st, REG_GOS_USER6_MREG_TOP1,
+			save_regs.gos_user6);
+	result |= inv_mreg_single_write(st, REG_GOS_USER7_MREG_TOP1,
+			save_regs.gos_user7);
+	result |= inv_mreg_single_write(st, REG_GOS_USER8_MREG_TOP1,
+			save_regs.gos_user8);
+
+	/* Bank 0 */
+	result |= inv_plat_single_write(st, REG_INT_SOURCE0,
+			save_regs.int_source0);
+	result |= inv_plat_single_write(st, REG_INT_SOURCE1,
+			save_regs.int_soruce1);
+	result |= inv_plat_single_write(st, REG_GYRO_CONFIG0,
+			save_regs.gyro_config0);
+	result |= inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+			save_regs.accel_config0);
+	result |= inv_plat_single_write(st, REG_GYRO_CONFIG1,
+			save_regs.gyro_config1);
+	result |= inv_plat_single_write(st, REG_ACCEL_CONFIG1,
+			save_regs.accel_config1);
+	result |= inv_plat_single_write(st, REG_FIFO_CONFIG1,
+			save_regs.fifo_config1);
+	result |= inv_plat_single_write(st, REG_APEX_CONFIG0,
+			save_regs.apex_config0);
+	result |= inv_plat_single_write(st, REG_PWR_MGMT_0,
+			save_regs.pwr_mgmt_0);
+	/* Note: do not restore REG_APEX_CONFIG1 intentionally */
+
+	return result;
+}
+
+static int inv_reset_offset_reg(struct inv_mpu_state *st)
+{
+	int result = 0;
+
+	result |= inv_mreg_single_write(st, REG_GOS_USER0_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER1_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER2_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER3_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER4_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER5_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER6_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER7_MREG_TOP1, 0);
+	result |= inv_mreg_single_write(st, REG_GOS_USER8_MREG_TOP1, 0);
+
+	return result;
+}
+
+static int inv_init_selftest(struct inv_mpu_state *st)
+{
+	int result;
+
+	/* disable sensors, and enable RC clock */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0,
+			BIT_IDLE | BIT_ACCEL_LP_CLK_SEL);
+	if (result)
+		return result;
+
+	/* disable interrupts */
+	result = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_SOURCE1, 0);
+	if (result)
+		return result;
+	result = inv_mreg_single_write(st, REG_INT_SOURCE6_MREG_TOP1, 0);
+	if (result)
+		return result;
+
+	/* disabled all apex features */
+	result = inv_plat_single_write(st, REG_APEX_CONFIG1, BIT_DMP_ODR_50HZ);
+
+	/* reset offset registers */
+	result = inv_reset_offset_reg(st);
+	if (result)
+		return result;
+
+	/* stop FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_CONFIG1,
+			BIT_FIFO_MODE_BYPASS);
+	if (result)
+		return result;
+	result = inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, 0);
+
+	return result;
+}
+
+static int inv_setup_sensors(struct inv_mpu_state *st,
+	int sensor, int st_mode, int pwr_mode)
+{
+	int result;
+	u8 val;
+
+	/* disable sensors */
+	val = BIT_IDLE | BIT_ACCEL_LP_CLK_SEL;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0, val);
+
+	/* self-test mode set */
+	val = 0;
+	if (st_mode == ST_ON) {
+		if (sensor == SENSOR_ACCEL)
+			val |= BIT_EN_AX_ST | BIT_EN_AY_ST | BIT_EN_AZ_ST;
+		else if (sensor == SENSOR_GYRO)
+			val |= BIT_EN_GX_ST | BIT_EN_GY_ST | BIT_EN_GZ_ST;
+	}
+	result = inv_mreg_single_write(st, REG_SELFTEST_MREG_TOP1, val);
+	if (result)
+		return result;
+
+	/* set rate */
+	if (pwr_mode == SENS_LPM) {
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG0,
+				(SELF_TEST_GYR_FS << SHIFT_GYRO_FS_SEL) |
+				(SELF_TEST_ODR_LP << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+				(SELF_TEST_ACC_FS << SHIFT_ACCEL_FS_SEL) |
+				(SELF_TEST_ODR_LP << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+	} else {
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG0,
+				(SELF_TEST_GYR_FS << SHIFT_GYRO_FS_SEL) |
+				(SELF_TEST_ODR << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_ACCEL_CONFIG0,
+				(SELF_TEST_ACC_FS << SHIFT_ACCEL_FS_SEL) |
+				(SELF_TEST_ODR << SHIFT_ODR_CONF));
+		if (result)
+			return result;
+	}
+
+	/* set filter */
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG1,
+		SELF_TEST_GYR_LPM_AVG | SELF_TEST_GYR_BW_IND);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG1,
+		SELF_TEST_ACC_LPM_AVG | SELF_TEST_ACC_BW_IND);
+	if (result)
+		return result;
+
+	/* turn on sensors */
+	val = 0;
+	if (sensor == SENSOR_ACCEL) {
+		if (pwr_mode == SENS_LPM)
+			val |= BIT_ACCEL_MODE_LPM;
+		else
+			val |= BIT_ACCEL_MODE_LNM;
+	} else if (sensor == SENSOR_GYRO) {
+		if (pwr_mode == SENS_LPM)
+			val |= BIT_GYRO_MODE_LPM;
+		else
+			val |= BIT_GYRO_MODE_LNM;
+	}
+	val |= BIT_IDLE | BIT_ACCEL_LP_CLK_SEL;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0, val);
+
+	msleep(200);
+
+	return result;
+}
+
+static int inv_calc_avg_with_samples(struct inv_mpu_state *st, int sensor,
+		int avg[3], int count, int pwr_mode)
+{
+	int result = 0;
+	int i, t;
+	u8 data[6];
+	u8 reg;
+	s32 sum[3] = { 0 };
+
+	if (sensor == SENSOR_ACCEL)
+		reg = REG_ACCEL_DATA_X0_UI;
+	else if (sensor == SENSOR_GYRO)
+		reg = REG_GYRO_DATA_X0_UI;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < count; i++) {
+		result = inv_plat_read(st, reg, 6, data);
+		if (result)
+			return result;
+
+		/* convert 8-bit to 16-bit */
+		for (t = 0; t < 3; t++)
+			sum[t] += (s16)be16_to_cpup((__be16 *)(&data[t * 2]));
+
+		if (pwr_mode == SENS_LPM)
+			usleep_range(2500, 2501); /* 400Hz */
+		else
+			usleep_range(1250, 1251); /* 800Hz */
+	}
+
+	for (t = 0; t < 3; t++)
+		avg[t] = (int)(sum[t] / count * SELF_TEST_PRECISION);
+
+	return result;
+}
+
+static int inv_run_dmp_selftest(struct inv_mpu_state *st, int sensor)
+{
+	int result;
+	int i;
+	u8 val;
+	bool done = false;
+	bool pass = false;
+
+	/* disable sensors, and enable RC clock */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_0,
+			BIT_IDLE | BIT_ACCEL_LP_CLK_SEL);
+	if (result)
+		return result;
+
+	/* initialize SRAM */
+	result = inv_plat_single_write(st, REG_APEX_CONFIG0,
+			BIT_DMP_SRAM_RESET_APEX);
+	if (result)
+		return result;
+
+	usleep_range(1000, 1200);
+
+	/* Reload self-test data from OTP */
+	inv_mreg_single_write(st, REG_OTP_CONFIG_MREG_TOP1, BIT_OTP_COPY_ST_DATA);
+	inv_mreg_single_write(st, REG_OTP_CTRL7_MREG_OTP, 0x04);
+	usleep_range(200, 300);
+	inv_mreg_single_write(st, REG_OTP_CTRL7_MREG_OTP, 0x04 | BIT_OTP_RELOAD);
+	usleep_range(100, 200);
+	inv_mreg_single_write(st, REG_OTP_CONFIG_MREG_TOP1, BIT_OTP_COPY_NORMAL);
+	inv_mreg_single_write(st, REG_OTP_CTRL7_MREG_OTP, 0x04 | BIT_OTP_PWR_DOWN);
+	usleep_range(200, 300);
+
+	/* configure DMP self-test */
+	result = inv_mreg_single_write(st, REG_ST_CONFIG_MREG_TOP1,
+			(SELF_TEST_GYRO_ST_LIM_DMP << SHIFT_GYRO_ST_LIM) |
+			(SELF_TEST_ACCEL_ST_LIM_DMP << SHIFT_ACCEL_ST_LIM) |
+			(SELF_TEST_NUM_SAMPLE_DMP << SHIFT_ST_NUM_SAMPLE));
+	if (result)
+		return result;
+
+	/* start DMP self-test */
+	if (sensor == SENSOR_ACCEL)
+		val = BIT_ACCEL_ST_EN;
+	else if (sensor == SENSOR_GYRO)
+		val = BIT_GYRO_ST_EN;
+	else
+		return -EINVAL;
+
+	result = inv_mreg_single_write(st, REG_SELFTEST_MREG_TOP1, val);
+	if (result)
+		return result;
+
+	/* wait for pass/fail result from DMP */
+	for (i = 0; i < RETRY_CNT_SELF_TEST_DMP; i++) {
+		msleep(RETRY_WAIT_MS_SELF_TEST_DMP);
+		if (sensor == SENSOR_ACCEL)
+			result = inv_mreg_read(st, REG_ST_STATUS1_MREG_TOP1,
+					1, &val);
+		else if (sensor == SENSOR_GYRO)
+			result = inv_mreg_read(st, REG_ST_STATUS2_MREG_TOP1,
+					1, &val);
+		if (result)
+			return result;
+
+		pr_debug("st_status = 0x%02x\n", val);
+
+		if (sensor == SENSOR_ACCEL) {
+			if (val & BIT_DMP_ACCEL_ST_DONE) {
+				if ((val & BIT_DMP_AX_ST_PASS) &&
+					(val & BIT_DMP_AY_ST_PASS) &&
+					(val & BIT_DMP_AZ_ST_PASS))
+					pass = true;
+				done = true;
+				break;
+			}
+		} else if (sensor == SENSOR_GYRO) {
+			if (val & BIT_DMP_GYRO_ST_DONE) {
+				if ((val & BIT_DMP_GX_ST_PASS) &&
+					(val & BIT_DMP_GY_ST_PASS) &&
+					(val & BIT_DMP_GZ_ST_PASS))
+					pass = true;
+				done = true;
+				break;
+			}
+		}
+	}
+	pr_debug("dmp status read cnt = %d\n", i);
+	pr_info("sensor %d: done=%d, pass=%d\n", sensor, done, pass);
+
+	/* disable DMP self-test */
+	result = inv_mreg_single_write(st, REG_SELFTEST_MREG_TOP1, 0);
+	if (result)
+		return result;
+
+	if (done && pass)
+		result = 0;
+	else
+		result = -1;
+
+	return result;
+}
+
+static int inv_do_selftest_dmp(struct inv_mpu_state *st, int sensor,
+		int bias_lnm[3], int bias_lpm[3], bool lp_mode)
+{
+	u16 result;
+	int i;
+	int lsb[3] = { 0 };
+	int lsb_lp[3] = { 0 };
+
+	/* factory cal */
+	result = inv_setup_sensors(st, sensor, ST_OFF, SENS_LNM);
+	if (result)
+		return result;
+	result = inv_calc_avg_with_samples(st, sensor, lsb,
+			SELF_TEST_SAMPLE_NB, SENS_LNM);
+	if (result)
+		return result;
+	pr_info("sensor %d: LNM bias(LSB): %d, %d, %d\n",
+			sensor, lsb[0], lsb[1], lsb[2]);
+
+	if (lp_mode) {
+		result = inv_setup_sensors(st, sensor, ST_OFF, SENS_LPM);
+		if (result)
+			return result;
+		result = inv_calc_avg_with_samples(st, sensor, lsb_lp,
+				SELF_TEST_SAMPLE_NB, SENS_LPM);
+		if (result)
+			return result;
+		pr_info("sensor %d: LPM bias(LSB): %d, %d, %d\n",
+				sensor, lsb_lp[0], lsb_lp[1], lsb_lp[2]);
+	}
+
+	/* set bias output values */
+	for (i = 0; i < 3; i++) {
+		bias_lnm[i] = lsb[i];
+		bias_lpm[i] = lsb_lp[i];
+	}
+
+	/* self-test by DMP */
+	result = inv_run_dmp_selftest(st, sensor);
+
+	return result;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_lnm[3] = { 0 };
+	int accel_bias_lnm[3] = { 0 };
+	int gyro_bias_lpm[3] = { 0 };
+	int accel_bias_lpm[3] = { 0 };
+	int accel_result = 0;
+	int gyro_result = 0;
+	int i;
+
+	/* save registers */
+	/* idle bit will be set in this function */
+	result = inv_save_setting(st);
+	if (result)
+		goto test_fail;
+
+	/* initialization for self-test */
+	result = inv_init_selftest(st);
+	if (result)
+		goto test_fail;
+
+	/* accel self-test */
+	pr_info("accel self-test\n");
+	result = inv_do_selftest_dmp(st, SENSOR_ACCEL,
+			accel_bias_lnm, accel_bias_lpm, true);
+	if (result == 0) {
+		/* pass */
+		accel_result = 1;
+		/* output LPM bias */
+		for (i = 0; i < 3; i++)
+			st->accel_st_bias[i] =
+			    accel_bias_lpm[i] / SELF_TEST_PRECISION;
+	}
+
+	/* gyro self-test */
+	pr_info("gyro self-test\n");
+	result = inv_do_selftest_dmp(st, SENSOR_GYRO,
+			gyro_bias_lnm, gyro_bias_lpm, false);
+	if (result == 0) {
+		/* pass */
+		gyro_result = 1;
+		/* output LNM bias */
+		for (i = 0; i < 3; i++)
+			st->gyro_st_bias[i] =
+			    gyro_bias_lnm[i] / SELF_TEST_PRECISION;
+	}
+
+test_fail:
+	/* initialize SRAM */
+	result = inv_plat_single_write(st, REG_APEX_CONFIG0,
+			BIT_DMP_SRAM_RESET_APEX);
+	if (result)
+		return result;
+
+	usleep_range(1000, 1200);
+
+	/* Note:
+	 * Keep all APEX features disabled in APEX_CONFIG1 register
+	 * to reconfigure the features because SRAM is reset
+	 * in self-test process.
+	 */
+	/* restore registers */
+	inv_recover_setting(st);
+	st->apex_data.step_reset_last_val = true;
+
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_setup_43600.c b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_setup_43600.c
new file mode 100644
index 000000000000..51cd53c788de
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm43600/inv_mpu_setup_43600.c
@@ -0,0 +1,763 @@
+/*
+ * Copyright (C) 2017-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_get_actual_duration(int rate)
+{
+	int duration_ns;
+
+	if (rate > 400)
+		duration_ns = 1250000;
+	else if (rate > 200)
+		duration_ns = 2500000;
+	else if (rate > 100)
+		duration_ns = 5000000;
+	else if (rate > 50)
+		duration_ns = 10000000;
+	else if (rate > 25)
+		duration_ns = 20000000;
+	else if (rate > 12)
+		duration_ns = 40000000;
+	else if (rate > 6)
+		duration_ns = 80000000;
+	else if (rate > 3)
+		duration_ns = 160000000;
+	else
+		duration_ns = 320000000;
+
+	return duration_ns;
+}
+
+static int inv_calc_engine_dur(struct inv_mpu_state *st,
+				struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+int inv_turn_off_fifo(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st,
+		REG_FIFO_CONFIG1, BIT_FIFO_MODE_BYPASS);
+	if (res)
+		return res;
+	res = inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, 0);
+
+	return res;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	uint8_t data[3];
+	int r;
+	u8 int_source0 = 0;
+	u8 int_source1 = 0;
+	u8 int_source6 = 0;
+	u8 fifo_config5 = 0;
+	u8 wom_config = 0;
+
+	/* reset FIFO */
+	r = inv_plat_single_write(st,
+		REG_FIFO_CONFIG1, BIT_FIFO_MODE_BYPASS);
+	if (r)
+		return r;
+	r = inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, 0);
+	if (r)
+		return r;
+	r = inv_plat_read(st, REG_FIFO_BYTE_COUNT1, 2, data);
+	if (r)
+		return r;
+
+	/* create register values */
+	if (inv_get_apex_enabled(st)) {
+		/* enable WOM as long as APEX feature is
+		 * enabled to support DMP_POWER_SAVE_EN
+		 */
+		wom_config |= BIT_WOM_INT_MODE_AND | BIT_WOM_MODE_PREV | BIT_WOM_EN_ON;
+	}
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		if (st->chip_config.stationary_detect_enable)
+			st->gesture_int_count = STATIONARY_DELAY_THRESHOLD;
+		else
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+
+		r = inv_set_accel_intel(st);
+		if (r)
+			return r;
+		int_source1 |= BIT_INT_WOM_XYZ_INT1_EN;
+		wom_config |= BIT_WOM_INT_MODE_AND | BIT_WOM_MODE_PREV | BIT_WOM_EN_ON;
+	}
+
+	if (st->smd.on && st->smd_supported)
+		int_source1 |= BIT_INT_SMD_INT1_EN;
+
+	if (st->sensor[SENSOR_GYRO].on ||
+		st->sensor[SENSOR_ACCEL].on) {
+		if (st->batch.timeout) {
+			if (!st->batch.fifo_wm_th)
+				int_source0 |= BIT_INT_DRDY_INT_EN;
+			else
+				int_source0 |= BIT_INT_FIFO_THS_INT1_EN | BIT_INT_FIFO_FULL_INT1_EN;
+		} else {
+			int_source0 |= BIT_INT_DRDY_INT_EN;
+			if (st->chip_config.eis_enable)
+				int_source0 |= BIT_INT_FSYNC_INT1_EN;
+		}
+	}
+
+	if (st->sensor[SENSOR_GYRO].on || st->sensor[SENSOR_ACCEL].on)
+		fifo_config5 |= BIT_FIFO_ACCEL_EN | BIT_FIFO_GYRO_EN | BIT_WM_GT_TH;
+	if (st->chip_config.high_res_mode)
+		fifo_config5 |= BIT_FIFO_HIRES_EN;
+
+	if (st->step_detector_l_on || st->step_detector_wake_l_on ||
+			((st->step_counter_wake_l_on || st->step_counter_l_on)
+			 && st->ped.int_mode))
+		int_source6 |= BIT_INT_STEP_DET_INT1_EN;
+	if (st->chip_config.tilt_enable)
+		int_source6 |= BIT_INT_TLT_DET_INT1_EN;
+
+	/* Update registers */
+	r = inv_plat_single_write(st, REG_WOM_CONFIG, wom_config);
+	if (r)
+		return r;
+	r = inv_mreg_single_write(st, REG_FIFO_CONFIG5_MREG_TOP1, fifo_config5);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_CONFIG1, BIT_FIFO_MODE_NO_BYPASS);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_SOURCE0, int_source0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_INT_SOURCE1, int_source1);
+	if (r)
+		return r;
+	r = inv_mreg_single_write(st, REG_INT_SOURCE6_MREG_TOP1, int_source6);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int accel_rate, gyro_rate;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	accel_rate = 800 / st->eng_info[ENGINE_ACCEL].divider;
+	gyro_rate = 800 / st->eng_info[ENGINE_GYRO].divider;
+
+	if (accel_rate >= 800)
+		ts_algo->first_drop_samples[SENSOR_ACCEL] =
+			FIRST_DROP_SAMPLES_ACC_800HZ;
+	else if (accel_rate >= 200)
+		ts_algo->first_drop_samples[SENSOR_ACCEL] =
+			FIRST_DROP_SAMPLES_ACC_200HZ;
+	else
+		ts_algo->first_drop_samples[SENSOR_ACCEL] = 1;
+
+	if (gyro_rate >= 800)
+		ts_algo->first_drop_samples[SENSOR_GYRO] =
+			FIRST_DROP_SAMPLES_GYR_800HZ;
+	else if (gyro_rate >= 200)
+		ts_algo->first_drop_samples[SENSOR_GYRO] =
+			FIRST_DROP_SAMPLES_GYR_200HZ;
+	else
+		ts_algo->first_drop_samples[SENSOR_GYRO] = 1;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int r;
+	unsigned int wait_ms;
+	int accel_rate, gyro_rate;
+
+	accel_rate = 800 / st->eng_info[ENGINE_ACCEL].divider;
+	gyro_rate = 800 / st->eng_info[ENGINE_GYRO].divider;
+	r = inv_plat_read(st, REG_PWR_MGMT_0, 1, &v);
+	if (r)
+		return r;
+	w = v & ~(BIT_GYRO_MODE_LNM | BIT_ACCEL_MODE_LNM);
+	if (st->chip_config.gyro_enable) {
+		/* gyro support low noise mode only */
+		w |= BIT_GYRO_MODE_LNM;
+	}
+	if (st->chip_config.accel_enable ||
+		inv_get_apex_enabled(st)) {
+#ifdef SUPPORT_ACCEL_LPM
+		if (accel_rate > ACC_LPM_MAX_RATE)
+			w |= BIT_ACCEL_MODE_LNM;
+		else
+			w |= BIT_ACCEL_MODE_LPM;
+#else
+		w |= BIT_ACCEL_MODE_LNM;
+#endif
+	}
+	r = inv_plat_single_write(st, REG_PWR_MGMT_0, w);
+	if (r)
+		return r;
+	usleep_range(1000, 1001);
+	wait_ms = 0;
+	if (st->chip_config.gyro_enable && !(v & BIT_GYRO_MODE_LNM))
+		wait_ms = INV_ICM43600_GYRO_START_TIME;
+	if ((v & BIT_GYRO_MODE_LNM) && !st->chip_config.gyro_enable) {
+		if (wait_ms < INV_ICM43600_GYRO_STOP_TIME)
+			wait_ms = INV_ICM43600_GYRO_STOP_TIME;
+	}
+	if ((st->chip_config.accel_enable || inv_get_apex_enabled(st)) &&
+		!(v & BIT_ACCEL_MODE_LNM)) {
+		if (wait_ms < INV_ICM43600_ACCEL_START_TIME)
+			wait_ms = INV_ICM43600_ACCEL_START_TIME;
+	}
+	if (wait_ms)
+		msleep(wait_ms);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur;
+			st->sensor[i].div = 1;
+		}
+	}
+
+	return 0;
+}
+
+static int inv_set_odr_and_filter(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result;
+	int accel_hz, gyro_hz;
+	bool apex_only;
+	u8 a_odr, a_lpm_filter, a_lnm_filter;
+	u8 g_odr, g_lpm_filter, g_lnm_filter;
+	u8 data;
+
+	accel_hz = 800 / (a_d + 1);
+	gyro_hz = 800 / (g_d + 1);
+
+	/* accel ODR and filter */
+	if (accel_hz > 400) {
+		a_odr = BIT_SENSOR_ODR_800HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_180HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_2X;
+	} else if (accel_hz > 200) {
+		a_odr = BIT_SENSOR_ODR_400HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_180HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_8X;
+	} else if (accel_hz > 100) {
+		a_odr = BIT_SENSOR_ODR_200HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_121HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_16X;
+	} else if (accel_hz > 50) {
+		a_odr = BIT_SENSOR_ODR_100HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_53HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_32X;
+	} else if (accel_hz > 25) {
+		a_odr = BIT_SENSOR_ODR_50HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_25HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_64X;
+	} else if (accel_hz > 12) {
+		a_odr = BIT_SENSOR_ODR_25HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_16HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_64X;
+	} else if (accel_hz > 6) {
+		a_odr = BIT_SENSOR_ODR_12HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_16HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_64X;
+	} else if (accel_hz > 3) {
+		a_odr = BIT_SENSOR_ODR_6HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_16HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_64X;
+	} else {
+		a_odr = BIT_SENSOR_ODR_3HZ;
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_16HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_64X;
+	}
+
+	/* only apex is enabled */
+	if (inv_get_apex_enabled(st) && !st->chip_config.accel_enable &&
+			!st->gesture_only_on)
+		apex_only = true;
+	else
+		apex_only = false;
+
+	if (apex_only) {
+		a_lnm_filter = BIT_ACC_FILT_BW_IND_180HZ;
+		a_lpm_filter = BIT_ACC_UI_AVG_IND_2X;
+	}
+
+	/* gyro ODR and filter */
+	if (gyro_hz > 400) {
+		g_odr = BIT_SENSOR_ODR_800HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_180HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_2X;
+	} else if (gyro_hz > 200) {
+		g_odr = BIT_SENSOR_ODR_400HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_180HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_8X;
+	} else if (gyro_hz > 100) {
+		g_odr = BIT_SENSOR_ODR_200HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_121HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_16X;
+	} else if (gyro_hz > 50) {
+		g_odr = BIT_SENSOR_ODR_100HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_53HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_32X;
+	} else if (gyro_hz > 25) {
+		g_odr = BIT_SENSOR_ODR_50HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_25HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_64X;
+	} else if (gyro_hz > 12) {
+		g_odr = BIT_SENSOR_ODR_25HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_16HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_64X;
+	} else if (gyro_hz > 6) {
+		g_odr = BIT_SENSOR_ODR_12HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_16HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_64X;
+	} else if (gyro_hz > 3) {
+		g_odr = BIT_SENSOR_ODR_6HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_16HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_64X;
+	} else {
+		g_odr = BIT_SENSOR_ODR_3HZ;
+		g_lnm_filter = BIT_GYR_UI_FLT_BW_16HZ;
+		g_lpm_filter = BIT_GYR_UI_AVG_IND_64X;
+	}
+
+	/* update registers */
+	data = ((3 - st->chip_config.accel_fs) << SHIFT_ACCEL_FS_SEL) | a_odr;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG0, data);
+	if (result)
+		return result;
+
+	data = ((3 - st->chip_config.fsr) << SHIFT_GYRO_FS_SEL) | g_odr;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG0, data);
+	if (result)
+		return result;
+
+	data = a_lpm_filter | a_lnm_filter;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG1, data);
+	if (result)
+		return result;
+
+	data = g_lpm_filter | g_lnm_filter;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG1, data);
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+	int res = 0;
+	u32 w;
+	u32 running_rate;
+
+	if (st->sensor[SENSOR_ACCEL].on || st->sensor[SENSOR_GYRO].on) {
+		if (st->chip_config.high_res_mode)
+			st->batch.pk_size = 20;
+		else
+			st->batch.pk_size = 16;
+	} else
+		st->batch.pk_size = 0;
+	if (st->sensor[SENSOR_GYRO].on && !st->sensor[SENSOR_ACCEL].on)
+		running_rate = st->eng_info[ENGINE_GYRO].running_rate;
+	else if (!st->sensor[SENSOR_GYRO].on && st->sensor[SENSOR_ACCEL].on)
+		running_rate = st->eng_info[ENGINE_ACCEL].running_rate;
+	else
+		running_rate = st->eng_info[ENGINE_GYRO].running_rate;
+	if (st->batch.timeout) {
+		w = st->batch.timeout * running_rate
+					* st->batch.pk_size / 1000;
+		if (w > MAX_BATCH_FIFO_SIZE)
+			w = MAX_BATCH_FIFO_SIZE;
+	} else {
+		w = 0;
+	}
+	st->batch.fifo_wm_th = w;
+	pr_debug("running= %d, pksize=%d, to=%d w=%d\n",
+		running_rate, st->batch.pk_size, st->batch.timeout, w);
+
+	res = inv_plat_single_write(st, REG_FIFO_CONFIG2, w & 0xff);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_FIFO_CONFIG3, (w >> 8) & 0xff);
+
+	return res;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+
+	result = inv_set_odr_and_filter(st, a_d, g_d);
+	if (result)
+		return result;
+
+	result = inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_enable_apex_gestures(struct inv_mpu_state *st)
+{
+	int result;
+	u8 w, r;
+	unsigned int wait_ms = 0;
+
+	result = inv_plat_read(st, REG_APEX_CONFIG1, 1, &r);
+	if (result)
+		return result;
+
+	w = BIT_DMP_ODR_50HZ;
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on ||
+		st->step_counter_l_on ||
+		st->step_counter_wake_l_on ||
+		st->smd.on)
+		w |= BIT_DMP_PEDO_EN;
+	if (st->chip_config.tilt_enable)
+		w |= BIT_DMP_TILT_EN;
+	if (st->smd.on)
+		w |= BIT_DMP_SMD_EN;
+
+	if (r != w) {
+		if (!(r & BIT_DMP_PEDO_EN) && (w & BIT_DMP_PEDO_EN)) {
+			/* give DMP some time to push the latest step count
+			 * to data register
+			 */
+			wait_ms = 50;
+		}
+		if (!(r & (BIT_DMP_PEDO_EN | BIT_DMP_TILT_EN | BIT_DMP_SMD_EN)) &&
+			(w & (BIT_DMP_PEDO_EN | BIT_DMP_TILT_EN | BIT_DMP_SMD_EN))) {
+			/* first time to enable apex features in DMP */
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0, BIT_DMP_INIT_EN);
+			if (result)
+				return result;
+			msleep(50);
+			result = inv_plat_single_write(st, REG_APEX_CONFIG1, w);
+			if (result)
+				return result;
+			if (wait_ms)
+				msleep(wait_ms);
+#ifndef NOT_SET_DMP_POWER_SAVE
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0, BIT_DMP_POWER_SAVE_EN);
+			if (result)
+				return result;
+#endif
+		} else if (!(w & (BIT_DMP_PEDO_EN | BIT_DMP_TILT_EN | BIT_DMP_SMD_EN))) {
+			/* disable all apex features in DMP */
+			result = inv_plat_single_write(st, REG_APEX_CONFIG1, w);
+			if (result)
+				return result;
+			result = inv_plat_single_write(st, REG_APEX_CONFIG0,
+					BIT_DMP_SRAM_RESET_APEX | BIT_DMP_POWER_SAVE_EN);
+			if (result)
+				return result;
+			usleep_range(1000, 1001);
+		} else {
+			/* update apex features in DMP, additionally enalbe or disable
+			 * some but at least one is still enabled
+			 */
+			result = inv_plat_single_write(st, REG_APEX_CONFIG1, w);
+			if (result)
+				return result;
+			if (wait_ms)
+				msleep(wait_ms);
+		}
+
+		if (!(r & BIT_DMP_PEDO_EN) && (w & BIT_DMP_PEDO_EN))
+			st->apex_data.step_reset_last_val = true;
+		else
+			st->apex_data.step_reset_last_val = false;
+	}
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	gyro_rate = MPU_INIT_SENSOR_RATE_LNM;
+#ifdef SUPPORT_ACCEL_LPM
+	accel_rate = MPU_INIT_SENSOR_RATE_LPM;
+#else
+	accel_rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif
+	/*
+	 * loop the streaming sensors to see which engine needs to be turned on
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	if (g_en)
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	else
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+
+	if (st->chip_config.eis_enable) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+					    ((BASE_SAMPLE_RATE /
+						 st->eng_info[ENGINE_GYRO].divider) /
+						 st->sensor_l[i].rate);
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider =
+			inv_get_actual_duration(st->eng_info[ENGINE_GYRO].running_rate) / 1250000;
+		st->eng_info[ENGINE_ACCEL].divider =
+			inv_get_actual_duration(st->eng_info[ENGINE_ACCEL].running_rate) / 1250000;
+	}
+
+	for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(st, &st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	inv_set_idle(st);
+
+	inv_stop_interrupt(st);
+	inv_turn_off_fifo(st);
+	inv_determine_engine(st);
+
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+
+	if (st->apex_supported) {
+		result = inv_enable_apex_gestures(st);
+		if (result) {
+			pr_err("inv_enable_apex_gestures error\n");
+			return result;
+		}
+	}
+
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+
+	inv_reset_idle(st);
+
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!inv_get_apex_enabled(st))) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_SOURCE0, 1, &st->int_en);
+	if (res)
+		return res;
+	res = inv_plat_read(st, REG_INT_SOURCE1, 1, &st->int_en_2);
+	if (res)
+		return res;
+	res = inv_mreg_read(st, REG_INT_SOURCE6_MREG_TOP1, 1, &st->int_en_6);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE1, 0);
+	if (res)
+		return res;
+	res = inv_mreg_single_write(st, REG_INT_SOURCE6_MREG_TOP1, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, st->int_en);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_INT_SOURCE1, st->int_en_2);
+	if (res)
+		return res;
+	res = inv_mreg_single_write(st, REG_INT_SOURCE6_MREG_TOP1, st->int_en_6);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, 0);
+
+	return res;
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_SOURCE0, st->int_en);
+
+	return res;
+}
+
+/* dummy function for 20608D */
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	return 0;
+}
+
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	return 0;
+}
+
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_common.c b/drivers/iio/imu/inv_mpu/inv_mpu_common.c
new file mode 100644
index 000000000000..d844ea7b6fe0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_common.c
@@ -0,0 +1,1380 @@
+/*
+ * Copyright (C) 2012-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "inv_mpu_iio.h"
+#ifdef CONFIG_RTC_INTF_ALARM
+#include <linux/android_alarm.h>
+#endif
+#include <linux/export.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_RTC_INTF_ALARM
+s64 get_time_ns(void)
+{
+	struct timespec ts;
+
+	/* get_monotonic_boottime(&ts); */
+
+	/* Workaround for some platform on which monotonic clock and
+	 * Android SystemClock has a gap.
+	 * Use ktime_to_timespec(alarm_get_elapsed_realtime()) instead of
+	 * get_monotonic_boottime() for these platform
+	 */
+
+	ts = ktime_to_timespec(alarm_get_elapsed_realtime());
+
+	return timespec_to_ns(&ts);
+}
+#else
+s64 get_time_ns(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)
+	/* kernel ~4.18 */
+	struct timespec ts;
+	get_monotonic_boottime(&ts);
+	return timespec_to_ns(&ts);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+	/* kernel 4.19~5.2 */
+	return ktime_get_boot_ns();
+#else
+	/* kernel 5.3~ */
+	return ktime_get_boottime_ns();
+#endif
+}
+
+#endif
+
+#ifdef ACCEL_BIAS_TEST
+int inv_get_3axis_average(s16 src[], s16 dst[], s16 reset)
+{
+#define BUFFER_SIZE 200
+	static s16 buffer[BUFFER_SIZE][3];
+	static s16 current_position;
+	static s16 ready;
+	int sum[3] = {0,};
+	int i;
+
+	if (reset) {
+		current_position = 0;
+		ready = 0;
+	}
+	buffer[current_position][0] = src[0];
+	buffer[current_position][1] = src[1];
+	buffer[current_position][2] = src[2];
+	current_position++;
+	if (current_position == BUFFER_SIZE) {
+		ready = 1;
+		current_position = 0;
+	}
+	if (ready) {
+		for (i = 0; i < BUFFER_SIZE; i++) {
+			sum[0] += buffer[i][0];
+			sum[1] += buffer[i][1];
+			sum[2] += buffer[i][2];
+		}
+		dst[0] = sum[0]/BUFFER_SIZE;
+		dst[1] = sum[1]/BUFFER_SIZE;
+		dst[2] = sum[2]/BUFFER_SIZE;
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+int inv_q30_mult(int a, int b)
+{
+#define DMP_MULTI_SHIFT                 30
+	u64 temp;
+	int result;
+
+	temp = ((u64)a) * b;
+	result = (int)(temp >> DMP_MULTI_SHIFT);
+
+	return result;
+}
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+					defined(CONFIG_INV_MPU_IIO_ICM20690)
+/* inv_read_secondary(): set secondary registers for reading.
+ * ICM20648: The chip must be set as bank 3 before calling.
+ */
+int inv_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+		       int reg, int len)
+{
+	int result;
+
+	/* I2C address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].addr,
+				       INV_MPU_BIT_I2C_READ | addr);
+	if (result)
+		return result;
+	/* Register address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].reg, reg);
+	if (result)
+		return result;
+	/* Enable SLV channel */
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl,
+				       INV_MPU_BIT_SLV_EN | len);
+
+	return result;
+}
+
+int inv_execute_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			       int reg, int len, u8 *d)
+{
+	int result;
+
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_read_secondary(st, ind, addr, reg, len);
+	if (result)
+		return result;
+
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+				       BIT_I2C_MST_EN);
+	if (result)
+		return result;
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00, len, d);
+	if (result)
+		return result;
+
+	/* Disable SLV channel */
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl, 0);
+	inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+/* inv_write_secondary(): set secondary registers for writing.
+ * ICM20648: The chip must be set as bank 3 before calling.
+ */
+int inv_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int v)
+{
+	int result;
+
+	/* I2C address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].addr, addr);
+	if (result)
+		return result;
+	/* Register address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].reg, reg);
+	if (result)
+		return result;
+	/* Output data */
+	result = inv_plat_single_write(st, st->slv_reg[ind].d0, v);
+	if (result)
+		return result;
+	/* Enable SLV channel */
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl,
+				       INV_MPU_BIT_SLV_EN | 1);
+
+	return result;
+}
+
+int inv_execute_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+				int reg, int v)
+{
+	int result;
+
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_write_secondary(st, ind, addr, reg, v);
+	if (result)
+		return result;
+
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+				       BIT_I2C_MST_EN);
+	if (result)
+		return result;
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+
+	/* Disable SLV channel */
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl, 0);
+	inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_bank(struct inv_mpu_state *st, u8 bank)
+{
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	int r;
+
+	r = inv_plat_single_write(st, REG_BANK_SEL, bank);
+
+	return r;
+#else
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+/**
+ *  inv_write_cntl() - Write control word to designated address.
+ *  @st:	Device driver instance.
+ *  @wd:        control word.
+ *  @en:	enable/disable.
+ *  @cntl:	control address to be written.
+ */
+int inv_write_cntl(struct inv_mpu_state *st, u16 wd, bool en, int cntl)
+{
+	int result;
+	u8 reg[2], d_out[2];
+
+	result = mem_r(cntl, 2, d_out);
+	if (result)
+		return result;
+	reg[0] = ((wd >> 8) & 0xff);
+	reg[1] = (wd & 0xff);
+	if (!en) {
+		d_out[0] &= ~reg[0];
+		d_out[1] &= ~reg[1];
+	} else {
+		d_out[0] |= reg[0];
+		d_out[1] |= reg[1];
+	}
+	result = mem_w(cntl, 2, d_out);
+
+	return result;
+}
+#endif
+
+int inv_set_power(struct inv_mpu_state *st, bool power_on)
+{
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || defined(CONFIG_INV_MPU_IIO_ICM43600)
+	if ((!power_on) == st->chip_config.is_asleep)
+		return 0;
+	st->chip_config.is_asleep = !power_on;
+#else
+	u8 d;
+	int r;
+
+	if ((!power_on) == st->chip_config.is_asleep)
+		return 0;
+
+	d = BIT_CLK_PLL;
+	if (!power_on)
+		d |= BIT_SLEEP;
+
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, d);
+	if (r)
+		return r;
+
+	if (power_on)
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+
+	st->chip_config.is_asleep = !power_on;
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_set_power);
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	u8 w;
+
+	if ((!st->chip_config.is_asleep) &&
+	    ((!on) == st->chip_config.lp_en_set))
+		return 0;
+
+	w = BIT_CLK_PLL;
+	if ((!on) && (!st->eis.eis_triggered))
+		w |= BIT_LP_EN;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	if (on)
+		usleep_range(70, 100);
+	st->chip_config.is_asleep = 0;
+	st->chip_config.lp_en_set = (!on);
+	return r;
+}
+#endif
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20690) \
+	|| defined(CONFIG_INV_MPU_IIO_IAM20680)
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode)
+{
+	int cycle_freq[] = {275, 192, 111, 59};
+	int cont_freq[] = {219, 219, 99, 45, 22, 11, 6};
+	int i, r, rate;
+	u8 v;
+
+	v = 0;
+#ifdef CONFIG_INV_MPU_IIO_ICM20690
+	v |= BIT_FIFO_SIZE_1K;
+#endif
+	if (cycle_mode) {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate << 1);
+		i = ARRAY_SIZE(cycle_freq) - 1;
+		while (i > 0) {
+			if (rate < cycle_freq[i])
+				break;
+			i--;
+		}
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, v |
+								(i << 4) | 7);
+		if (r)
+			return r;
+		st->accel_lp_mode = 1;
+	} else {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate >> 1);
+		for (i = 1; i < ARRAY_SIZE(cont_freq); i++) {
+			if (rate >= cont_freq[i])
+				break;
+		}
+		if (i > 6)
+			i = 6;
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, v | i);
+		if (r)
+			return r;
+		st->accel_lp_mode = 0;
+	}
+
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	bool cond_check;
+
+	if ((!st->chip_config.is_asleep) &&
+			((!on) == st->chip_config.lp_en_set))
+		return 0;
+
+	/* will set LP mode ? */
+	cond_check = (!on) && st->cycle_on;
+
+	/* wake up */
+	if (st->chip_config.is_asleep) {
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		inv_set_accel_config2(st, false);
+		st->chip_config.is_asleep = 0;
+		st->chip_config.lp_en_set = false;
+	}
+
+	/* set power mode */
+	if (st->chip_config.lp_en_set && !cond_check) {
+		/* LP -> LN */
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		inv_set_accel_config2(st, false);
+		st->chip_config.lp_en_set = false;
+	} else if (!st->chip_config.lp_en_set && cond_check) {
+		/* LN -> LP */
+		inv_set_accel_config2(st, true);
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1,
+				BIT_CLK_PLL | BIT_LP_EN);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		st->chip_config.lp_en_set = true;
+	}
+
+	return r;
+}
+#endif
+#ifdef CONFIG_INV_MPU_IIO_ICM20608D
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode)
+{
+	int cycle_freq[] = {442, 236, 122, 61};
+	int cont_freq[] = {219, 219, 99, 45, 22, 11, 6};
+	int i, r, rate;
+
+	if (cycle_mode) {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate << 1);
+		i = ARRAY_SIZE(cycle_freq) - 1;
+		while (i > 0) {
+			if (rate < cycle_freq[i])
+				break;
+			i--;
+		}
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, (i << 4) | 7);
+		if (r)
+			return r;
+	} else {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate >> 1);
+		for (i = 1; i < ARRAY_SIZE(cont_freq); i++) {
+			if (rate >= cont_freq[i])
+				break;
+		}
+		if (i > 6)
+			i = 6;
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, i);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	u8 w;
+	bool cond_check;
+
+	cond_check = (!on) && (!st->chip_config.eis_enable)
+					   && (!st->chip_config.gyro_enable);
+
+	w = BIT_CLK_PLL;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	if (r)
+		return r;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+	inv_set_accel_config2(st, cond_check);
+
+	if (cond_check)
+		w |= BIT_LP_EN;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	st->chip_config.is_asleep = 0;
+
+	return r;
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || defined(CONFIG_INV_MPU_IIO_ICM43600)
+int inv_set_accel_config2(struct inv_mpu_state *st, bool on)
+{
+	/* dummy */
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	/* dummy */
+	return 0;
+}
+#endif
+
+static int inv_lp_en_off_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+
+	if (!st->chip_config.is_asleep)
+		return 0;
+
+#if !defined(CONFIG_INV_MPU_IIO_ICM42600) && !defined(CONFIG_INV_MPU_IIO_ICM43600)
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+#endif
+	st->chip_config.is_asleep = 0;
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20690) || \
+	defined(CONFIG_INV_MPU_IIO_IAM20680) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	inv_set_accel_config2(st, false);
+#endif
+	return r;
+}
+
+int inv_switch_power_in_lp(struct inv_mpu_state *st, bool on)
+{
+	int r;
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || defined(CONFIG_INV_MPU_IIO_ICM43600)
+	/* nothing to do, dummy */
+	return 0;
+#endif
+	if (st->chip_config.lp_en_mode_off)
+		r = inv_lp_en_off_mode(st, on);
+	else
+		r = inv_lp_en_on_mode(st, on);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(inv_switch_power_in_lp);
+
+int write_be16_to_mem(struct inv_mpu_state *st, u16 data, int addr)
+{
+	u8 d[2];
+
+	d[0] = (data >> 8) & 0xff;
+	d[1] = data & 0xff;
+
+	return mem_w(addr, sizeof(d), d);
+}
+
+int write_be32_to_mem(struct inv_mpu_state *st, u32 data, int addr)
+{
+	cpu_to_be32s(&data);
+	return mem_w(addr, sizeof(data), (u8 *)&data);
+}
+
+int read_be16_from_mem(struct inv_mpu_state *st, u16 *o, int addr)
+{
+	int result;
+	u8 d[2];
+
+	result = mem_r(addr, 2, (u8 *) &d);
+	*o = d[0] << 8 | d[1];
+
+	return result;
+}
+
+int read_be32_from_mem(struct inv_mpu_state *st, u32 *o, int addr)
+{
+	int result;
+	u32 d = 0;
+
+	result = mem_r(addr, 4, (u8 *) &d);
+	*o = be32_to_cpup((__be32 *)(&d));
+
+	return result;
+}
+
+int be32_to_int(u8 *d)
+{
+	return (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | d[3];
+}
+
+u32 inv_get_cntr_diff(u32 curr_counter, u32 prev)
+{
+	u32 diff;
+
+	if (curr_counter > prev)
+		diff = curr_counter - prev;
+	else
+		diff = 0xffffffff - prev + curr_counter + 1;
+
+	return diff;
+}
+
+int inv_write_2bytes(struct inv_mpu_state *st, int addr, int data)
+{
+	u8 d[2];
+
+	if (data < 0 || data > USHRT_MAX)
+		return -EINVAL;
+
+	d[0] = (u8) ((data >> 8) & 0xff);
+	d[1] = (u8) (data & 0xff);
+
+	return mem_w(addr, ARRAY_SIZE(d), d);
+}
+
+
+
+int inv_process_eis(struct inv_mpu_state *st, u16 delay)
+{
+	int tmp1, tmp2, tmp3;
+
+	switch (st->eis.voting_state) {
+	case 0:
+		st->eis.gyro_counter_s[0] = st->eis.gyro_counter;
+		st->eis.fsync_delay_s[0] = delay - st->eis.fsync_delay;
+		st->eis.voting_count = 1;
+		st->eis.voting_count_sub = 0;
+		st->eis.voting_state = 1;
+		break;
+	case 1:
+		if (abs(st->eis.gyro_counter_s[0] -
+						st->eis.gyro_counter) <= 1) {
+			st->eis.voting_count++;
+		} else {
+			st->eis.gyro_counter_s[2] = st->eis.gyro_counter;
+			st->eis.voting_count_sub++;
+			st->eis.voting_state = 2;
+		}
+		if (st->eis.voting_count > 5)
+			st->eis.voting_state = 3;
+		break;
+	case 2:
+		tmp1 = abs(st->eis.gyro_counter_s[0] - st->eis.gyro_counter);
+		tmp2 = abs(st->eis.gyro_counter_s[2] - st->eis.gyro_counter);
+
+		if ((tmp1 < tmp2) && (tmp1 <= 1))
+			st->eis.voting_count++;
+		else
+			st->eis.voting_count_sub++;
+		if (st->eis.voting_count > 5) {
+			st->eis.voting_state = 3;
+			st->eis.voting_count = 0;
+			st->eis.voting_count_sub = 0;
+		}
+
+		if (st->eis.voting_count_sub > 5) {
+			st->eis.gyro_counter_s[0] = st->eis.gyro_counter;
+			st->eis.fsync_delay_s[0] = delay - st->eis.fsync_delay;
+			st->eis.voting_state = 1;
+			st->eis.voting_count = 1;
+			st->eis.voting_count_sub = 0;
+		}
+		break;
+	case 3:
+		tmp1 = abs(st->eis.gyro_counter_s[0] - st->eis.gyro_counter);
+		if (tmp1 == 1) {
+			st->eis.gyro_counter_s[1] = st->eis.gyro_counter;
+			st->eis.fsync_delay_s[1] = delay - st->eis.fsync_delay;
+			st->eis.voting_state = 4;
+			st->eis.voting_count_sub = 1;
+			st->eis.voting_count = 1;
+		}
+		break;
+	case 4:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[0]) {
+			tmp1 = delay - st->eis.fsync_delay;
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[0]);
+			if (tmp2 < 3) {
+				st->eis.voting_count++;
+			} else {
+				st->eis.fsync_delay_s[2] = tmp1;
+				st->eis.voting_count_sub = 1;
+				st->eis.voting_state = 5;
+			}
+			if (st->eis.voting_count > 5) {
+				st->eis.voting_count = 1;
+				st->eis.voting_state = 6;
+			}
+		}
+		break;
+	case 5:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[0]) {
+			tmp1 = delay - st->eis.fsync_delay;
+
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[0]);
+			tmp3 = abs(tmp1 - st->eis.fsync_delay_s[2]);
+			if ((tmp2 < tmp3) && (tmp2 < 3))
+				st->eis.voting_count++;
+			else
+				st->eis.voting_count_sub++;
+			if ((st->eis.voting_count > 5) &&
+					(st->eis.voting_count_sub
+					< st->eis.voting_count)) {
+				st->eis.voting_state = 6;
+				st->eis.voting_count = 1;
+			} else if (st->eis.voting_count_sub > 5) {
+				st->eis.fsync_delay_s[0] = tmp1;
+				st->eis.voting_state = 4;
+				st->eis.voting_count = 1;
+			}
+
+		}
+		break;
+	case 6:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[1]) {
+			tmp1 = delay - st->eis.fsync_delay;
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[1]);
+			if (tmp2 < 3) {
+				st->eis.voting_count++;
+			} else {
+				st->eis.fsync_delay_s[2] = tmp1;
+				st->eis.voting_count_sub = 1;
+				st->eis.voting_count = 1;
+				st->eis.voting_state = 7;
+			}
+			if (st->eis.voting_count > 5)
+				st->eis.voting_state = 8;
+		}
+		break;
+	case 7:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[1]) {
+			tmp1 = delay - st->eis.fsync_delay;
+
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[1]);
+			tmp3 = abs(tmp1 - st->eis.fsync_delay_s[2]);
+			if ((tmp2 < tmp3) && (tmp2 < 3))
+				st->eis.voting_count++;
+			else
+				st->eis.voting_count_sub++;
+			if ((st->eis.voting_count > 5) &&
+					(st->eis.voting_count_sub
+					< st->eis.voting_count)) {
+				st->eis.voting_state = 8;
+			} else if (st->eis.voting_count_sub > 5) {
+				st->eis.fsync_delay_s[1] = tmp1;
+				st->eis.voting_state = 6;
+				st->eis.voting_count = 1;
+			}
+
+		}
+		break;
+	default:
+		break;
+	}
+
+	pr_debug("de= %d gc= %d\n", delay, st->eis.gyro_counter);
+	st->eis.fsync_delay = delay;
+	st->eis.gyro_counter = 0;
+
+	pr_debug("state=%d g1= %d d1= %d g2= %d d2= %d\n",
+			st->eis.voting_state,
+			st->eis.gyro_counter_s[0],
+			st->eis.fsync_delay_s[0],
+			st->eis.gyro_counter_s[1],
+			st->eis.fsync_delay_s[1]);
+
+	return 0;
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data)
+{
+	int out_hz;
+
+	if (data > 500)
+		out_hz = 1000;
+	else if (data > 200)
+		out_hz = 500;
+	else if (data > 100)
+		out_hz = 200;
+	else if (data > 50)
+		out_hz = 100;
+	else if (data > 25)
+		out_hz = 50;
+	else if (data > 12)
+		out_hz = 25;
+	else if (data > 6)
+		out_hz = 12;
+	else if (data > 3)
+		out_hz = 6;
+	else
+		out_hz = 3;
+
+	return out_hz;
+}
+#elif defined(CONFIG_INV_MPU_IIO_ICM43600)
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data)
+{
+	int out_hz;
+
+	if (data > 400)
+		out_hz = 800;
+	else if (data > 200)
+		out_hz = 400;
+	else if (data > 100)
+		out_hz = 200;
+	else if (data > 50)
+		out_hz = 100;
+	else if (data > 25)
+		out_hz = 50;
+	else if (data > 12)
+		out_hz = 25;
+	else if (data > 6)
+		out_hz = 12;
+	else if (data > 3)
+		out_hz = 6;
+	else
+		out_hz = 3;
+
+	return out_hz;
+}
+#else
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data)
+{
+	int t, out, out1, out2;
+	int base_freq;
+
+	if (data <= MPU_DEFAULT_DMP_FREQ)
+		base_freq = MPU_DEFAULT_DMP_FREQ;
+	else
+		base_freq = BASE_SAMPLE_RATE;
+
+	t = base_freq / data;
+	if (!t)
+		t = 1;
+	out1 = base_freq / (t + 1);
+	out2 = base_freq / t;
+	if ((data - out1) * INV_ODR_BUFFER_MULTI < data)
+		out = out1;
+	else
+		out = out2;
+
+	return out;
+}
+#endif
+
+static void inv_check_wake_non_wake(struct inv_mpu_state *st,
+			enum SENSOR_L wake, enum SENSOR_L non_wake)
+{
+	int tmp_rate;
+
+	if (!st->sensor_l[wake].on && !st->sensor_l[non_wake].on)
+		return;
+
+	tmp_rate = 0;
+	if (st->sensor_l[wake].on)
+		tmp_rate = st->sensor_l[wake].rate;
+	if (st->sensor_l[non_wake].on)
+		tmp_rate = max(tmp_rate, st->sensor_l[non_wake].rate);
+	st->sensor_l[wake].rate = tmp_rate;
+	st->sensor_l[non_wake].rate = tmp_rate;
+}
+
+static void inv_check_wake_non_wake_divider(struct inv_mpu_state *st,
+			enum SENSOR_L wake, enum SENSOR_L non_wake)
+{
+	if (st->sensor_l[wake].on && st->sensor_l[non_wake].on)
+		st->sensor_l[non_wake].div = 0xffff;
+
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20690) \
+	|| defined(CONFIG_INV_MPU_IIO_IAM20680)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	int max_rate;
+	int i;
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+					SENSOR_L_MAG_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG};
+
+	/* initialize rates */
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate = GESTURE_ACCEL_RATE;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	/* set GESTURE_ACCEL on to support gestures at HAL */
+	if (st->step_detector_l_on
+			|| st->step_detector_wake_l_on
+			|| st->step_counter_l_on
+			|| st->step_counter_wake_l_on
+			|| st->chip_config.pick_up_enable
+			|| st->chip_config.tilt_enable
+			|| st->chip_config.stationary_detect_enable
+			|| st->chip_config.motion_detect_enable)
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = true;
+	else
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = false;
+
+	/* set wake_on according to enabled sensors */
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+
+	/* only gesture accel is enabled? */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on &&
+			(!st->sensor_l[SENSOR_L_ACCEL].on &&
+				!st->sensor_l[SENSOR_L_ACCEL_WAKE].on) &&
+			(!st->sensor[SENSOR_GYRO].on) &&
+			(!st->sensor[SENSOR_COMPASS].on))
+		st->gesture_only_on = true;
+	else
+		st->gesture_only_on = false;
+
+	/* update rate to user side for sensors which are affected by gesture */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on &&
+					st->sensor_l[SENSOR_L_GESTURE_ACCEL].base ==
+					st->sensor_l[i].base) {
+				st->sensor_l[i].rate =
+					max(st->sensor_l[i].rate,
+							st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+			}
+		}
+	}
+
+	/* set rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+							st->sensor_l[i].rate);
+		}
+	}
+	max_rate = MPU_INIT_SENSOR_RATE;
+	if (st->chip_config.eis_enable) {
+		max_rate = ESI_GYRO_RATE;
+		st->sensor_l[SENSOR_L_EIS_GYRO].rate = ESI_GYRO_RATE;
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			max_rate = max(max_rate, st->sensor[i].rate);
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->sensor[i].rate = max_rate;
+	}
+
+	/* set rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	/* calculate decimation rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+							/ st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+			pr_debug("sensor= %d, div= %d\n",
+						i, st->sensor_l[i].div);
+		}
+	}
+
+	/* set decimation rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	return 0;
+}
+#elif defined(CONFIG_INV_MPU_IIO_ICM42600)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	int i;
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+					SENSOR_L_MAG_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG};
+
+	/* initialize rates */
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate = GESTURE_ACCEL_RATE;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+#if defined(SUPPORT_ACCEL_LPM)
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LPM;
+	st->sensor[SENSOR_GYRO].rate = MPU_INIT_SENSOR_RATE_LNM;
+#else
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif /* SUPPORT_ACCEL_LPM */
+
+	/* set GESTURE_ACCEL on to support gestures at HAL */
+	if ((!st->apex_supported &&
+				(st->step_detector_wake_l_on
+				 || st->step_counter_l_on
+				 || st->step_counter_wake_l_on
+				 || st->chip_config.pick_up_enable
+				 || st->chip_config.tilt_enable))
+			|| st->chip_config.stationary_detect_enable
+			||st->chip_config.motion_detect_enable)
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = true;
+	else
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = false;
+
+	/* set wake_on according to enabled sensors */
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+	/* set wake_on when DMP/HW wake-up gestures are enabled */
+	if (st->step_detector_wake_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.pick_up_enable ||
+			st->chip_config.tilt_enable ||
+			st->chip_config.tap_enable)
+		st->chip_config.wake_on = true;
+
+	/* only gesture accel is enabled? */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on &&
+			(!st->sensor_l[SENSOR_L_ACCEL].on &&
+				!st->sensor_l[SENSOR_L_ACCEL_WAKE].on) &&
+			(!st->sensor[SENSOR_GYRO].on) &&
+			(!st->sensor[SENSOR_COMPASS].on))
+		st->gesture_only_on = true;
+	else
+		st->gesture_only_on = false;
+
+	/* update rate to user side for sensors which are affected by gesture */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on &&
+					st->sensor_l[SENSOR_L_GESTURE_ACCEL].base ==
+					st->sensor_l[i].base) {
+				st->sensor_l[i].rate =
+					max(st->sensor_l[i].rate,
+							st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+			}
+		}
+	}
+
+	/* set rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+							st->sensor_l[i].rate);
+		}
+	}
+	if (st->chip_config.eis_enable)
+		st->sensor_l[SENSOR_L_EIS_GYRO].rate = ESI_GYRO_RATE;
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+	}
+	if (inv_get_apex_enabled(st)) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			inv_get_apex_odr(st));
+	}
+
+	/* set rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	/* calculate decimation rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+							/ st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+			pr_debug("sensor= %d, div= %d\n",
+						i, st->sensor_l[i].div);
+		}
+	}
+
+	/* set decimation rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	return 0;
+}
+#elif defined(CONFIG_INV_MPU_IIO_ICM43600)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	int i;
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+					SENSOR_L_MAG_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG};
+
+	/* initialize rates */
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate = GESTURE_ACCEL_RATE;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+#if defined(SUPPORT_ACCEL_LPM)
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LPM;
+	st->sensor[SENSOR_GYRO].rate = MPU_INIT_SENSOR_RATE_LNM;
+#else
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif /* SUPPORT_ACCEL_LPM */
+
+	/* set GESTURE_ACCEL on to support gestures at HAL */
+	if ((!st->apex_supported &&
+				(st->step_detector_wake_l_on
+				 || st->step_counter_l_on
+				 || st->step_counter_wake_l_on
+				 || st->chip_config.tilt_enable))
+			|| st->chip_config.stationary_detect_enable
+			|| st->chip_config.motion_detect_enable)
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = true;
+	else
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = false;
+
+	/* set wake_on according to enabled sensors */
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+	/* set wake_on when DMP/HW wake-up gestures are enabled */
+	if (st->step_detector_wake_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.pick_up_enable ||
+			st->chip_config.tilt_enable ||
+			st->chip_config.tap_enable)
+		st->chip_config.wake_on = true;
+
+	/* only gesture accel is enabled? */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on &&
+			(!st->sensor_l[SENSOR_L_ACCEL].on &&
+				!st->sensor_l[SENSOR_L_ACCEL_WAKE].on) &&
+			(!st->sensor[SENSOR_GYRO].on) &&
+			(!st->sensor[SENSOR_COMPASS].on))
+		st->gesture_only_on = true;
+	else
+		st->gesture_only_on = false;
+
+	/* update rate to user side for sensors which are affected by gesture */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on &&
+					st->sensor_l[SENSOR_L_GESTURE_ACCEL].base ==
+					st->sensor_l[i].base) {
+				st->sensor_l[i].rate =
+					max(st->sensor_l[i].rate,
+							st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+			}
+		}
+	}
+
+	/* set rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+							st->sensor_l[i].rate);
+		}
+	}
+	if (st->chip_config.eis_enable)
+		st->sensor_l[SENSOR_L_EIS_GYRO].rate = ESI_GYRO_RATE;
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+	}
+	if (inv_get_apex_enabled(st)) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			inv_get_apex_odr(st));
+	}
+
+	/* set rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	/* calculate decimation rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+							/ st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+			pr_debug("sensor= %d, div= %d\n",
+						i, st->sensor_l[i].div);
+		}
+	}
+
+	/* set decimation rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	return 0;
+}
+#else /* ICM20608D/ICM20648 */
+static void inv_do_check_sensor_on(struct inv_mpu_state *st,
+				enum SENSOR_L *wake,
+				enum SENSOR_L *non_wake, int sensor_size)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+				st->sensor_l[i].rate);
+		}
+	}
+	for (i = 0; i < sensor_size; i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+				    / st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+		}
+	}
+	for (i = 0; i < sensor_size; i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	if (st->step_detector_wake_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.pick_up_enable ||
+			st->chip_config.tilt_enable ||
+			st->smd.on)
+		st->chip_config.wake_on = true;
+
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20608D)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+				SENSOR_L_SIXQ_WAKE, SENSOR_L_PEDQ_WAKE,
+				SENSOR_L_GYRO_CAL_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+				SENSOR_L_SIXQ, SENSOR_L_PEDQ,
+				SENSOR_L_GYRO_CAL};
+
+	inv_do_check_sensor_on(st, wake, non_wake, ARRAY_SIZE(wake));
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+				SENSOR_L_MAG_WAKE, SENSOR_L_ALS_WAKE,
+				SENSOR_L_SIXQ_WAKE, SENSOR_L_PEDQ_WAKE,
+				SENSOR_L_NINEQ_WAKE, SENSOR_L_GEOMAG_WAKE,
+				SENSOR_L_PRESSURE_WAKE,
+				SENSOR_L_GYRO_CAL_WAKE,
+				SENSOR_L_MAG_CAL_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG, SENSOR_L_ALS,
+					SENSOR_L_SIXQ, SENSOR_L_PEDQ,
+					SENSOR_L_NINEQ, SENSOR_L_GEOMAG,
+					SENSOR_L_PRESSURE,
+					SENSOR_L_GYRO_CAL,
+					SENSOR_L_MAG_CAL};
+
+	inv_do_check_sensor_on(st, wake, non_wake, ARRAY_SIZE(wake));
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static bool any_wakeup_streaming_enabled(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = SENSOR_L_ACCEL_WAKE; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on)
+			return true;
+	}
+	return false;
+}
+
+static int set_interrupt_for_suspend(struct inv_mpu_state *st)
+{
+	if (any_wakeup_streaming_enabled(st)) {
+		/* wakeup streaming sensor is enabled */
+		/* do nothing */
+	} else if (!st->chip_config.wake_on) {
+		/* no wakeup gesture is enabled, disable all interrupts */
+		inv_stop_interrupt(st);
+	} else {
+		/* wakeup gesture is enabled, stop streaming interrupts */
+		inv_stop_stream_interrupt(st);
+	}
+
+	return 0;
+}
+
+static int restore_interrupt_for_suspend(struct inv_mpu_state *st)
+{
+	if (any_wakeup_streaming_enabled(st)) {
+		/* wakeup streaming sensor is enabled */
+		/* do nothing */
+	} else if (!st->chip_config.wake_on) {
+		/* no wakeup gesture is enabled, do the opposite of suspend */
+		inv_restore_interrupt(st);
+	} else {
+		/* reenable streaming interrupts */
+		inv_restore_stream_interrupt(st);
+	}
+
+	return 0;
+}
+
+int inv_mpu_suspend(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	/* add code according to different request Start */
+	dev_info(st->dev, "%s suspend\n", st->hw->name);
+	mutex_lock(&st->lock);
+
+	st->resume_state = false;
+
+	set_interrupt_for_suspend(st);
+
+	if (st->chip_config.wake_on)
+		enable_irq_wake(st->irq);
+
+	mutex_unlock(&st->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_suspend);
+
+/*
+ * inv_mpu_complete(): complete method for this driver.
+ *    This method can be modified according to the request of different
+ *    customers. It basically undo everything suspend is doing
+ *    and recover the chip to what it was before suspend. We use complete to
+ *    make sure that alarm clock resume is finished. If we use resume, the
+ *    alarm clock may not resume yet and get incorrect clock reading.
+ */
+void inv_mpu_complete(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	dev_info(st->dev, "%s resume\n", st->hw->name);
+	if (st->resume_state)
+		return;
+
+	mutex_lock(&st->lock);
+
+	if (st->chip_config.wake_on)
+		disable_irq_wake(st->irq);
+
+	restore_interrupt_for_suspend(st);
+
+	/* resume state is used to synchronize read_fifo such that it won't
+	 * proceed unless resume is finished.
+	 */
+	st->resume_state = true;
+	/* resume flag is indicating that current clock reading is from resume,
+	 * it has up to 1 second drift and should do proper processing
+	 */
+	st->ts_algo.resume_flag  = true;
+	mutex_unlock(&st->lock);
+	wake_up_interruptible(&st->wait_queue);
+}
+EXPORT_SYMBOL_GPL(inv_mpu_complete);
+#endif
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_dts.c b/drivers/iio/imu/inv_mpu/inv_mpu_dts.c
new file mode 100644
index 000000000000..86d5b4583e46
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_dts.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2012-2017 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/export.h>
+
+#include <linux/iio/imu/mpu.h>
+#include "inv_mpu_dts.h"
+#include "inv_mpu_iio.h"
+
+#ifdef CONFIG_OF
+
+static int inv_mpu_power_on(struct mpu_platform_data *pdata)
+{
+	int err;
+
+	if (!IS_ERR(pdata->vdd_ana)) {
+		err = regulator_enable(pdata->vdd_ana);
+		if (err)
+			return err;
+	}
+	if (!IS_ERR(pdata->vdd_i2c)) {
+		err = regulator_enable(pdata->vdd_i2c);
+		if (err)
+			goto error_disable_vdd_ana;
+	}
+
+	return 0;
+
+error_disable_vdd_ana:
+	regulator_disable(pdata->vdd_ana);
+	return err;
+}
+
+static int inv_mpu_power_off(struct mpu_platform_data *pdata)
+{
+	if (!IS_ERR(pdata->vdd_ana))
+		regulator_disable(pdata->vdd_ana);
+	if (!IS_ERR(pdata->vdd_i2c))
+		regulator_disable(pdata->vdd_i2c);
+
+	return 0;
+}
+
+static int inv_parse_orientation_matrix(struct device *dev, s8 *orient)
+{
+	int rc, i;
+	struct device_node *np = dev->of_node;
+	u32 temp_val, temp_val2;
+
+	for (i = 0; i < 9; i++)
+		orient[i] = 0;
+
+	/* parsing axis x orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_x", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_x\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_x", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_x\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[temp_val] = -1;
+	else
+		orient[temp_val] = 1;
+
+	/* parsing axis y orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_y", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_y\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_y", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_y\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[3 + temp_val] = -1;
+	else
+		orient[3 + temp_val] = 1;
+
+	/* parsing axis z orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_z", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_z\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_z", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_z\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[6 + temp_val] = -1;
+	else
+		orient[6 + temp_val] = 1;
+
+	return 0;
+}
+
+static int inv_parse_secondary_orientation_matrix(struct device *dev,
+						  s8 *orient)
+{
+	int rc, i;
+	struct device_node *np = dev->of_node;
+	u32 temp_val, temp_val2;
+
+	for (i = 0; i < 9; i++)
+		orient[i] = 0;
+
+	/* parsing axis x orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_x", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_x\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_x", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_x\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[temp_val] = -1;
+	else
+		orient[temp_val] = 1;
+
+	/* parsing axis y orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_y", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_y\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_y", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_y\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[3 + temp_val] = -1;
+	else
+		orient[3 + temp_val] = 1;
+
+	/* parsing axis z orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_z", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_z\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_z", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_z\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[6 + temp_val] = -1;
+	else
+		orient[6 + temp_val] = 1;
+
+	return 0;
+}
+
+static int inv_parse_secondary(struct device *dev,
+			       struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,secondary_type", &name)) {
+		dev_err(dev, "Missing secondary type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "compass")) {
+		pdata->sec_slave_type = SECONDARY_SLAVE_TYPE_COMPASS;
+	} else if (!strcmp(name, "none")) {
+		pdata->sec_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,secondary_name", &name)) {
+		dev_err(dev, "Missing secondary name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "ak8963"))
+		pdata->sec_slave_id = COMPASS_ID_AK8963;
+	else if (!strcmp(name, "ak8975"))
+		pdata->sec_slave_id = COMPASS_ID_AK8975;
+	else if (!strcmp(name, "ak8972"))
+		pdata->sec_slave_id = COMPASS_ID_AK8972;
+	else if (!strcmp(name, "ak09911"))
+		pdata->sec_slave_id = COMPASS_ID_AK09911;
+	else if (!strcmp(name, "ak09912"))
+		pdata->sec_slave_id = COMPASS_ID_AK09912;
+	else if (!strcmp(name, "ak09915"))
+		pdata->sec_slave_id = COMPASS_ID_AK09915;
+	else if (!strcmp(name, "ak09916"))
+		pdata->sec_slave_id = COMPASS_ID_AK09916;
+	else
+		return -EINVAL;
+	rc = of_property_read_u32(np, "inven,secondary_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary register\n");
+		return rc;
+	}
+	pdata->secondary_i2c_addr = temp_val;
+	rc = inv_parse_secondary_orientation_matrix(dev,
+						    pdata->
+						    secondary_orientation);
+
+	return rc;
+}
+
+static int inv_parse_aux(struct device *dev, struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,aux_type", &name)) {
+		dev_err(dev, "Missing aux type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "pressure")) {
+		pdata->aux_slave_type = SECONDARY_SLAVE_TYPE_PRESSURE;
+	} else if (!strcmp(name, "none")) {
+		pdata->aux_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,aux_name", &name)) {
+		dev_err(dev, "Missing aux name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "bmp280"))
+		pdata->aux_slave_id = PRESSURE_ID_BMP280;
+	else
+		return -EINVAL;
+
+	rc = of_property_read_u32(np, "inven,aux_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read aux register\n");
+		return rc;
+	}
+	pdata->aux_i2c_addr = temp_val;
+
+	return 0;
+}
+
+static int inv_parse_readonly_secondary(struct device *dev,
+				 	struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,read_only_slave_type", &name)) {
+		dev_err(dev, "Missing read only slave type type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "als")) {
+		pdata->read_only_slave_type = SECONDARY_SLAVE_TYPE_ALS;
+	} else if (!strcmp(name, "none")) {
+		pdata->read_only_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,read_only_slave_name", &name)) {
+		dev_err(dev, "Missing read only slave type name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "apds9930"))
+		pdata->read_only_slave_id = ALS_ID_APDS_9930;
+	else
+		return -EINVAL;
+
+	rc = of_property_read_u32(np, "inven,read_only_slave_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read read only slave reg register\n");
+		return rc;
+	}
+	pdata->read_only_i2c_addr = temp_val;
+
+	return 0;
+}
+
+int invensense_mpu_parse_dt(struct device *dev, struct mpu_platform_data *pdata)
+{
+	int rc;
+
+	rc = inv_parse_orientation_matrix(dev, pdata->orientation);
+	if (rc)
+		return rc;
+	rc = inv_parse_secondary(dev, pdata);
+	if (rc)
+		return rc;
+	inv_parse_aux(dev, pdata);
+
+	inv_parse_readonly_secondary(dev, pdata);
+
+	pdata->vdd_ana = regulator_get(dev, "inven,vdd_ana");
+	if (IS_ERR(pdata->vdd_ana))
+		return PTR_ERR(pdata->vdd_ana);
+
+	pdata->vdd_i2c = regulator_get(dev, "inven,vcc_i2c");
+	if (IS_ERR(pdata->vdd_i2c)) {
+		regulator_put(pdata->vdd_ana);
+		return PTR_ERR(pdata->vdd_i2c);
+	}
+
+	pdata->power_on = inv_mpu_power_on;
+	pdata->power_off = inv_mpu_power_off;
+	dev_dbg(dev, "parse dt complete\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(invensense_mpu_parse_dt);
+
+#endif /* CONFIG_OF */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_dts.h b/drivers/iio/imu/inv_mpu/inv_mpu_dts.h
new file mode 100644
index 000000000000..90966febb930
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_dts.h
@@ -0,0 +1,25 @@
+/*
+* Copyright (C) 2012-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef _INV_MPU_DTS_H_
+#define _INV_MPU_DTS_H_
+
+#include <linux/kernel.h>
+#include <linux/iio/imu/mpu.h>
+
+#ifdef CONFIG_OF
+int invensense_mpu_parse_dt(struct device *dev,
+			    struct mpu_platform_data *pdata);
+#endif
+
+#endif /* #ifndef _INV_MPU_DTS_H_ */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c
new file mode 100644
index 000000000000..49d90e66398e
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c
@@ -0,0 +1,561 @@
+/*
+* Copyright (C) 2012-2020 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+#include <linux/errno.h>
+#include <linux/version.h>
+
+#include "inv_mpu_iio.h"
+#include "inv_mpu_dts.h"
+
+#define CONFIG_DYNAMIC_DEBUG_I2C 0
+
+/**
+ *  inv_i2c_read_base() - Read one or more bytes from the device registers.
+ *  @st:	Device driver instance.
+ *  @i2c_addr:  i2c address of device.
+ *  @reg:	First device register to be read from.
+ *  @length:	Number of bytes to read.
+ *  @data:	Data read from device.
+ *  NOTE:This is not re-implementation of i2c_smbus_read because i2c
+ *       address could be specified in this case. We could have two different
+ *       i2c address due to secondary i2c interface.
+ */
+int inv_i2c_read_base(struct inv_mpu_state *st, u16 i2c_addr,
+						u8 reg, u16 length, u8 *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (!data)
+		return -EINVAL;
+
+	msgs[0].addr = i2c_addr;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = &reg;
+	msgs[0].len = 1;
+
+	msgs[1].addr = i2c_addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].buf = data;
+	msgs[1].len = length;
+
+	res = i2c_transfer(st->sl_handle, msgs, 2);
+
+	if (res < 2) {
+		if (res >= 0)
+			res = -EIO;
+	} else
+		res = 0;
+
+	return res;
+}
+
+/**
+ *  inv_i2c_single_write_base() - Write a byte to a device register.
+ *  @st:	Device driver instance.
+ *  @i2c_addr:  I2C address of the device.
+ *  @reg:	Device register to be written to.
+ *  @data:	Byte to write to device.
+ *  NOTE:This is not re-implementation of i2c_smbus_write because i2c
+ *       address could be specified in this case. We could have two different
+ *       i2c address due to secondary i2c interface.
+ */
+int inv_i2c_single_write_base(struct inv_mpu_state *st,
+						u16 i2c_addr, u8 reg, u8 data)
+{
+	u8 tmp[2];
+	struct i2c_msg msg;
+	int res;
+
+	tmp[0] = reg;
+	tmp[1] = data;
+
+	msg.addr = i2c_addr;
+	msg.flags = 0;		/* write */
+	msg.buf = tmp;
+	msg.len = 2;
+
+	res = i2c_transfer(st->sl_handle, &msg, 1);
+	if (res < 1) {
+		if (res == 0)
+			res = -EIO;
+		return res;
+	} else
+		return 0;
+}
+
+static int inv_i2c_single_write(struct inv_mpu_state *st, u8 reg, u8 data)
+{
+	return inv_i2c_single_write_base(st, st->i2c_addr, reg, data);
+}
+
+static int inv_i2c_read(struct inv_mpu_state *st, u8 reg, int len, u8 *data)
+{
+	return inv_i2c_read_base(st, st->i2c_addr, reg, len, data);
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+static int _memory_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 const *data)
+{
+	u8 bank[2];
+	u8 addr[2];
+	u8 buf[513];
+
+	struct i2c_msg msgs[3];
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len >= (sizeof(buf) - 1))
+		return -ENOMEM;
+
+	bank[0] = REG_MEM_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = REG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf[0] = REG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = (u8 *) buf;
+	msgs[2].len = len + 1;
+
+#if CONFIG_DYNAMIC_DEBUG_I2C
+	{
+		char *write = 0;
+		pr_debug("%s WM%02X%02X%02X%s%s - %d\n", st->hw->name,
+			mpu_addr, bank[1], addr[1],
+			wr_pr_debug_begin(data, len, write),
+			wr_pr_debug_end(write), len);
+	}
+#endif
+
+	res = i2c_transfer(st->sl_handle, msgs, 3);
+	if (res != 3) {
+		if (res >= 0)
+			res = -EIO;
+		return res;
+	} else {
+		return 0;
+	}
+}
+
+static int inv_i2c_mem_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 const *data)
+{
+	int r, i, j;
+#define DMP_MEM_CMP_SIZE 16
+	u8 w[DMP_MEM_CMP_SIZE];
+	bool retry;
+
+	j = 0;
+	retry = true;
+	while ((j < 3) && retry) {
+		retry = false;
+		r = _memory_write(st, mpu_addr, mem_addr, len, data);
+		if (len < DMP_MEM_CMP_SIZE) {
+			r = mem_r(mem_addr, len, w);
+			for (i = 0; i < len; i++) {
+				if (data[i] != w[i]) {
+					pr_debug
+				("error write=%x, len=%d,data=%x, w=%x, i=%d\n",
+					mem_addr, len, data[i], w[i], i);
+					retry = true;
+				}
+			}
+		}
+		j++;
+	}
+
+	return r;
+}
+
+static int inv_i2c_mem_read(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 *data)
+{
+	u8 bank[2];
+	u8 addr[2];
+	u8 buf;
+
+	struct i2c_msg msgs[4];
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	bank[0] = REG_MEM_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = REG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf = REG_MEM_R_W;
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = &buf;
+	msgs[2].len = 1;
+
+	msgs[3].addr = mpu_addr;
+	msgs[3].flags = I2C_M_RD;
+	msgs[3].buf = data;
+	msgs[3].len = len;
+
+	res = i2c_transfer(st->sl_handle, msgs, 4);
+	if (res != 4) {
+		if (res >= 0)
+			res = -EIO;
+	} else
+		res = 0;
+
+#if CONFIG_DYNAMIC_DEBUG_I2C
+	{
+		char *read = 0;
+		pr_debug("%s RM%02X%02X%02X%02X - %s%s\n", st->hw->name,
+			mpu_addr, bank[1], addr[1], len,
+			wr_pr_debug_begin(data, len, read),
+			wr_pr_debug_end(read));
+	}
+#endif
+
+	return res;
+}
+#endif
+
+/*
+ *  inv_mpu_probe() - probe function.
+ */
+static int inv_mpu_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct inv_mpu_state *st;
+	struct iio_dev *indio_dev;
+	int result;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENOSYS;
+		pr_err("I2c function error\n");
+		goto out_no_free;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+	indio_dev = iio_device_alloc(sizeof(*st));
+#else
+	indio_dev = iio_device_alloc(&client->dev, sizeof(*st));
+#endif
+	if (indio_dev == NULL) {
+		pr_err("memory allocation failed\n");
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	st = iio_priv(indio_dev);
+	mutex_init(&st->lock);
+	st->client = client;
+	st->sl_handle = client->adapter;
+	st->i2c_addr = client->addr;
+	st->write = inv_i2c_single_write;
+	st->read = inv_i2c_read;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	st->mem_write = inv_i2c_mem_write;
+	st->mem_read = inv_i2c_mem_read;
+#endif
+	st->dev = &client->dev;
+	st->irq = client->irq;
+#if defined(CONFIG_INV_MPU_IIO_ICM43600)
+	st->i2c_dis = BIT_SIFS_CFG_I2C_ONLY;
+#endif
+	st->bus_type = BUS_I2C;
+	i2c_set_clientdata(client, indio_dev);
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = id->name;
+
+#ifdef CONFIG_OF
+	result = invensense_mpu_parse_dt(st->dev, &st->plat_data);
+	if (result)
+		goto out_free;
+#else
+	if (dev_get_platdata(st->dev) == NULL) {
+		result = -ENODEV;
+		goto out_free;
+	}
+	st->plat_data = *(struct mpu_platform_data *)dev_get_platdata(st->dev);
+#endif
+	/* Power on device */
+	if (st->plat_data.power_on) {
+		result = st->plat_data.power_on(&st->plat_data);
+		if (result < 0) {
+			dev_err(st->dev, "power_on failed: %d\n", result);
+			goto out_free;
+		}
+		pr_info("%s: power on here.\n", __func__);
+	}
+	pr_info("%s: power on.\n", __func__);
+
+	msleep(100);
+
+	/* power is turned on inside check chip type */
+	result = inv_check_chip_type(indio_dev, id->name);
+	if (result)
+		goto out_free;
+
+	result = inv_mpu_configure_ring(indio_dev);
+	if (result) {
+		pr_err("configure ring buffer fail\n");
+		goto out_free;
+	}
+
+	result = iio_device_register(indio_dev);
+	if (result) {
+		pr_err("IIO device register fail\n");
+		goto out_unreg_ring;
+	}
+
+	result = inv_create_dmp_sysfs(indio_dev);
+	if (result) {
+		pr_err("create dmp sysfs failed\n");
+		goto out_unreg_iio;
+	}
+	init_waitqueue_head(&st->wait_queue);
+	st->resume_state = true;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&st->wake_lock, WAKE_LOCK_SUSPEND, "inv_mpu");
+#else
+	st->wake_lock = wakeup_source_create("inv_mpu");
+	wakeup_source_add(st->wake_lock);
+	if (st->wake_lock)
+		pr_info("wakeup_source is created successfully\n");
+	else
+		pr_info("failed to create wakeup_source\n");
+#endif
+	dev_info(st->dev, "%s ma-kernel-%s is ready to go!\n",
+				indio_dev->name, INVENSENSE_DRIVER_VERSION);
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	pr_info("Data read from registers\n");
+#else
+	pr_info("Data read from FIFO\n");
+#endif
+#ifdef TIMER_BASED_BATCHING
+	pr_info("Timer based batching\n");
+#endif
+
+	return 0;
+
+out_unreg_iio:
+	iio_device_unregister(indio_dev);
+out_unreg_ring:
+	inv_mpu_unconfigure_ring(indio_dev);
+out_free:
+	iio_device_free(indio_dev);
+out_no_free:
+	if (result != -EPROBE_DEFER)
+		dev_err(&client->dev, "%s failed %d\n", __func__, result);
+	return result;
+}
+
+static void inv_mpu_shutdown(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	inv_switch_power_in_lp(st, true);
+	dev_dbg(st->dev, "Shutting down %s...\n", st->hw->name);
+
+	/* turn off power to ensure gyro engine is off */
+	result = inv_set_power(st, false);
+	if (result)
+		dev_err(st->dev, "Failed to turn off %s\n",
+			st->hw->name);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+}
+
+/*
+ *  inv_mpu_remove() - remove function.
+ */
+static int inv_mpu_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef CONFIG_HAS_WAKELOCK
+	if (st->wake_lock)
+		wakeup_source_destroy(st->wake_lock);
+#endif
+	if (st->aux_dev)
+		i2c_unregister_device(st->aux_dev);
+	iio_device_unregister(indio_dev);
+	inv_mpu_unconfigure_ring(indio_dev);
+	iio_device_free(indio_dev);
+	dev_info(st->dev, "inv-mpu-iio module removed.\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int inv_mpu_i2c_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+
+	return inv_mpu_suspend(indio_dev);
+}
+
+static void inv_mpu_i2c_complete(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+
+	inv_mpu_complete(indio_dev);
+}
+#endif
+
+static const struct dev_pm_ops inv_mpu_i2c_pmops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = inv_mpu_i2c_suspend,
+	.complete = inv_mpu_i2c_complete,
+#endif
+};
+
+/* device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct i2c_device_id inv_mpu_id[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{"icm20648", ICM20648},
+#else
+	{"icm20608d", ICM20608D},
+	{"icm20789", ICM20789},
+	{"icm20690", ICM20690},
+	{"icm20602", ICM20602},
+	{"iam20680", IAM20680},
+	{"icm42600", ICM42600},
+	{"icm42686", ICM42686},
+	{"icm42688", ICM42688},
+	{"icm40609d", ICM40609D},
+	{"icm43600", ICM43600},
+	{"iim42600", ICM42600},
+#endif
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
+
+static const struct of_device_id inv_mpu_of_match[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{
+		.compatible = "invensense,icm20648",
+		.data = (void *)ICM20648,
+	},
+#else
+	{
+		.compatible = "invensense,icm20608d",
+		.data = (void *)ICM20608D,
+	}, {
+		.compatible = "invensense,icm20789",
+		.data = (void *)ICM20789,
+	}, {
+		.compatible = "invensense,icm20690",
+		.data = (void *)ICM20690,
+	}, {
+		.compatible = "invensense,icm20602",
+		.data = (void *)ICM20602,
+	}, {
+		.compatible = "invensense,iam20680",
+		.data = (void *)IAM20680,
+	}, {
+		.compatible = "invensense,icm42600",
+		.data = (void *)ICM42600,
+	}, {
+		.compatible = "invensense,icm42686",
+		.data = (void *)ICM42686,
+	}, {
+		.compatible = "invensense,icm42688",
+		.data = (void *)ICM42688,
+	}, {
+		.compatible = "invensense,icm40609d",
+		.data = (void *)ICM40609D,
+	}, {
+		.compatible = "invensense,icm43600",
+		.data = (void *)ICM43600,
+	}, {
+		.compatible = "invensense,iim42600",
+		.data = (void *)ICM42600,
+        },
+#endif
+	{ }
+};
+MODULE_DEVICE_TABLE(of, inv_mpu_of_match);
+
+static struct i2c_driver inv_mpu_driver = {
+	.probe = inv_mpu_probe,
+	.remove = inv_mpu_remove,
+	.shutdown = inv_mpu_shutdown,
+	.id_table = inv_mpu_id,
+	.driver = {
+		.owner = THIS_MODULE,
+		.of_match_table = inv_mpu_of_match,
+		.name = "inv-mpu-iio-i2c",
+		.pm = &inv_mpu_i2c_pmops,
+	},
+};
+module_i2c_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense I2C device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_iio.h b/drivers/iio/imu/inv_mpu/inv_mpu_iio.h
new file mode 100644
index 000000000000..3683953bd1d6
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_iio.h
@@ -0,0 +1,1216 @@
+/*
+ * Copyright (C) 2012-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_H_
+#define _INV_MPU_IIO_H_
+
+#include <linux/i2c.h>
+#include <linux/kfifo.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/iio/imu/mpu.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include <linux/wait.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+#include "icm20648/dmp3Default.h"
+#endif
+#ifdef CONFIG_INV_MPU_IIO_ICM20608D
+#include "icm20608d/dmp3Default_20608D.h"
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648)
+#include "icm20648/inv_mpu_iio_reg_20648.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20602)
+#include "icm20602/inv_mpu_iio_reg_20602.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20608D)
+#include "icm20608d/inv_mpu_iio_reg_20608.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20690)
+#include "icm20690/inv_mpu_iio_reg_20690.h"
+#elif defined(CONFIG_INV_MPU_IIO_IAM20680)
+#include "iam20680/inv_mpu_iio_reg_20680.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM42600)
+#include "icm42600/inv_mpu_iio_reg_42600.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM43600)
+#include "icm43600/inv_mpu_iio_reg_43600.h"
+#endif
+
+#define INVENSENSE_DRIVER_VERSION		"9.6.0-test1"
+
+/* #define DEBUG */
+
+/* #define ACCEL_BIAS_TEST */
+
+/* #define BIAS_CONFIDENCE_HIGH 1 */
+
+#define MAX_FIFO_READ_SIZE       128
+#define MAX_DMP_READ_SIZE        16
+
+/* data header defines */
+#define WAKE_HDR                 0x8000
+
+#define ACCEL_HDR                1
+#define GYRO_HDR                 2
+#define COMPASS_HDR              3
+#define ALS_HDR                  4
+#define SIXQUAT_HDR              5
+#define NINEQUAT_HDR             6
+#define PEDQUAT_HDR              7
+#define GEOMAG_HDR               8
+#define PRESSURE_HDR             9
+#define GYRO_CALIB_HDR           10
+#define COMPASS_CALIB_HDR        11
+#define STEP_COUNTER_HDR         12
+#define STEP_DETECTOR_HDR        13
+#define STEP_COUNT_HDR           14
+#define ACTIVITY_HDR             15
+#define PICK_UP_HDR              16
+#define EMPTY_MARKER             17
+#define END_MARKER               18
+#define COMPASS_ACCURACY_HDR     19
+#define ACCEL_ACCURACY_HDR       20
+#define GYRO_ACCURACY_HDR        21
+#define EIS_GYRO_HDR             36
+#define EIS_CALIB_HDR            37
+#define LPQ_HDR                  38
+#define TAP_HDR                  40
+
+#define ACCEL_WAKE_HDR           (ACCEL_HDR | WAKE_HDR)
+#define GYRO_WAKE_HDR            (GYRO_HDR | WAKE_HDR)
+#define COMPASS_WAKE_HDR         (COMPASS_HDR | WAKE_HDR)
+#define ALS_WAKE_HDR             (ALS_HDR | WAKE_HDR)
+#define SIXQUAT_WAKE_HDR         (SIXQUAT_HDR | WAKE_HDR)
+#define NINEQUAT_WAKE_HDR        (NINEQUAT_HDR | WAKE_HDR)
+#define PEDQUAT_WAKE_HDR         (PEDQUAT_HDR | WAKE_HDR)
+#define GEOMAG_WAKE_HDR          (GEOMAG_HDR | WAKE_HDR)
+#define PRESSURE_WAKE_HDR        (PRESSURE_HDR | WAKE_HDR)
+#define GYRO_CALIB_WAKE_HDR      (GYRO_CALIB_HDR | WAKE_HDR)
+#define COMPASS_CALIB_WAKE_HDR   (COMPASS_CALIB_HDR | WAKE_HDR)
+#define STEP_COUNTER_WAKE_HDR    (STEP_COUNTER_HDR | WAKE_HDR)
+#define STEP_DETECTOR_WAKE_HDR   (STEP_DETECTOR_HDR | WAKE_HDR)
+#define TAP_WAKE_HDR             (TAP_HDR | WAKE_HDR)
+
+/* init parameters */
+#define MPU_INIT_SMD_THLD        1500
+/* default FSR for gyro
+ * note: 4000dps is supported only by icm42686.
+ * 0:250dps, 1:500dps, 2:1000dps, 3:2000dps, 4:4000dps
+ */
+#define MPU_INIT_GYRO_SCALE      3
+/* default FSR for accel
+ * note: 32g is supported by only by icm42686. 2g is not supported by icm42686.
+ * 0:2g, 1:4g, 2:8g, 3:16g, 4:32g
+ */
+#define MPU_INIT_ACCEL_SCALE     1
+#define MPU_INIT_PED_INT_THRESH  2
+#define MPU_INIT_PED_STEP_THRESH 6
+#define MPU_4X_TS_GYRO_SHIFT      (3160000 / 2)
+#define DMP_START_ADDR_20648     0x1000
+#define DMP_START_ADDR_20608D    0x4B0
+#define MAX_WR_SZ                PAGE_SIZE
+#define WOM_DELAY_THRESHOLD      200
+#define STATIONARY_DELAY_THRESHOLD 12000 /* 60s */
+#define INV_ODR_BUFFER_MULTI     20
+
+#define COVARIANCE_SIZE          14
+#define ACCEL_COVARIANCE_SIZE  (COVARIANCE_SIZE * sizeof(int))
+
+enum inv_bus_type {
+	BUS_I2C = 0,
+	BUS_SPI,
+};
+
+struct inv_mpu_state;
+
+enum INV_ENGINE {
+	ENGINE_GYRO = 0,
+	ENGINE_ACCEL,
+	ENGINE_PRESSURE,
+	ENGINE_I2C,
+	ENGINE_NUM_MAX,
+};
+
+/**
+ *  struct inv_hw_s - Other important hardware information.
+ *  @num_reg:	Number of registers on device.
+ *  @name:      name of the chip
+ */
+struct inv_hw_s {
+	u8 num_reg;
+	u8 *name;
+};
+
+/**
+ *  struct inv_sensor - information for each sensor.
+ *  @ts: this sensors timestamp.
+ *  @ts_adj: sensor timestamp adjustment.
+ *  @previous_ts: previous timestamp for this sensor.
+ *  @dur: duration between samples in ns.
+ *  @rate:  sensor data rate.
+ *  @sample_size: number of bytes for the sensor.
+ *  @odr_addr: output data rate address in DMP.
+ *  @counter_addr: output counter address in DMP.
+ *  @output: output on/off control word.
+ *  @time_calib: calibrate timestamp.
+ *  @sample_calib: calibrate bytes accumulated.
+ *  @div:         divider in DMP mode.
+ *  @calib_flag:  calibrate flag used to improve the accuracy of estimation.
+ *  @on:    sensor on/off.
+ *  @a_en:  accel engine requirement.
+ *  @g_en:  gyro engine requirement.
+ *  @c_en:  compass_engine requirement.
+ *  @p_en:  pressure engine requirement.
+ *  @engine_base: engine base for this sensor.
+ *  @count: number of samples in one session.
+ *  @send: decide whether to send this sample or not.
+ */
+struct inv_sensor {
+	u64 ts;
+	s64 ts_adj;
+	u64 previous_ts;
+	int dur;
+	int rate;
+	u8 sample_size;
+	int odr_addr;
+	int counter_addr;
+	u16 output;
+	u64 time_calib;
+	u32 sample_calib;
+	int div;
+	bool calib_flag;
+	bool on;
+	bool a_en;
+	bool g_en;
+	bool c_en;
+	bool p_en;
+	enum INV_ENGINE engine_base;
+	int count;
+	bool send;
+};
+
+/**
+ *  struct inv_sensor - information for each sensor.
+ *  @sample_size: number of bytes for the sensor.
+ *  @output: output on/off control word.
+ *  @on:    sensor on/off.
+ *  @header: accuracy header for communicate with HAL
+ *dd  @count: number of samples in one session.
+ */
+struct inv_sensor_accuracy {
+	u16 output;
+	u8 sample_size;
+	bool on;
+	u16 header;
+};
+
+enum SENSOR_ACCURACY {
+	SENSOR_ACCEL_ACCURACY = 0,
+	SENSOR_GYRO_ACCURACY,
+	SENSOR_COMPASS_ACCURACY,
+	SENSOR_ACCURACY_NUM_MAX,
+};
+
+enum SENSOR_L {
+	SENSOR_L_ACCEL = 0,
+	SENSOR_L_GYRO,
+	SENSOR_L_MAG,
+	SENSOR_L_ALS,
+	SENSOR_L_SIXQ,
+	SENSOR_L_THREEQ,
+	SENSOR_L_NINEQ,
+	SENSOR_L_PEDQ,
+	SENSOR_L_GEOMAG,
+	SENSOR_L_PRESSURE,
+	SENSOR_L_GYRO_CAL,
+	SENSOR_L_MAG_CAL,
+	SENSOR_L_EIS_GYRO,
+	/*wake sensors */
+	SENSOR_L_ACCEL_WAKE = 13,
+	SENSOR_L_GYRO_WAKE,
+	SENSOR_L_MAG_WAKE,
+	SENSOR_L_ALS_WAKE,
+	SENSOR_L_SIXQ_WAKE,
+	SENSOR_L_NINEQ_WAKE,
+	SENSOR_L_PEDQ_WAKE,
+	SENSOR_L_GEOMAG_WAKE,
+	SENSOR_L_PRESSURE_WAKE,
+	SENSOR_L_GYRO_CAL_WAKE,
+	SENSOR_L_MAG_CAL_WAKE,
+	SENSOR_L_GESTURE_ACCEL,
+	SENSOR_L_NUM_MAX,
+};
+
+/**
+ *  struct android_l_sensor - information for each android sensor.
+ *  @ts: this sensors timestamp.
+ *  @base: android sensor based on invensense sensor.
+ *  @rate: output rate.
+ *  @on:  sensor on/off.
+ *  @wake_on: wake on sensor is on/off.
+ *  @div: divider for the output.
+ *  @counter: counter works with the divider.
+ *  @header: header for the output.
+ */
+struct android_l_sensor {
+	u64 ts;
+	enum INV_SENSORS base;
+	int rate;
+	bool on;
+	bool wake_on;
+	int div;
+	int counter;
+	u16 header;
+};
+
+/**
+ *  struct inv_batch - information for batchmode.
+ *  @on: normal batch mode on.
+ *  @default_on: default batch on. This is optimization option.
+ *  @overflow_on: overflow mode for batchmode.
+ *  @wake_fifo_on: overflow for suspend mode.
+ *  @step_only: mean only step detector data is batched.
+ *  @post_isr_run: mean post isr has runned once.
+ *  @counter: counter for batch mode.
+ *  @timeout: nominal timeout value for batchmode in milliseconds.
+ *  @max_rate: max rate for all batched sensors.
+ *  @pk_size: packet size;
+ *  @engine_base: engine base batch mode should stick to.
+ */
+struct inv_batch {
+	bool on;
+	bool default_on;
+	bool overflow_on;
+	bool wake_fifo_on;
+	bool step_only;
+	bool post_isr_run;
+	u32 counter;
+	u32 timeout;
+	u32 max_rate;
+	u32 pk_size;
+	u32 fifo_wm_th;
+	enum INV_ENGINE engine_base;
+};
+
+/**
+ *  struct inv_chip_config_s - Cached chip configuration data.
+ *  @fsr:		Full scale range.
+ *  @lpf:		Digital low pass filter frequency.
+ *  @accel_fs:		accel full scale range.
+ *  @accel_enable:	enable accel functionality
+ *  @gyro_enable:	enable gyro functionality
+ *  @compass_enable:    enable compass functinality.
+ *  @geomag_enable:     enable geomag sensor functions.
+ *  @als_enable:        enable ALS functionality.
+ *  @pressure_enable:   eanble pressure functionality.
+ *  @secondary_enable:  secondary I2C bus enabled or not.
+ *  @has_gyro:	has gyro or not.
+ *  @has_compass:	has secondary I2C compass or not.
+ *  @has_pressure:      has secondary I2C pressure or not.
+ *  @has_als:           has secondary I2C als or not.
+ *  @slave_enable:      secondary I2C interface enabled or not.
+ *  @normal_compass_measure: discard first compass data after reset.
+ *  @is_asleep:		1 if chip is powered down.
+ *  @lp_en_set:         1 if LP_EN bit is set;
+ *  @lp_en_mode_off:    debug mode that turns off LP_EN mode off.
+ *  @clk_sel:           debug_mode that turns on/off clock selection.
+ *  @dmp_on:		dmp is on/off.
+ *  @dmp_event_int_on:  dmp event interrupt on/off.
+ *  @wom_on:        WOM interrupt on. This is an internal variable.
+ *  @step_indicator_on: step indicate bit added to the sensor or not.
+ *  @tilt_enable: tilt enable.
+ *  @pick_up_enable: pick up gesture enable.
+ *  @tap_enable: tap gesture enable.
+ *  @stationary_detect_enable: stationary detect enable.
+ *  @motion_detect_enable: motion detect enable.
+ *  @step_detector_on:  step detector on or not.
+ *  @activity_on: turn on/off activity.
+ *  @activity_eng_on: activity engine on/off.
+ *  @firmware_loaded:	flag indicate firmware loaded or not.
+ *  @low_power_gyro_on: flag indicating low power gyro on/off.
+ *  @wake_on: any wake on sensor is on/off.
+ *  @compass_rate:    compass engine rate. Determined by underlying data.
+ *  @high_res_mode: high resolution mode on/off.
+ */
+struct inv_chip_config_s {
+	u32 fsr:3;
+	u32 lpf:3;
+	u32 accel_fs:3;
+	u32 accel_enable:1;
+	u32 gyro_enable:1;
+	u32 compass_enable:1;
+	u32 geomag_enable:1;
+	u32 als_enable:1;
+	u32 prox_enable:1;
+	u32 pressure_enable:1;
+	u32 has_gyro:1;
+	u32 has_compass:1;
+	u32 has_pressure:1;
+	u32 has_als:1;
+	u32 slave_enable:1;
+	u32 normal_compass_measure:1;
+	u32 is_asleep:1;
+	u32 lp_en_set:1;
+	u32 lp_en_mode_off:1;
+	u32 clk_sel:1;
+	u32 dmp_on:1;
+	u32 dmp_event_int_on:1;
+	u32 wom_on:1;
+	u32 step_indicator_on:1;
+	u32 tilt_enable:1;
+	u32 pick_up_enable:1;
+	u32 tap_enable:1;
+	u32 stationary_detect_enable:1;
+	u32 motion_detect_enable:1;
+	u32 eis_enable:1;
+	u32 step_detector_on:1;
+	u32 activity_on:1;
+	u32 activity_eng_on:1;
+	u32 firmware_loaded:1;
+	u32 low_power_gyro_on:1;
+	u32 wake_on:1;
+	int compass_rate;
+	u32 high_res_mode:1;
+};
+
+/**
+ *  struct inv_temp_comp - temperature compensation structure.
+ *  @t_lo:    raw temperature in low temperature.
+ *  @t_hi:    raw temperature in high temperature.
+ *  @b_lo:    gyro bias in low temperature.
+ *  @b_hi:    gyro bias in high temperature.
+ *  @has_low:    flag indicate low temperature parameters is updated.
+ *  @has_high:   flag indicates high temperature parameters is updated.
+ *  @slope:      slope for temperature compensation.
+ */
+struct inv_temp_comp {
+	int t_lo;
+	int t_hi;
+	int b_lo[3];
+	int b_hi[3];
+	bool has_low;
+	bool has_high;
+	int slope[3];
+};
+
+/**
+ *  struct inv_chip_info_s - Chip related information.
+ *  @product_id:	Product id.
+ *  @product_revision:	Product revision.
+ *  @silicon_revision:	Silicon revision.
+ *  @software_revision:	software revision.
+ *  @compass_sens:	compass sensitivity.
+ *  @gyro_sens_trim:	Gyro sensitivity trim factor.
+ *  @accel_sens_trim:    accel sensitivity trim factor.
+ */
+struct inv_chip_info_s {
+	u8 product_id;
+	u8 product_revision;
+	u8 silicon_revision;
+	u8 software_revision;
+	u8 compass_sens[3];
+	u32 gyro_sens_trim;
+	u32 accel_sens_trim;
+};
+
+/**
+ * struct inv_smd significant motion detection structure.
+ * @threshold: accel threshold for motion detection.
+ * @delay: delay time to confirm 2nd motion.
+ * @delay2: delay window parameter.
+ * @on: smd on/off.
+ */
+struct inv_smd {
+	u32 threshold;
+	u32 delay;
+	u32 delay2;
+	bool on;
+};
+
+/**
+ * struct inv_ped pedometer related data structure.
+ * @step: steps taken.
+ * @time: time taken during the period.
+ * @last_step_time: last time the step is taken.
+ * @step_thresh: step threshold to show steps.
+ * @int_thresh: step threshold to generate interrupt.
+ * @int_on:   pedometer interrupt enable/disable.
+ * @int_mode: select the trigger to read step count from DMP, int or poll.
+ * @on:  pedometer on/off.
+ * @engine_on: pedometer engine on/off.
+ */
+struct inv_ped {
+	u64 step;
+	u64 time;
+	u64 last_step_time;
+	u16 step_thresh;
+	u16 int_thresh;
+	bool int_on;
+	bool int_mode;
+	bool on;
+	bool engine_on;
+};
+
+/**
+ * struct inv_eis EIS related data structure.
+ * @prev_gyro: latest gyro data just before FSYNC triggerd
+ * @prev_timestamp: latest gyro timestamp just before FSYNC triggered
+ * @current_gyro: gyro data just after FSYNC triggerd
+ * @current_timestamp: gyro timestamp just after FSYNC triggered
+ * @fsync_timestamp: timestamp of FSYNC event
+ * @fsync_delay: delay time of FSYNC and Gyro data. DMP data of FSYNC event
+ * @eis_triggered: check fsync event is triggered or not.
+ * @eis_frame: current frame is eis frame;
+ * @current_sync: current frame contains fsync counter.
+ * @frame_count: frame count for synchronization.
+ */
+struct inv_eis {
+	int prev_gyro[3];
+	u64 prev_timestamp;
+	int current_gyro[3];
+	u64 current_timestamp;
+	u32 frame_dur;
+	u64 slope[3];
+	u64 fsync_timestamp;
+	u64 last_fsync_timestamp;
+	u16 fsync_delay;
+	bool eis_triggered;
+	bool eis_frame;
+	bool current_sync;
+	bool prev_state;
+	u32 frame_count;
+	int gyro_counter;
+	int gyro_counter_s[3];
+	int fsync_delay_s[3];
+	int voting_count;
+	int voting_count_sub;
+	int voting_state;
+	int count_precision;
+};
+
+enum TRIGGER_STATE {
+	DATA_TRIGGER = 0,
+	RATE_TRIGGER,
+	EVENT_TRIGGER,
+	MISC_TRIGGER,
+	DEBUG_TRIGGER,
+};
+
+enum inv_fifo_count_mode {
+	BYTE_MODE,
+	RECORD_MODE
+};
+
+/**
+ *  struct inv_secondary_reg - secondary registers data structure.
+ *  @addr:       address of the slave.
+ *  @reg: register address of slave.
+ *  @ctrl: control register.
+ *  @d0: data out register.
+ */
+struct inv_secondary_reg {
+	u8 addr;
+	u8 reg;
+	u8 ctrl;
+	u8 d0;
+};
+
+struct inv_secondary_set {
+	u8 delay_enable;
+	u8 delay_time;
+	u8 odr_config;
+};
+/**
+ *  struct inv_engine_info - data structure for engines.
+ *  @base_time: base time for each engine.
+ *  @base_time_1k: base time when chip is running at 1K;
+ *  @base_time_vr: base time when chip is running in VR mode(500Hz);
+ *  @divider: divider used to downsample engine rate from original rate.
+ *  @running_rate: the actually running rate of engine.
+ *  @orig_rate: original rate for each engine before downsample.
+ *  @dur: duration for one tick.
+ *  @last_update_time: last update time.
+ */
+struct inv_engine_info {
+	u32 base_time;
+	u32 base_time_1k;
+	u32 base_time_vr;
+	u32 divider;
+	u32 running_rate;
+	u32 orig_rate;
+	u32 dur;
+	u64 last_update_time;
+};
+
+struct inv_ois {
+	int gyro_fs;
+	int accel_fs;
+	bool en;
+};
+
+/**
+ *  struct inv_timestamp_algo - timestamp algorithm .
+ *  @last_run_time: last time the post ISR runs.
+ *  @ts_for_calib: ts storage for calibration.
+ *  @reset_ts: reset time.
+ *  @dmp_ticks: dmp ticks storage for calibration.
+ *  @start_dmp_counter: dmp counter when start a new session.
+ *  @calib_counter: calibration counter for timestamp.
+ *  @resume_flag: flag to indicate this is the first time after resume. time
+ *				could have up to 1 seconds difference.
+ *  @clock_base: clock base to calculate the timestamp.
+ *  @gyro_ts_shift: 9 K counter for EIS.
+ *  @first_sample: first of 1K running should be dropped it affects timing
+ *  @first_drop_samples: the number of first samples to be dropped
+ */
+struct inv_timestamp_algo {
+	u64 last_run_time;
+	u64 ts_for_calib;
+	u64 reset_ts;
+	u32 dmp_ticks;
+	u32 start_dmp_counter;
+	int calib_counter;
+	bool resume_flag;
+	enum INV_ENGINE clock_base;
+	u32 gyro_ts_shift;
+	u32 first_sample;
+	u32 first_drop_samples[SENSOR_NUM_MAX];
+};
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || defined(CONFIG_INV_MPU_IIO_ICM43600)
+/**
+ *	struct inv_apex_data - apex gesture algo data .
+ *	@step_cnt_total: step count total.
+ *	@step_cnt_last_val: previous step count value from chip.
+ *	@step_reset_last_val: check if it is first time after step count reset.
+ */
+struct inv_apex_data {
+	uint32_t step_cnt_total;
+	uint32_t step_cnt_last_val;
+	bool step_reset_last_val;
+};
+#endif
+
+struct inv_mpu_slave;
+/**
+ *  struct inv_mpu_state - Driver state variables.
+ *  @dev:               device address of the current bus, i2c or spi.
+ *  @aux_dev:           device connected on auxiliary i2c bus with bypass mode.
+ *  @trig:		iio trigger device.
+ *  @chip_config:	Cached attribute information.
+ *  @chip_info:		Chip information from read-only registers.
+ *  @smd:               SMD data structure.
+ *  @ped:               pedometer data structure.
+ *  @batch:             batchmode data structure.
+ *  @temp_comp:         gyro temperature compensation structure.
+ *  @slave_compass:     slave compass.
+ *  @slave_pressure:    slave pressure.
+ *  @slave_als:         slave als.
+ *  @slv_reg: slave register data structure.
+ *  @ts_algo: timestamp algorithm data structure.
+ *  @apex_supported flag if apex feature is supported.
+ *  @smd_supported flag if smd is supported by hardware.
+ *  @apex_data data of apex data.
+ *  @sec_set: slave register odr config.
+ *  @eng_info: information for each engine.
+ *  @hw:		Other hardware-specific information.
+ *  @chip_type:		chip type.
+ *  @suspend_resume_sema: semaphore for suspend/resume.
+ *  @wake_lock: wake lock of the system.
+ *  @client:		i2c client handle.
+ *  @plat_data:		platform data.
+ *  @sl_handle:         Handle to I2C port.
+ *  @sensor{SENSOR_NUM_MAX]: sensor individual properties.
+ *  @sensor_l[SENSOR_L_NUM_MAX]: android L sensors properties.
+ *  @sensor_accuracy[SENSOR_ACCURACY_NUM_MAX]: sensor accuracy.
+ *  @sensor_acurracy_flag: flag indiciate whether to check output accuracy.
+ *  @irq:               irq number store.
+ *  @accel_bias:        accel bias store.
+ *  @gyro_bias:         gyro bias store.
+ *  @accel_st_bias:     accel bias store, result of self-test.
+ *  @gyro_st_bias:      gyro bias store, result of self-test.
+ *  @gyro_ois_st_bias:  gyro bias store from ois self test result.
+ *  @gyro_lp_mode:  gyro low power mode on/off.
+ *  @accel_lp_mode:  accel low power mode on/off.
+ *  @input_accel_dmp_bias[3]: accel bias for dmp.
+ *  @input_gyro_dmp_bias[3]: gyro bias for dmp.
+ *  @input_compass_dmp_bias[3]: compass bias for dmp.
+ *  @input_accel_bias[3]: accel bias for offset register.
+ *  @input_gyro_bias[3]: gyro bias for offset register.
+ *  @org_accel_offset_reg[3]: accel offset register original values.
+ *  @org_gyro_offset_reg[3]: gyro offset register original values.
+ *  @fifo_data[8]: fifo data storage.
+ *  @i2c_addr:          i2c address.
+ *  @header_count:      header count in current FIFO.
+ *  @step_det_count:    number of step detectors in one batch.
+ *  @gyro_sf: gyro scale factor.
+ *  @left_over[LEFT_OVER_BYTES]: left over bytes storage.
+ *  @left_over_size: left over size.
+ *  @fifo_count: current fifo_count;
+ *  @wake_sensor_received: wake up sensor received.
+ *  @accel_cal_enable:  accel calibration on/off
+ *  @gyro_cal_enable:   gyro calibration on/off
+ *  @calib_compass_on: calibrate compass on.
+ *  @debug_determine_engine_on: determine engine on/off.
+ *  @poke_mode_on: poke mode on/off.
+ *  @mode_1k_on: indicate 1K Hz mode is on.
+ *  @mode_vr_on: indicates VR mode (500 Hz) is on
+ *  @poke_ts: time stamp for poke feature.
+ *  @step_detector_base_ts: base time stamp for step detector calculation.
+ *  @last_temp_comp_time: last time temperature compensation is done.
+ *  @i2c_dis: disable I2C interface or not.
+ *  @name: name for the chip.
+ *  @gyro_st_data: gyro self test data.
+ *  @accel_st_data: accel self test data.
+ *  @secondary_name: name for the slave device in the secondary I2C.
+ *  @compass_var: compass variance from DMP.
+ *  @current_compass_matrix: matrix compass data multiplied to before soft iron.
+ *  @final_compass_matrix: matrix compass data multiplied to before soft iron.
+ *  @trigger_state: information that which part triggers set_inv_enable.
+ *  @firmware: firmware data pointer.
+ *  @accel_calib_threshold: accel calibration threshold;
+ *  @accel_calib_rate: divider for accel calibration rate.
+ *  @accel_covariance[COVARIANCE_SIZE]: accel covariance data;
+ *  @kf: kfifo for activity store.
+ *  @activity_size: size for activity.
+ *  @cntl: control word for sensor enable.
+ *  @cntl2: control word for sensor extension.
+ *  @motion_event_cntl: control word for events.
+ *  @intr_cntl: control word for fifo interrupt.
+ *  @dmp_image_size: dmp image size.
+ *  @dmp_start_address: start address of dmp.
+ *  @step_counter_l_on: step counter android L sensor on/off.
+ *  @step_counter_wake_l_on: step counter android L sensor wake on/off .
+ *  @step_detector_l_on: step detector android L sensor on/off.
+ *  @step_detector_wake_l_on: step detector android L sensor wake on/off .
+ *  @gesture_only_on: indicate it is gesture only.
+ *  @mag_divider: mag divider when gyro/accel is faster than mag maximum rate.
+ *  @mag_first_drop_cnt: mag sample counter to be dropped after enable.
+ *  @prev_steps: previous steps sent to the user.
+ *  @aut_key_in: authentication key input.
+ *  @aut_key_out: authentication key output.
+ *  @auth_i: authentication data input
+ *  @auth_o: authentication data output
+ *  @suspend_state: state variable to indicate that we are in suspend state.
+ *  @secondary_gyro_on: DMP out signal to turn on gyro.
+ *  @secondary_mag_on:  DMP out signal to turn on mag.
+ *  @secondary_prox_on: DMP out signal to turn on proximity.
+ *  @secondary_switch: showing this setup is triggerred by secondary switch.
+ *  @send_calib_gyro:       flag to indicate to send calibrated gyro.
+ *  @send_raw_compass: flag to send raw compass.
+ *  @resume_state: flag to synchronize the processing of inv_read_fifo()
+ *  @cycle_on: variable indicate accel cycle mode is on.
+ *  @secondary_switch_data: secondary switch data for activity.
+ *  @raw_gyro_data[6]:    save raw gyro data.
+ *  @raw_compass_data[3]: save raw compass data.
+ *  @wait_queue: wait queue to wake up inv_read_fifo()
+ *  @bac_drive_conf: bac drive configuration.
+ *  @bac_walk_conf: bac walk configuration.
+ *  @bac_smd_conf: bac smd configuration.
+ *  @bac_bike_conf: bac bike configuration.
+ *  @bac_run_conf: bac run configuration.
+ *  @bac_still_conf: back still configuration.
+ *  @power_on_data: power on data.
+ *  @fifo_data_store: store of FIFO data.
+ *  @int_en: store interrupt enable register data.
+ *  @int_en2: store interrupt enable register 2 data.
+ *  @gesture_int_count: interrupt count for gesture only mode.
+ *  @smplrt_div: SMPLRT_DIV register value.
+ */
+struct inv_mpu_state {
+	struct mutex lock;
+	struct device *dev;
+	struct i2c_client *aux_dev;
+	struct iio_trigger *trig;
+	int (*write)(struct inv_mpu_state *st, u8 reg, u8 data);
+	int (*read)(struct inv_mpu_state *st, u8 reg, int len, u8 *data);
+	int (*mem_write)(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+			u32 len, u8 const *data);
+	int (*mem_read)(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+			u32 len, u8 *data);
+	struct inv_chip_config_s chip_config;
+	struct inv_chip_info_s chip_info;
+	struct inv_smd smd;
+	struct inv_ped ped;
+	struct inv_eis eis;
+	struct inv_batch batch;
+	struct inv_temp_comp temp_comp;
+	struct inv_mpu_slave *slave_compass;
+	struct inv_mpu_slave *slave_pressure;
+	struct inv_mpu_slave *slave_als;
+	struct inv_secondary_reg slv_reg[4];
+	struct inv_timestamp_algo ts_algo;
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || defined(CONFIG_INV_MPU_IIO_ICM43600)
+	bool apex_supported;
+	bool smd_supported;
+	struct inv_apex_data apex_data;
+#endif
+	struct inv_secondary_set sec_set;
+	struct inv_engine_info eng_info[ENGINE_NUM_MAX];
+	const struct inv_hw_s *hw;
+	enum inv_devices chip_type;
+	enum inv_bus_type bus_type;
+	enum inv_fifo_count_mode fifo_count_mode;
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock wake_lock;
+#else
+	struct wakeup_source *wake_lock;
+#endif
+#ifdef TIMER_BASED_BATCHING
+	struct hrtimer hr_batch_timer;
+	u64 batch_timeout;
+	bool is_batch_timer_running;
+	struct work_struct batch_work;
+#endif
+	struct i2c_client *client;
+	struct mpu_platform_data plat_data;
+	void *sl_handle;
+	struct inv_sensor sensor[SENSOR_NUM_MAX];
+	struct android_l_sensor sensor_l[SENSOR_L_NUM_MAX];
+	struct inv_sensor_accuracy sensor_accuracy[SENSOR_ACCURACY_NUM_MAX];
+	struct inv_ois ois;
+	bool sensor_acurracy_flag[SENSOR_ACCURACY_NUM_MAX];
+	short irq;
+	int accel_bias[3];
+	int gyro_bias[3];
+	int accel_st_bias[3];
+	int accel_ois_st_bias[3];
+	int gyro_st_bias[3];
+	int gyro_ois_st_bias[3];
+	int gyro_lp_mode;
+	int accel_lp_mode;
+	int input_accel_dmp_bias[3];
+	int input_gyro_dmp_bias[3];
+	int input_compass_dmp_bias[3];
+	int input_accel_bias[3];
+	int input_gyro_bias[3];
+	s16 org_accel_offset_reg[3];
+	s16 org_gyro_offset_reg[3];
+	u8 fifo_data[8];
+	u8 i2c_addr;
+	int header_count;
+	int step_det_count;
+	s32 gyro_sf;
+	u8 left_over[LEFT_OVER_BYTES];
+	u32 left_over_size;
+	u32 fifo_count;
+	bool wake_sensor_received;
+	bool accel_cal_enable;
+	bool gyro_cal_enable;
+	bool calib_compass_on;
+	bool debug_determine_engine_on;
+	bool poke_mode_on;
+	bool mode_1k_on;
+	bool mode_vr_on;
+	u64 poke_ts;
+	u64 step_detector_base_ts;
+	u64 last_temp_comp_time;
+	u8 i2c_dis;
+	u8 name[20];
+	u8 gyro_st_data[3];
+	u8 accel_st_data[3];
+	u8 secondary_name[20];
+	s32 compass_var;
+	int current_compass_matrix[9];
+	int final_compass_matrix[9];
+	enum TRIGGER_STATE trigger_state;
+	u8 *firmware;
+	int accel_calib_threshold;
+	int accel_calib_rate;
+	u32 accel_covariance[COVARIANCE_SIZE];
+	 DECLARE_KFIFO(kf, u8, 128);
+	u32 activity_size;
+	int wom_thld;
+	u16 cntl;
+	u16 cntl2;
+	u16 motion_event_cntl;
+	u16 intr_cntl;
+	int dmp_image_size;
+	int dmp_start_address;
+	bool step_counter_l_on;
+	bool step_counter_wake_l_on;
+	bool step_detector_l_on;
+	bool step_detector_wake_l_on;
+	bool gesture_only_on;
+	int mag_first_drop_cnt;
+	int mag_divider;
+	int prev_steps;
+	u32 curr_steps;
+	int aut_key_in;
+	int aut_key_out;
+	u8 auth_i[256];
+	u8 auth_o[256];
+	bool secondary_gyro_on;
+	bool secondary_mag_on;
+	bool secondary_prox_on;
+	bool secondary_switch;
+	bool send_calib_gyro;
+	bool send_raw_compass;
+	bool send_raw_gyro;
+	bool resume_state;
+	bool cycle_on;
+	int secondary_switch_data;
+	u8 raw_gyro_data[6];
+	u32 raw_compass_data[3];
+	wait_queue_head_t wait_queue;
+	u32 bac_drive_conf;
+	u32 bac_walk_conf;
+	u32 bac_smd_conf;
+	u32 bac_bike_conf;
+	u32 bac_run_conf;
+	u32 bac_still_conf;
+	u32 power_on_data;
+	u8 fifo_data_store[HARDWARE_FIFO_SIZE + LEFT_OVER_BYTES];
+	u8 int_en;
+	u8 int_en_2;
+	u8 int_en_6;
+	int gesture_int_count;
+	u8 smplrt_div;
+};
+
+/**
+ *  struct inv_mpu_slave - MPU slave structure.
+ *  @st_upper:  compass self test upper limit.
+ *  @st_lower:  compass self test lower limit.
+ *  @scale: compass scale.
+ *  @rate_scale: decide how fast a compass can read.
+ *  @min_read_time: minimum time between each reading.
+ *  @self_test: self test method of the slave.
+ *  @set_scale: set scale of slave
+ *  @get_scale: read scale back of the slave.
+ *  @suspend:		suspend operation.
+ *  @resume:		resume operation.
+ *  @setup:		setup chip. initialization.
+ *  @combine_data:	combine raw data into meaningful data.
+ *  @read_data:        read external sensor and output
+ *  @get_mode:		get current chip mode.
+ *  @set_lpf:            set low pass filter.
+ *  @set_fs:             set full scale
+ *  @prev_ts: last time it is read.
+ */
+struct inv_mpu_slave {
+	const short *st_upper;
+	const short *st_lower;
+	int scale;
+	int rate_scale;
+	int min_read_time;
+	int (*self_test)(struct inv_mpu_state *);
+	int (*set_scale)(struct inv_mpu_state *, int scale);
+	int (*get_scale)(struct inv_mpu_state *, int *val);
+	int (*suspend)(struct inv_mpu_state *);
+	int (*resume)(struct inv_mpu_state *);
+	int (*setup)(struct inv_mpu_state *);
+	int (*combine_data)(u8 *in, short *out);
+	int (*read_data)(struct inv_mpu_state *, short *out);
+	int (*get_mode)(void);
+	int (*set_lpf)(struct inv_mpu_state *, int rate);
+	int (*set_fs)(struct inv_mpu_state *, int fs);
+	u64 prev_ts;
+};
+
+/* scan element definition */
+enum inv_mpu_scan {
+	INV_MPU_SCAN_TIMESTAMP,
+};
+
+/* IIO attribute address */
+enum MPU_IIO_ATTR_ADDR {
+	ATTR_DMP_GYRO_X_DMP_BIAS,
+	ATTR_DMP_GYRO_Y_DMP_BIAS,
+	ATTR_DMP_GYRO_Z_DMP_BIAS,
+	ATTR_DMP_GYRO_CAL_ENABLE,
+	ATTR_DMP_ACCEL_X_DMP_BIAS,
+	ATTR_DMP_ACCEL_Y_DMP_BIAS,
+	ATTR_DMP_ACCEL_Z_DMP_BIAS,
+	ATTR_DMP_MAGN_X_DMP_BIAS,
+	ATTR_DMP_MAGN_Y_DMP_BIAS,
+	ATTR_DMP_MAGN_Z_DMP_BIAS,
+	ATTR_DMP_MAGN_ACCURACY,
+	ATTR_GYRO_X_OFFSET,
+	ATTR_GYRO_Y_OFFSET,
+	ATTR_GYRO_Z_OFFSET,
+	ATTR_ACCEL_X_OFFSET,
+	ATTR_ACCEL_Y_OFFSET,
+	ATTR_ACCEL_Z_OFFSET,
+	ATTR_DMP_SC_AUTH,
+	ATTR_DMP_EIS_AUTH,
+	ATTR_DMP_ACCEL_CAL_ENABLE,
+	ATTR_DMP_PED_INT_ON,
+	ATTR_DMP_PED_STEP_THRESH,
+	ATTR_DMP_PED_INT_THRESH,
+	ATTR_DMP_PED_INT_MODE,
+	ATTR_DMP_PED_ON,
+	ATTR_DMP_SMD_ENABLE,
+	ATTR_DMP_TILT_ENABLE,
+	ATTR_DMP_PICK_UP_ENABLE,
+	ATTR_DMP_TAP_ENABLE,
+	ATTR_DMP_STATIONARY_DETECT_ENABLE,
+	ATTR_DMP_MOTION_DETECT_ENABLE,
+	ATTR_DMP_EIS_ENABLE,
+	ATTR_DMP_PEDOMETER_STEPS,
+	ATTR_DMP_PEDOMETER_TIME,
+	ATTR_DMP_PEDOMETER_COUNTER,
+	ATTR_DMP_LOW_POWER_GYRO_ON,
+	ATTR_DMP_LP_EN_OFF,
+	ATTR_DMP_CLK_SEL,
+	ATTR_DMP_DEBUG_MEM_READ,
+	ATTR_DMP_DEBUG_MEM_WRITE,
+	ATTR_DEBUG_REG_WRITE,
+	ATTR_DEBUG_WRITE_CFG,
+	ATTR_DEBUG_REG_ADDR,
+	ATTR_WOM_THLD,
+	/* *****above this line, are DMP features, power needs on/off */
+	/* *****below this line, are DMP features, no power needed */
+	ATTR_IN_POWER_ON,
+	ATTR_HIGH_RES_MODE,
+	ATTR_DMP_ON,
+	ATTR_DMP_EVENT_INT_ON,
+	ATTR_DMP_STEP_COUNTER_ON,
+	ATTR_DMP_STEP_COUNTER_WAKE_ON,
+	ATTR_DMP_STEP_COUNTER_SEND,
+	ATTR_DMP_BATCHMODE_TIMEOUT,
+	ATTR_DMP_BATCHMODE_WAKE_FIFO_FULL,
+	ATTR_DMP_STEP_DETECTOR_ON,
+	ATTR_DMP_STEP_DETECTOR_WAKE_ON,
+	ATTR_DMP_ACTIVITY_ON,
+	ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE,
+	ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE,
+	ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON,
+	ATTR_DMP_MISC_GYRO_RECALIBRATION,
+	ATTR_DMP_MISC_ACCEL_RECALIBRATION,
+	ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD,
+	ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE,
+	ATTR_GYRO_SCALE,
+	ATTR_ACCEL_SCALE,
+	ATTR_COMPASS_SCALE,
+	ATTR_COMPASS_SENSITIVITY_X,
+	ATTR_COMPASS_SENSITIVITY_Y,
+	ATTR_COMPASS_SENSITIVITY_Z,
+	ATTR_GYRO_ENABLE,
+	ATTR_ACCEL_ENABLE,
+	ATTR_COMPASS_ENABLE,
+	ATTR_FIRMWARE_LOADED,
+	ATTR_POKE_MODE,
+	ATTR_ANGLVEL_X_CALIBBIAS,
+	ATTR_ANGLVEL_Y_CALIBBIAS,
+	ATTR_ANGLVEL_Z_CALIBBIAS,
+	ATTR_ACCEL_X_CALIBBIAS,
+	ATTR_ACCEL_Y_CALIBBIAS,
+	ATTR_ACCEL_Z_CALIBBIAS,
+	ATTR_ANGLVEL_X_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Y_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Z_ST_CALIBBIAS,
+	ATTR_ANGLVEL_X_OIS_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Y_OIS_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Z_OIS_ST_CALIBBIAS,
+	ATTR_GYRO_LP_MODE,
+	ATTR_ACCEL_LP_MODE,
+	ATTR_ACCEL_X_ST_CALIBBIAS,
+	ATTR_ACCEL_Y_ST_CALIBBIAS,
+	ATTR_ACCEL_Z_ST_CALIBBIAS,
+	ATTR_ACCEL_X_OIS_ST_CALIBBIAS,
+	ATTR_ACCEL_Y_OIS_ST_CALIBBIAS,
+	ATTR_ACCEL_Z_OIS_ST_CALIBBIAS,
+	ATTR_GYRO_MATRIX,
+	ATTR_ACCEL_MATRIX,
+	ATTR_COMPASS_MATRIX,
+	ATTR_FSYNC_FRAME_COUNT,
+	ATTR_SECONDARY_NAME,
+	ATTR_GYRO_SF,
+	ATTR_BAC_DRIVE_CONFIDENCE,
+	ATTR_BAC_WALK_CONFIDENCE,
+	ATTR_BAC_SMD_CONFIDENCE,
+	ATTR_BAC_BIKE_CONFIDENCE,
+	ATTR_BAC_STILL_CONFIDENCE,
+	ATTR_BAC_RUN_CONFIDENCE,
+	IN_OIS_ACCEL_FS,
+	IN_OIS_GYRO_FS,
+	IN_OIS_ENABLE,
+};
+
+int inv_mpu_configure_ring(struct iio_dev *indio_dev);
+int inv_mpu_probe_trigger(struct iio_dev *indio_dev);
+void inv_mpu_unconfigure_ring(struct iio_dev *indio_dev);
+void inv_mpu_remove_trigger(struct iio_dev *indio_dev);
+#ifdef CONFIG_PM_SLEEP
+int inv_mpu_suspend(struct iio_dev *indio_dev);
+void inv_mpu_complete(struct iio_dev *indio_dev);
+#endif
+
+int inv_get_pedometer_steps(struct inv_mpu_state *st, int *ped);
+int inv_get_pedometer_time(struct inv_mpu_state *st, int *ped);
+int inv_read_pedometer_counter(struct inv_mpu_state *st);
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf);
+int inv_firmware_load(struct inv_mpu_state *st);
+
+int set_inv_enable(struct iio_dev *indio_dev);
+
+int inv_mpu_setup_compass_slave(struct inv_mpu_state *st);
+int inv_mpu_setup_pressure_slave(struct inv_mpu_state *st);
+int inv_mpu_setup_als_slave(struct inv_mpu_state *st);
+int inv_mpu_initialize(struct inv_mpu_state *st);
+int inv_set_accel_sf(struct inv_mpu_state *st);
+int inv_write_accel_sf(struct inv_mpu_state *st); /* to DMP */
+int inv_set_gyro_sf(struct inv_mpu_state *st);
+s64 get_time_ns(void);
+int inv_i2c_read_base(struct inv_mpu_state *st, u16 i, u8 r, u16 l, u8 *d);
+int inv_i2c_single_write_base(struct inv_mpu_state *st, u16 i, u8 r, u8 d);
+int write_be32_to_mem(struct inv_mpu_state *st, u32 data, int addr);
+int write_be16_to_mem(struct inv_mpu_state *st, u16 data, int addr);
+int read_be32_from_mem(struct inv_mpu_state *st, u32 *o, int addr);
+int read_be16_from_mem(struct inv_mpu_state *st, u16 *o, int addr);
+u32 inv_get_cntr_diff(u32 curr_counter, u32 prev);
+int inv_write_2bytes(struct inv_mpu_state *st, int k, int data);
+int inv_set_bank(struct inv_mpu_state *st, u8 bank);
+int inv_set_power(struct inv_mpu_state *st, bool power_on);
+int inv_switch_power_in_lp(struct inv_mpu_state *st, bool on);
+#ifndef CONFIG_INV_MPU_IIO_ICM20608D
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode);
+#endif
+int inv_stop_dmp(struct inv_mpu_state *st);
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off);
+int inv_create_dmp_sysfs(struct iio_dev *ind);
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name);
+int inv_write_compass_matrix(struct inv_mpu_state *st, int *adj);
+irqreturn_t inv_read_fifo(int irq, void *p);
+#ifdef TIMER_BASED_BATCHING
+void inv_batch_work(struct work_struct *work);
+#endif
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data);
+static inline int mpu_memory_write(struct inv_mpu_state *st, u8 mpu_addr,
+		u16 mem_addr, u32 len, u8 const *data)
+{
+	int ret = -1;
+
+	if (st->mem_write)
+		ret = st->mem_write(st, mpu_addr, mem_addr, len, data);
+
+	return ret;
+}
+static inline int mpu_memory_read(struct inv_mpu_state *st, u8 mpu_addr,
+		u16 mem_addr, u32 len, u8 *data)
+{
+	int ret = -1;
+
+	if (st->mem_read)
+		ret = st->mem_read(st, mpu_addr, mem_addr, len, data);
+
+	return ret;
+}
+int inv_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int len);
+int inv_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int v);
+int inv_execute_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+				int reg, int v);
+int inv_execute_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			       int reg, int len, u8 *d);
+
+int inv_push_16bytes_buffer(struct iio_dev *indio_dev, u16 hdr,
+						u64 t, int *q, s16 accur);
+int inv_push_gyro_data(struct iio_dev *indio_dev, s32 *raw, s32 *calib, u64 t);
+int inv_push_8bytes_buffer(struct iio_dev *indio_dev, u16 hdr, u64 t, s16 *d);
+int inv_push_8bytes_kf(struct iio_dev *indio_dev, u16 hdr, u64 t, s16 *d);
+
+void inv_push_step_indicator(struct iio_dev *indio_dev, u64 t);
+int inv_send_steps(struct iio_dev *indio_dev, int step, u64 t);
+int inv_push_marker_to_buffer(struct iio_dev *indio_dev, u16 hdr, int data);
+
+int inv_check_sensor_on(struct inv_mpu_state *st);
+int inv_write_cntl(struct inv_mpu_state *st, u16 wd, bool en, int cntl);
+
+int inv_get_packet_size(struct inv_mpu_state *st, u16 hdr,
+						u32 *pk_size, u8 *dptr);
+int inv_parse_packet(struct iio_dev *indio_dev, u16 hdr, u8 *dptr);
+int inv_pre_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr);
+int inv_process_dmp_data(struct iio_dev *indio_dev);
+
+int be32_to_int(u8 *d);
+void inv_convert_and_push_16bytes(struct iio_dev *indio_dev, u16 hdr,
+				  u8 *d, u64 t, s8 *m);
+void inv_convert_and_push_8bytes(struct iio_dev *indio_dev, u16 hdr,
+				 u8 *d, u64 t, s8 *m);
+int inv_get_dmp_ts(struct inv_mpu_state *st, int i);
+int inv_process_step_det(struct iio_dev *indio_dev, u8 *dptr);
+int inv_process_eis(struct inv_mpu_state *st, u16 delay);
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data);
+
+int inv_setup_dmp_firmware(struct inv_mpu_state *st);
+/* used to print i2c data using pr_debug */
+char *wr_pr_debug_begin(u8 const *data, u32 len, char *string);
+char *wr_pr_debug_end(char *string);
+
+int inv_hw_self_test(struct inv_mpu_state *st);
+int inv_q30_mult(int a, int b);
+#ifdef ACCEL_BIAS_TEST
+int inv_get_3axis_average(s16 src[], s16 dst[], s16 reset);
+#endif
+
+static inline int inv_plat_single_write(struct inv_mpu_state *st,
+							u8 reg, u8 data)
+{
+	int ret = -1;
+
+	if (st->write)
+		ret = st->write(st, reg, data);
+
+	return ret;
+}
+static inline int inv_plat_read(struct inv_mpu_state *st, u8 reg,
+							int len, u8 *data)
+{
+	int ret = -1;
+
+	if (st->read)
+		ret = st->read(st, reg, len, data);
+
+	return ret;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st);
+int inv_restore_interrupt(struct inv_mpu_state *st);
+int inv_stop_stream_interrupt(struct inv_mpu_state *st);
+int inv_restore_stream_interrupt(struct inv_mpu_state *st);
+
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en);
+int inv_dataout_control1(struct inv_mpu_state *st, u16 cntl1);
+int inv_dataout_control2(struct inv_mpu_state *st, u16 cntl2);
+int inv_motion_interrupt_control(struct inv_mpu_state *st,
+						u16 motion_event_cntl);
+
+int inv_bound_timestamp(struct inv_mpu_state *st);
+int inv_update_dmp_ts(struct inv_mpu_state *st, int ind);
+int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st);
+int inv_set_accel_intel(struct inv_mpu_state *st);
+
+int inv_read_offset_regs(struct inv_mpu_state *st,
+		s16 accel[3], s16 gyro[3]);
+int inv_write_offset_regs(struct inv_mpu_state *st,
+		const s16 accel[3], const s16 gyro[3]);
+
+#define mem_w(a, b, c) mpu_memory_write(st, st->i2c_addr, a, b, c)
+#define mem_r(a, b, c) mpu_memory_read(st, st->i2c_addr, a, b, c)
+
+#endif /* #ifndef _INV_MPU_IIO_H_ */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_ring.c b/drivers/iio/imu/inv_mpu/inv_mpu_ring.c
new file mode 100644
index 000000000000..a5599b243ab7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_ring.c
@@ -0,0 +1,632 @@
+/*
+ * Copyright (C) 2012-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/math64.h>
+#include <linux/version.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "inv_mpu_iio.h"
+
+static void inv_push_timestamp(struct iio_dev *indio_dev, u64 t)
+{
+	u8 buf[IIO_BUFFER_BYTES];
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	if (st->poke_mode_on)
+		memcpy(buf, &st->poke_ts, sizeof(t));
+	else
+		memcpy(buf, &t, sizeof(t));
+	iio_push_to_buffers(indio_dev, buf);
+}
+
+int inv_push_marker_to_buffer(struct iio_dev *indio_dev, u16 hdr, int data)
+{
+	u8 buf[IIO_BUFFER_BYTES];
+
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(&buf[4], &data, sizeof(data));
+	iio_push_to_buffers(indio_dev, buf);
+
+	return 0;
+}
+
+static int inv_calc_precision(struct inv_mpu_state *st)
+{
+	int diff;
+	int init;
+
+	if (st->eis.voting_state != 8)
+		return 0;
+	diff = abs(st->eis.fsync_delay_s[1] - st->eis.fsync_delay_s[0]);
+	init = 0;
+	if (diff)
+		init = st->sensor[SENSOR_GYRO].dur / diff;
+
+	if (abs(init - NSEC_PER_USEC) < (NSEC_PER_USEC >> 3))
+		st->eis.count_precision = init;
+	else
+		st->eis.voting_state = 0;
+
+	pr_debug("dur= %d prc= %d\n", st->sensor[SENSOR_GYRO].dur,
+						st->eis.count_precision);
+
+	return 0;
+}
+
+static s64 calc_frame_ave(struct inv_mpu_state *st, int delay)
+{
+	s64 ts;
+
+	ts = st->eis.current_timestamp - delay;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+	ts -= st->ts_algo.gyro_ts_shift;
+#endif
+	pr_debug("shift= %d ts = %lld\n", st->ts_algo.gyro_ts_shift, ts);
+
+	return ts;
+}
+
+static void inv_push_eis_ring(struct iio_dev *indio_dev, int *q, bool sync,
+								s64 t)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct inv_eis *eis = &st->eis;
+	u8 buf[IIO_BUFFER_BYTES];
+	int tmp, ii;
+
+	buf[0] = (EIS_GYRO_HDR & 0xff);
+	buf[1] = (EIS_GYRO_HDR >> 8);
+	memcpy(buf + 4, &q[0], sizeof(q[0]));
+	iio_push_to_buffers(indio_dev, buf);
+	for (ii = 0; ii < 2; ii++)
+		memcpy(buf + 4 * ii, &q[ii + 1], sizeof(q[ii]));
+	iio_push_to_buffers(indio_dev, buf);
+	tmp = eis->frame_count;
+	if (sync)
+		tmp |= 0x80000000;
+	memcpy(buf, &tmp, sizeof(tmp));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+}
+
+static int inv_do_interpolation_gyro(struct iio_dev *indio_dev, int *prev,
+	s64 prev_t, int *curr, s64 curr_t, s64 t, bool trigger)
+{
+	int i;
+	int out[3];
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	prev_t -= st->ts_algo.gyro_ts_shift;
+	prev_t += MPU_4X_TS_GYRO_SHIFT;
+	curr_t -= st->ts_algo.gyro_ts_shift;
+	curr_t += MPU_4X_TS_GYRO_SHIFT;
+#endif
+	if ((t > prev_t) && (t < curr_t)) {
+		for (i = 0; i < 3; i++)
+			out[i] = (int)div_s64((s64)(curr[i] - prev[i]) *
+				(s64)(t - prev_t), curr_t - prev_t) + prev[i];
+	} else if (t < prev_t) {
+		for (i = 0; i < 3; i++)
+			out[i] = prev[i];
+	} else {
+		for (i = 0; i < 3; i++)
+			out[i] = curr[i];
+	}
+	pr_debug("prev= %lld t = %lld curr= %lld\n", prev_t, t, curr_t);
+	pr_debug("prev = %d, %d, %d\n", prev[0], prev[1], prev[2]);
+	pr_debug("curr = %d, %d, %d\n", curr[0], curr[1], curr[2]);
+	pr_debug("out = %d, %d, %d\n", out[0], out[1], out[2]);
+	inv_push_eis_ring(indio_dev, out, trigger, t);
+
+	return 0;
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+static void inv_handle_triggered_eis(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct inv_eis *eis = &st->eis;
+	int delay;
+
+	if (st->eis.eis_frame) {
+		inv_calc_precision(st);
+		delay = ((int)st->eis.fsync_delay) * st->eis.count_precision;
+		eis->fsync_timestamp = calc_frame_ave(st, delay);
+		inv_do_interpolation_gyro(indio_dev,
+			st->eis.prev_gyro,    st->eis.prev_timestamp,
+			st->eis.current_gyro, st->eis.current_timestamp,
+			eis->fsync_timestamp, true);
+		pr_debug("fsync=%lld, curr=%lld, delay=%d\n",
+			eis->fsync_timestamp, eis->current_timestamp, delay);
+		inv_push_eis_ring(indio_dev, st->eis.current_gyro, false,
+			st->eis.current_timestamp - st->ts_algo.gyro_ts_shift
+						+ MPU_4X_TS_GYRO_SHIFT);
+		eis->last_fsync_timestamp = eis->fsync_timestamp;
+	} else {
+		pr_debug("cur= %lld\n", st->eis.current_timestamp);
+		inv_push_eis_ring(indio_dev, st->eis.current_gyro, false,
+			st->eis.current_timestamp - st->ts_algo.gyro_ts_shift
+						+ MPU_4X_TS_GYRO_SHIFT);
+	}
+}
+#else
+static void inv_handle_triggered_eis(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct inv_eis *eis = &st->eis;
+	int delay;
+
+	if ((st->eis.eis_frame && (st->eis.fsync_delay != 5)) ||
+		(st->eis.eis_frame && (st->eis.fsync_delay == 5) &&
+		(!st->eis.current_sync))
+		) {
+		inv_calc_precision(st);
+		delay = ((int)st->eis.fsync_delay) * st->eis.count_precision;
+		eis->fsync_timestamp = calc_frame_ave(st, delay);
+		inv_do_interpolation_gyro(indio_dev,
+			st->eis.prev_gyro,    st->eis.prev_timestamp,
+			st->eis.current_gyro, st->eis.current_timestamp,
+			eis->fsync_timestamp, true);
+		pr_debug("fsync=%lld, curr=%lld, delay=%d\n",
+			eis->fsync_timestamp, eis->current_timestamp, delay);
+		inv_push_eis_ring(indio_dev, st->eis.current_gyro, false,
+				st->eis.current_timestamp);
+		eis->last_fsync_timestamp = eis->fsync_timestamp;
+		st->eis.eis_frame = false;
+	} else {
+		st->eis.current_sync = false;
+		pr_debug("cur= %lld\n", st->eis.current_timestamp);
+		inv_push_eis_ring(indio_dev, st->eis.current_gyro, false,
+				st->eis.current_timestamp);
+	}
+}
+#endif
+static void inv_push_eis_buffer(struct iio_dev *indio_dev, u64 t, int *q)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int ii;
+
+	if (st->eis.eis_triggered) {
+		for (ii = 0; ii < 3; ii++)
+			st->eis.prev_gyro[ii] = st->eis.current_gyro[ii];
+		st->eis.prev_timestamp = st->eis.current_timestamp;
+
+		for (ii = 0; ii < 3; ii++)
+			st->eis.current_gyro[ii] = q[ii];
+		st->eis.current_timestamp = t;
+		inv_handle_triggered_eis(indio_dev);
+	} else {
+		for (ii = 0; ii < 3; ii++)
+			st->eis.current_gyro[ii] = q[ii];
+		st->eis.current_timestamp = t;
+	}
+}
+static int inv_push_16bytes_final(struct iio_dev *indio_dev, int j,
+						s32 *q, u64 t, s16 accur)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 buf[IIO_BUFFER_BYTES];
+	int ii;
+
+	memcpy(buf, &st->sensor_l[j].header, sizeof(st->sensor_l[j].header));
+	memcpy(buf + 2, &accur, sizeof(accur));
+	memcpy(buf + 4, &q[0], sizeof(q[0]));
+	iio_push_to_buffers(indio_dev, buf);
+	for (ii = 0; ii < 2; ii++)
+		memcpy(buf + 4 * ii, &q[ii + 1], sizeof(q[ii]));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+	st->sensor_l[j].counter = 0;
+	if (st->sensor_l[j].wake_on)
+		st->wake_sensor_received = true;
+
+	return 0;
+}
+int inv_push_16bytes_buffer(struct iio_dev *indio_dev, u16 sensor,
+				    u64 t, int *q, s16 accur)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int j;
+
+	for (j = 0; j < SENSOR_L_NUM_MAX; j++) {
+		if (st->sensor_l[j].on && (st->sensor_l[j].base == sensor)) {
+			st->sensor_l[j].counter++;
+			if ((st->sensor_l[j].div != 0xffff) &&
+				(st->sensor_l[j].counter >=
+						st->sensor_l[j].div)) {
+				pr_debug(
+	"Sensor_l = %d sensor = %d header [%04X] div [%d] ts [%lld] %d %d %d\n",
+					j, sensor,
+					st->sensor_l[j].header,
+					st->sensor_l[j].div,
+					t, q[0], q[1], q[2]);
+				inv_push_16bytes_final(indio_dev, j, q, t, accur);
+			}
+		}
+	}
+	return 0;
+}
+
+void inv_convert_and_push_16bytes(struct iio_dev *indio_dev, u16 hdr,
+							u8 *d, u64 t, s8 *m)
+{
+	int i, j;
+	s32 in[3], out[3];
+
+	for (i = 0; i < 3; i++)
+		in[i] = be32_to_int(d + i * 4);
+	/* multiply with orientation matrix can be optimized like this */
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			if (m[i * 3 + j])
+				out[i] = in[j] * m[i * 3 + j];
+
+	inv_push_16bytes_buffer(indio_dev, hdr, t, out, 0);
+}
+
+void inv_convert_and_push_8bytes(struct iio_dev *indio_dev, u16 hdr,
+				 u8 *d, u64 t, s8 *m)
+{
+	int i, j;
+	s16 in[3], out[3];
+
+	for (i = 0; i < 3; i++)
+		in[i] = be16_to_cpup((__be16 *) (d + i * 2));
+
+	/* multiply with orientation matrix can be optimized like this */
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			if (m[i * 3 + j])
+				out[i] = in[j] * m[i * 3 + j];
+
+	inv_push_8bytes_buffer(indio_dev, hdr, t, out);
+}
+
+static int inv_push_special_8bytes_buffer(struct iio_dev *indio_dev,
+					  u16 hdr, u64 t, s16 *d)
+{
+	u8 buf[IIO_BUFFER_BYTES];
+	int j;
+
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(&buf[2], &d[0], sizeof(d[0]));
+	for (j = 0; j < 2; j++)
+		memcpy(&buf[4 + j * 2], &d[j + 1], sizeof(d[j]));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+
+	return 0;
+}
+
+static int inv_s32_gyro_push(struct iio_dev *indio_dev, int i, s32 *calib, u64 t)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	if (st->sensor_l[i].on) {
+		st->sensor_l[i].counter++;
+		if ((st->sensor_l[i].div != 0xffff) &&
+			(st->sensor_l[i].counter >= st->sensor_l[i].div)) {
+			inv_push_16bytes_final(indio_dev, i, calib, t, 0);
+			st->sensor_l[i].counter = 0;
+			if (st->sensor_l[i].wake_on)
+				st->wake_sensor_received = true;
+		}
+	}
+
+	return 0;
+}
+
+int inv_push_gyro_data(struct iio_dev *indio_dev, s32 *raw, s32 *calib, u64 t)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int gyro_data[] = {SENSOR_L_GYRO, SENSOR_L_GYRO_WAKE};
+	int calib_data[] = {SENSOR_L_GYRO_CAL, SENSOR_L_GYRO_CAL_WAKE};
+	int i;
+
+	if (st->sensor_l[SENSOR_L_EIS_GYRO].on)
+		inv_push_eis_buffer(indio_dev, t, calib);
+
+	for (i = 0; i < 2; i++)
+		inv_s32_gyro_push(indio_dev, gyro_data[i], raw, t);
+	for (i = 0; i < 2; i++)
+		inv_s32_gyro_push(indio_dev, calib_data[i], calib, t);
+
+	return 0;
+}
+int inv_push_8bytes_buffer(struct iio_dev *indio_dev, u16 sensor, u64 t, s16 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 buf[IIO_BUFFER_BYTES];
+	int ii, j;
+
+	if ((sensor == STEP_DETECTOR_HDR) ||
+		(sensor == STEP_DETECTOR_WAKE_HDR) ||
+		(sensor == TAP_HDR)) {
+		memcpy(buf, &sensor, sizeof(sensor));
+		memcpy(&buf[2], &d[0], sizeof(d[0]));
+		for (j = 0; j < 2; j++)
+			memcpy(&buf[4 + j * 2], &d[j + 1], sizeof(d[j]));
+		iio_push_to_buffers(indio_dev, buf);
+		inv_push_timestamp(indio_dev, t);
+		if (sensor == STEP_DETECTOR_WAKE_HDR)
+			st->wake_sensor_received = true;
+		return 0;
+	}
+	for (ii = 0; ii < SENSOR_L_NUM_MAX; ii++) {
+		if (st->sensor_l[ii].on &&
+		    (st->sensor_l[ii].base == sensor) &&
+		    (st->sensor_l[ii].div != 0xffff)) {
+			st->sensor_l[ii].counter++;
+			if (st->sensor_l[ii].counter >= st->sensor_l[ii].div) {
+				pr_debug(
+	"Sensor_l = %d sensor = %d header [%04X] div [%d] ts [%lld] %d %d %d\n",
+	ii, sensor, st->sensor_l[ii].header,
+	st->sensor_l[ii].div, t, d[0], d[1], d[2]);
+
+				memcpy(buf, &st->sensor_l[ii].header,
+				       sizeof(st->sensor_l[ii].header));
+				memcpy(&buf[2], &d[0], sizeof(d[0]));
+				for (j = 0; j < 2; j++)
+					memcpy(&buf[4 + j * 2], &d[j + 1],
+					       sizeof(d[j]));
+
+				iio_push_to_buffers(indio_dev, buf);
+				inv_push_timestamp(indio_dev, t);
+				st->sensor_l[ii].counter = 0;
+				if (st->sensor_l[ii].wake_on)
+					st->wake_sensor_received = true;
+			}
+		}
+	}
+
+	return 0;
+}
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+/* Implemented activity to string function for BAC test */
+#define TILT_DETECTED  0x1000
+#define NONE 0x00
+#define DRIVE 0x01
+#define WALK 0x02
+#define RUN 0x04
+#define BIKE 0x08
+#define TILT 0x10
+#define STILL 0x20
+#define DRIVE_WALK (DRIVE | WALK)
+#define DRIVE_RUN (DRIVE | RUN)
+
+char *act_string(s16 data)
+{
+	data &= (~TILT);
+	switch (data) {
+	case NONE:
+		return "None";
+	case DRIVE:
+		return "Drive";
+	case WALK:
+		return "Walk";
+	case RUN:
+		return "Run";
+	case BIKE:
+		return "Bike";
+	case STILL:
+		return "Still";
+	case DRIVE_WALK:
+		return "drive and walk";
+	case DRIVE_RUN:
+		return "drive and run";
+	default:
+		return "Unknown";
+	}
+	return "Unknown";
+}
+
+char *inv_tilt_check(s16 data)
+{
+	if (data & TILT)
+		return "Tilt";
+	else
+		return "None";
+}
+
+int inv_push_8bytes_kf(struct iio_dev *indio_dev, u16 hdr, u64 t, s16 *d)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 buf[IIO_BUFFER_BYTES];
+	int i;
+
+	if (st->chip_config.activity_on) {
+		memcpy(buf, &hdr, sizeof(hdr));
+		for (i = 0; i < 3; i++)
+			memcpy(&buf[2 + i * 2], &d[i], sizeof(d[i]));
+
+		kfifo_in(&st->kf, buf, IIO_BUFFER_BYTES);
+		memcpy(buf, &t, sizeof(t));
+		kfifo_in(&st->kf, buf, IIO_BUFFER_BYTES);
+		st->activity_size += IIO_BUFFER_BYTES * 2;
+	}
+	if (st->chip_config.tilt_enable) {
+		pr_debug("d[0] = %04X,  [%X : %s] to [%X : %s]",
+		d[0], d[0] & 0x00FF,
+		inv_tilt_check(d[0] & 0x00FF),
+		(d[0] & 0xFF00) >> 8,  inv_tilt_check((d[0] & 0xFF00) >> 8));
+		if (!((d[0] & 0x00FF) & TILT) &&
+				(((d[0] & 0xFF00) >> 8) & TILT)) {
+			/* Not Tilt to Tilt */
+			sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_tilt");
+			st->wake_sensor_received = true; /* Tilt is wake-up */
+		}
+	}
+
+	pr_debug("d[0] = %04X,  [%X : %s] to [%X : %s]", d[0], d[0] & 0x00FF,
+		act_string(d[0] & 0x00FF),
+		(d[0] & 0xFF00) >> 8,  act_string((d[0] & 0xFF00) >> 8));
+
+	read_be32_from_mem(st, &st->bac_drive_conf, BAC_DRIVE_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_walk_conf, BAC_WALK_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_smd_conf, BAC_SMD_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_bike_conf, BAC_BIKE_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_still_conf, BAC_STILL_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_run_conf, BAC_RUN_CONFIDENCE);
+
+	return 0;
+}
+#endif
+
+int inv_send_steps(struct iio_dev *indio_dev, int step, u64 ts)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	s16 s[3];
+
+	s[0] = 0;
+	s[1] = (s16) (step & 0xffff);
+	s[2] = (s16) ((step >> 16) & 0xffff);
+	if (st->step_counter_l_on)
+		inv_push_special_8bytes_buffer(indio_dev, STEP_COUNTER_HDR, ts, s);
+	if (st->step_counter_wake_l_on) {
+		inv_push_special_8bytes_buffer(indio_dev, STEP_COUNTER_WAKE_HDR,
+					       ts, s);
+		st->wake_sensor_received = true;
+	}
+	return 0;
+}
+
+void inv_push_step_indicator(struct iio_dev *indio_dev, u64 t)
+{
+	s16 sen[3];
+#define STEP_INDICATOR_HEADER 0x0001
+
+	sen[0] = 0;
+	sen[1] = 0;
+	sen[2] = 0;
+	inv_push_8bytes_buffer(indio_dev, STEP_INDICATOR_HEADER, t, sen);
+}
+
+#ifdef TIMER_BASED_BATCHING
+static enum hrtimer_restart inv_batch_timer_handler(struct hrtimer *timer)
+{
+	struct inv_mpu_state *st =
+		container_of(timer, struct inv_mpu_state, hr_batch_timer);
+
+	if (st->chip_config.gyro_enable || st->chip_config.accel_enable) {
+		hrtimer_forward_now(&st->hr_batch_timer,
+			ns_to_ktime(st->batch_timeout));
+		schedule_work(&st->batch_work);
+		return HRTIMER_RESTART;
+	}
+	st->is_batch_timer_running = 0;
+	return HRTIMER_NORESTART;
+}
+#endif
+
+static int inv_mpu_set_trigger(struct iio_trigger *trig, bool state)
+{
+	/* unused for the moment */
+	return 0;
+}
+
+static const struct iio_trigger_ops inv_mpu_trigger_ops = {
+	.set_trigger_state = &inv_mpu_set_trigger,
+};
+
+int inv_mpu_configure_ring(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifdef TIMER_BASED_BATCHING
+	/* configure hrtimer */
+	hrtimer_init(&st->hr_batch_timer, CLOCK_BOOTTIME, HRTIMER_MODE_REL);
+	st->hr_batch_timer.function = inv_batch_timer_handler;
+	INIT_WORK(&st->batch_work, inv_batch_work);
+#endif
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL, inv_read_fifo, NULL);
+	if (ret) {
+		dev_err(st->dev, "iio triggered buffer failed %d\n", ret);
+		return ret;
+	}
+
+	st->trig = iio_trigger_alloc(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 13, 0)
+				     st->dev,
+#endif
+				    "%s-dev%d", indio_dev->name,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+				     indio_dev->id);
+#else
+				     iio_device_id(indio_dev));
+#endif
+	if (st->trig == NULL) {
+		ret = -ENOMEM;
+		dev_err(st->dev, "iio trigger alloc error\n");
+		goto error_free_buffer;
+	}
+	st->trig->dev.parent = st->dev;
+	st->trig->ops = &inv_mpu_trigger_ops;
+	iio_trigger_set_drvdata(st->trig, indio_dev);
+
+	ret = request_irq(st->irq, &iio_trigger_generic_data_rdy_poll,
+			  IRQF_TRIGGER_RISING, "inv_mpu", st->trig);
+	if (ret) {
+		dev_err(st->dev, "irq request error %d\n", ret);
+		goto error_free_trigger;
+	}
+
+	ret = iio_trigger_register(st->trig);
+	if (ret) {
+		dev_err(st->dev, "iio trigger register error %d\n", ret);
+		goto error_free_irq;
+	}
+	iio_trigger_get(st->trig);
+	indio_dev->trig = st->trig;
+
+	return 0;
+
+error_free_irq:
+	free_irq(st->irq, st->trig);
+error_free_trigger:
+	iio_trigger_free(st->trig);
+error_free_buffer:
+	iio_triggered_buffer_cleanup(indio_dev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_configure_ring);
+
+void inv_mpu_unconfigure_ring(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	iio_trigger_unregister(st->trig);
+	free_irq(st->irq, st->trig);
+	iio_trigger_free(st->trig);
+	iio_triggered_buffer_cleanup(indio_dev);
+};
+EXPORT_SYMBOL_GPL(inv_mpu_unconfigure_ring);
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_spi.c b/drivers/iio/imu/inv_mpu/inv_mpu_spi.c
new file mode 100644
index 000000000000..46888997a395
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_spi.c
@@ -0,0 +1,422 @@
+/*
+* Copyright (C) 2012-2020 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+#include <linux/errno.h>
+#include <linux/version.h>
+
+#include "inv_mpu_iio.h"
+#include "inv_mpu_dts.h"
+
+#define INV_SPI_READ 0x80
+
+static int inv_spi_single_write(struct inv_mpu_state *st, u8 reg, u8 data)
+{
+	struct spi_message msg;
+	int res;
+	u8 d[2];
+	struct spi_transfer xfers = {
+		.tx_buf = d,
+		.bits_per_word = 8,
+		.len = 2,
+	};
+
+	pr_debug("reg_write: reg=0x%x data=0x%x\n", reg, data);
+	d[0] = reg;
+	d[1] = data;
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	return res;
+}
+
+static int inv_spi_read(struct inv_mpu_state *st, u8 reg, int len, u8 *data)
+{
+	struct spi_message msg;
+	int res;
+	u8 d[1];
+	struct spi_transfer xfers[] = {
+		{
+		 .tx_buf = d,
+		 .bits_per_word = 8,
+		 .len = 1,
+		 },
+		{
+		 .rx_buf = data,
+		 .bits_per_word = 8,
+		 .len = len,
+		 }
+	};
+
+	if (!data)
+		return -EINVAL;
+
+	d[0] = (reg | INV_SPI_READ);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	if (len ==1)
+		pr_debug("reg_read: reg=0x%x length=%d data=0x%x\n",
+							reg, len, data[0]);
+	else
+		pr_debug("reg_read: reg=0x%x length=%d d0=0x%x d1=0x%x\n",
+					reg, len, data[0], data[1]);
+
+	return res;
+
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+static int inv_spi_mem_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+		     u32 len, u8 const *data)
+{
+	struct spi_message msg;
+	u8 buf[258];
+	int res;
+
+	struct spi_transfer xfers = {
+		.tx_buf = buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len > (sizeof(buf) - 1))
+		return -ENOMEM;
+
+	inv_plat_single_write(st, REG_MEM_BANK_SEL, mem_addr >> 8);
+	inv_plat_single_write(st, REG_MEM_START_ADDR, mem_addr & 0xFF);
+
+	buf[0] = REG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	return res;
+}
+
+static int inv_spi_mem_read(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+		    u32 len, u8 *data)
+{
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len > 256)
+		return -EINVAL;
+
+	res = inv_plat_single_write(st, REG_MEM_BANK_SEL, mem_addr >> 8);
+	res = inv_plat_single_write(st, REG_MEM_START_ADDR, mem_addr & 0xFF);
+	res = inv_plat_read(st, REG_MEM_R_W, len, data);
+
+	return res;
+}
+#endif
+
+/*
+ *  inv_mpu_probe() - probe function.
+ */
+static int inv_mpu_probe(struct spi_device *spi)
+{
+	const struct spi_device_id *id = spi_get_device_id(spi);
+	struct inv_mpu_state *st;
+	struct iio_dev *indio_dev;
+	int result;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+	indio_dev = iio_device_alloc(sizeof(*st));
+#else
+	indio_dev = iio_device_alloc(&spi->dev, sizeof(*st));
+#endif
+	if (indio_dev == NULL) {
+		pr_err("memory allocation failed\n");
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	st = iio_priv(indio_dev);
+	mutex_init(&st->lock);
+	st->write = inv_spi_single_write;
+	st->read = inv_spi_read;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	st->mem_write = inv_spi_mem_write;
+	st->mem_read = inv_spi_mem_read;
+#endif
+	st->dev = &spi->dev;
+	st->irq = spi->irq;
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	st->i2c_dis = BIT_UI_SIFS_DISABLE_I2C;
+#elif defined(CONFIG_INV_MPU_IIO_ICM43600)
+	st->i2c_dis = BIT_SIFS_CFG_SPI_ONLY;
+#elif !defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	&& !defined(CONFIG_INV_MPU_IIO_IAM20680)
+	st->i2c_dis = BIT_I2C_IF_DIS;
+#endif
+	st->bus_type = BUS_SPI;
+	spi_set_drvdata(spi, indio_dev);
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = id->name;
+
+#ifdef CONFIG_OF
+	result = invensense_mpu_parse_dt(st->dev, &st->plat_data);
+	if (result)
+		goto out_free;
+#else
+	if (dev_get_platdata(st->dev) == NULL) {
+		result = -ENODEV;
+		goto out_free;
+	}
+	st->plat_data = *(struct mpu_platform_data *)dev_get_platdata(st->dev);
+#endif
+	/* Power on device */
+	if (st->plat_data.power_on) {
+		result = st->plat_data.power_on(&st->plat_data);
+		if (result < 0) {
+			dev_err(st->dev, "power_on failed: %d\n", result);
+			goto out_free;
+		}
+		pr_info("%s: power on here.\n", __func__);
+	}
+	pr_info("%s: power on.\n", __func__);
+
+	msleep(100);
+
+	/* power is turned on inside check chip type */
+	result = inv_check_chip_type(indio_dev, id->name);
+	if (result)
+		goto out_free;
+
+	result = inv_mpu_configure_ring(indio_dev);
+	if (result) {
+		pr_err("configure ring buffer fail\n");
+		goto out_free;
+	}
+
+	result = iio_device_register(indio_dev);
+	if (result) {
+		pr_err("IIO device register fail\n");
+		goto out_unreg_ring;
+	}
+
+	result = inv_create_dmp_sysfs(indio_dev);
+	if (result) {
+		pr_err("create dmp sysfs failed\n");
+		goto out_unreg_iio;
+	}
+	init_waitqueue_head(&st->wait_queue);
+	st->resume_state = true;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&st->wake_lock, WAKE_LOCK_SUSPEND, "inv_mpu");
+#else
+	st->wake_lock = wakeup_source_create("inv_mpu");
+	wakeup_source_add(st->wake_lock);
+	if (st->wake_lock)
+		pr_info("wakeup_source is created successfully\n");
+	else
+		pr_info("failed to create wakeup_source\n");
+#endif
+	dev_info(st->dev, "%s ma-kernel-%s is ready to go!\n",
+	         indio_dev->name, INVENSENSE_DRIVER_VERSION);
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	pr_info("Data read from registers\n");
+#else
+	pr_info("Data read from FIFO\n");
+#endif
+#ifdef TIMER_BASED_BATCHING
+	pr_info("Timer based batching\n");
+#endif
+
+	return 0;
+
+out_unreg_iio:
+	iio_device_unregister(indio_dev);
+out_unreg_ring:
+	inv_mpu_unconfigure_ring(indio_dev);
+out_free:
+	iio_device_free(indio_dev);
+out_no_free:
+	if (result != -EPROBE_DEFER)
+		dev_err(&spi->dev, "%s failed %d\n", __func__, result);
+	return result;
+}
+
+static void inv_mpu_shutdown(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&st->lock);
+	inv_switch_power_in_lp(st, true);
+	dev_dbg(st->dev, "Shutting down %s...\n", st->hw->name);
+
+	/* turn off power to ensure gyro engine is off */
+	result = inv_set_power(st, false);
+	if (result)
+		dev_err(st->dev, "Failed to turn off %s\n",
+			st->hw->name);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&st->lock);
+}
+
+/*
+ *  inv_mpu_remove() - remove function.
+ */
+static int inv_mpu_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef CONFIG_HAS_WAKELOCK
+	if (st->wake_lock)
+		wakeup_source_destroy(st->wake_lock);
+#endif
+	iio_device_unregister(indio_dev);
+	inv_mpu_unconfigure_ring(indio_dev);
+	iio_device_free(indio_dev);
+	dev_info(st->dev, "inv-mpu-iio module removed.\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int inv_mpu_spi_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));
+
+	return inv_mpu_suspend(indio_dev);
+}
+
+static void inv_mpu_spi_complete(struct device *dev)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));
+
+	inv_mpu_complete(indio_dev);
+}
+#endif
+
+static const struct dev_pm_ops inv_mpu_spi_pmops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = inv_mpu_spi_suspend,
+	.complete = inv_mpu_spi_complete,
+#endif
+};
+
+/* device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct spi_device_id inv_mpu_id[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{"icm20648", ICM20648},
+#else
+	{"icm20608d", ICM20608D},
+	{"icm20690", ICM20690},
+	{"icm20602", ICM20602},
+	{"iam20680", IAM20680},
+	{"icm42600", ICM42600},
+	{"icm42686", ICM42686},
+	{"icm42688", ICM42688},
+	{"icm40609d", ICM40609D},
+	{"icm43600", ICM43600},
+	{"iim42600", ICM42600},
+#endif
+	{}
+};
+MODULE_DEVICE_TABLE(spi, inv_mpu_id);
+
+static const struct of_device_id inv_mpu_of_match[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{
+		.compatible = "invensense,icm20648",
+		.data = (void *)ICM20648,
+	},
+#else
+	{
+		.compatible = "invensense,icm20608d",
+		.data = (void *)ICM20608D,
+	}, {
+		.compatible = "invensense,icm20690",
+		.data = (void *)ICM20690,
+	}, {
+		.compatible = "invensense,icm20602",
+		.data = (void *)ICM20602,
+	}, {
+		.compatible = "invensense,iam20680",
+		.data = (void *)IAM20680,
+	}, {
+		.compatible = "invensense,icm42600",
+		.data = (void *)ICM42600,
+	}, {
+		.compatible = "invensense,icm42686",
+		.data = (void *)ICM42686,
+	}, {
+		.compatible = "invensense,icm42688",
+		.data = (void *)ICM42688,
+	}, {
+		.compatible = "invensense,icm40609d",
+		.data = (void *)ICM40609D,
+	}, {
+		.compatible = "invensense,icm43600",
+		.data = (void *)ICM43600,
+	}, {
+		.compatible = "invensense,iim42600",
+		.data = (void *)ICM42600,
+	},
+#endif
+	{ }
+};
+MODULE_DEVICE_TABLE(of, inv_mpu_of_match);
+
+static struct spi_driver inv_mpu_driver = {
+	.probe = inv_mpu_probe,
+	.remove = inv_mpu_remove,
+	.shutdown = inv_mpu_shutdown,
+	.id_table = inv_mpu_id,
+	.driver = {
+		.owner = THIS_MODULE,
+		.of_match_table = inv_mpu_of_match,
+		.name = "inv-mpu-iio-spi",
+		.pm = &inv_mpu_spi_pmops,
+	},
+};
+module_spi_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense SPI device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c b/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c
new file mode 100644
index 000000000000..46bbb1fc0028
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2012-2021 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "inv_mpu_iio.h"
+
+#define INV_TIME_CALIB_THRESHOLD_1 2
+
+#define MIN_DELAY (3 * NSEC_PER_MSEC)
+#define JITTER_THRESH (1 * NSEC_PER_MSEC)
+
+int inv_update_dmp_ts(struct inv_mpu_state *st, int ind)
+{
+	int i;
+	u32 counter;
+	u64 ts;
+	enum INV_ENGINE en_ind;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	u32 base_time;
+	u64 cal_period;
+
+	if (st->mode_1k_on)
+		cal_period = (NSEC_PER_SEC >> 2);
+	else
+		cal_period = 2 * NSEC_PER_SEC;
+
+	ts = ts_algo->last_run_time - st->sensor[ind].time_calib;
+	counter = st->sensor[ind].sample_calib;
+	en_ind = st->sensor[ind].engine_base;
+	if (en_ind != ts_algo->clock_base)
+		return 0;
+	/* we average over 2 seconds period to do the timestamp calculation */
+	if (ts < cal_period)
+		return 0;
+	/* this is the first time we do timestamp averaging, return */
+	/* after resume from suspend, the clock of linux has up to 1 seconds
+	   drift. We should start from the resume clock instead of using clock
+	   before resume */
+	if ((!st->sensor[ind].calib_flag) || ts_algo->resume_flag) {
+		st->sensor[ind].sample_calib = 0;
+		st->sensor[ind].time_calib = ts_algo->last_run_time;
+		st->sensor[ind].calib_flag = 1;
+		ts_algo->resume_flag = false;
+
+		return 0;
+	}
+	/* if the sample number in current FIFO is not zero and between now and
+		last update time is more than 2 seconds, we do calculation */
+	if ((counter > 0) &&
+		(ts_algo->last_run_time - st->eng_info[en_ind].last_update_time >
+		 cal_period)) {
+		/* duration for each sensor */
+		st->sensor[ind].dur = (u32) div_u64(ts, counter);
+		/* engine duration derived from each sensor */
+		if (st->sensor[ind].div)
+			st->eng_info[en_ind].dur = st->sensor[ind].dur /
+							st->sensor[ind].div;
+		else
+			pr_err("sensor %d divider zero!\n", ind);
+		/* update base time for each sensor */
+		if (st->eng_info[en_ind].divider) {
+			base_time = (st->eng_info[en_ind].dur /
+					st->eng_info[en_ind].divider) *
+					st->eng_info[en_ind].orig_rate;
+			if (st->mode_1k_on)
+				st->eng_info[en_ind].base_time_1k = base_time;
+			else
+				st->eng_info[en_ind].base_time = base_time;
+		} else {
+			pr_err("engine %d divider zero!\n", en_ind);
+		}
+
+		st->eng_info[en_ind].last_update_time = ts_algo->last_run_time;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+		defined(CONFIG_INV_MPU_IIO_ICM20608D) || \
+		defined(CONFIG_INV_MPU_IIO_ICM42600) || \
+		defined(CONFIG_INV_MPU_IIO_ICM43600)
+		/* update all the sensors duration based on the same engine */
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on &&
+			    (st->sensor[i].engine_base == en_ind))
+				st->sensor[i].dur = st->sensor[i].div *
+				    st->eng_info[en_ind].dur;
+		}
+#else
+		/* update all the sensors duration. There is a single engine */
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on)
+				st->sensor[i].dur = st->sensor[i].div *
+					st->eng_info[en_ind].dur;
+		}
+#endif
+
+	}
+	st->sensor[ind].sample_calib = 0;
+	st->sensor[ind].time_calib = ts_algo->last_run_time;
+
+	return 0;
+}
+/**
+ *     int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st)
+ *     This is the function to get last run time in non dmp and record mode.
+ *     This function will update the last_run_time, which is important parameter
+ *     in overall timestamp algorithm.
+ *     return value: this function returns fifo count value.
+*/
+int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st)
+{
+	long long t_pre, t_post, dur;
+	int fifo_count;
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	int res;
+	u8 data[2];
+#endif
+
+	t_pre = get_time_ns();
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	res = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, data);
+	if (res) {
+		pr_info("read REG_FIFO_COUNT_H failed= %d\n", res);
+		return 0;
+	}
+#endif
+	t_post = get_time_ns();
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	if (st->fifo_count_mode == BYTE_MODE)
+		fifo_count = st->batch.pk_size;
+	else
+		fifo_count = 1;
+#else
+	fifo_count = be16_to_cpup((__be16 *) (data));
+#endif
+	pr_debug("fifc=%d\n", fifo_count);
+	if (!fifo_count)
+		return 0;
+
+	/* In non DMP mode, either gyro or accel duration is the duration
+		for each sample */
+	if (st->chip_config.gyro_enable)
+		dur = st->eng_info[ENGINE_GYRO].dur;
+	else
+		dur = st->eng_info[ENGINE_ACCEL].dur;
+
+	if (st->fifo_count_mode == BYTE_MODE) {
+		fifo_count /= st->batch.pk_size;
+	}
+
+	/* In record mode, each number in fifo_count is 1 record or 1 sample */
+	st->ts_algo.last_run_time += dur * fifo_count;
+	if (st->ts_algo.last_run_time < t_pre)
+		st->ts_algo.last_run_time = t_pre;
+	if (st->ts_algo.last_run_time > t_post)
+		st->ts_algo.last_run_time = t_post;
+
+	return fifo_count;
+}
+
+int inv_get_dmp_ts(struct inv_mpu_state *st, int i)
+{
+	u64 current_time;
+	int expected_lower_duration, expected_upper_duration;
+
+	current_time = get_time_ns();
+
+	st->sensor[i].ts += st->sensor[i].dur + st->sensor[i].ts_adj;
+
+	if (st->sensor[i].ts < st->sensor[i].previous_ts)
+		st->sensor[i].ts = st->sensor[i].previous_ts + st->sensor[i].dur;
+
+	/* hifi sensor limits ts jitter to +/- 2% */
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	/* for DMP enabled devices */
+	expected_upper_duration =
+		st->eng_info[st->sensor[i].engine_base].dur *
+		st->sensor[i].div / 1000 * 1020;
+	expected_lower_duration =
+		st->eng_info[st->sensor[i].engine_base].dur *
+		st->sensor[i].div / 1000 * 980;
+#else
+	/* for no DMP devices */
+#if defined(CONFIG_INV_MPU_IIO_ICM42600) || \
+	defined(CONFIG_INV_MPU_IIO_ICM43600)
+	expected_upper_duration =
+		st->eng_info[st->sensor[i].engine_base].dur / 1000 * 1020;
+	expected_lower_duration =
+		st->eng_info[st->sensor[i].engine_base].dur / 1000 * 980;
+#else
+	expected_upper_duration =
+		st->eng_info[st->ts_algo.clock_base].dur / 1000 * 1020;
+	expected_lower_duration =
+		st->eng_info[st->ts_algo.clock_base].dur / 1000 * 980;
+#endif
+#endif
+
+	if (st->sensor[i].ts < st->sensor[i].previous_ts + expected_lower_duration)
+		st->sensor[i].ts = st->sensor[i].previous_ts + expected_lower_duration;
+	if (st->sensor[i].ts > st->sensor[i].previous_ts + expected_upper_duration)
+		st->sensor[i].ts = st->sensor[i].previous_ts + expected_upper_duration;
+
+	if (st->sensor[i].ts > current_time)
+		st->sensor[i].ts = current_time;
+
+	st->sensor[i].previous_ts = st->sensor[i].ts;
+
+	pr_debug("ts=%lld, reset=%lld\n", st->sensor[i].ts, st->ts_algo.reset_ts);
+	if (st->sensor[i].ts < st->ts_algo.reset_ts) {
+		pr_debug("less than reset\n");
+		st->sensor[i].send = false;
+	} else {
+		st->sensor[i].send = true;
+	}
+
+	if (st->header_count == 1)
+		inv_update_dmp_ts(st, i);
+
+	return 0;
+}
+
+static void process_sensor_bounding(struct inv_mpu_state *st, int i)
+{
+	s64 elaps_time, thresh1, thresh2;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	u32 dur;
+
+	elaps_time = ((u64) (st->sensor[i].dur)) * st->sensor[i].count;
+	thresh1 = ts_algo->last_run_time - elaps_time;
+
+	dur = max(st->sensor[i].dur, (int)MIN_DELAY);
+	thresh2 = thresh1 - dur;
+	if (thresh1 < 0)
+		thresh1 = 0;
+	if (thresh2 < 0)
+		thresh2 = 0;
+	st->sensor[i].ts_adj = 0;
+	if ((ts_algo->calib_counter >= INV_TIME_CALIB_THRESHOLD_1) &&
+						(!ts_algo->resume_flag)) {
+		if (st->sensor[i].ts < thresh2)
+			st->sensor[i].ts_adj = thresh2 - st->sensor[i].ts;
+	} else if ((ts_algo->calib_counter >=
+		INV_TIME_CALIB_THRESHOLD_1) && ts_algo->resume_flag) {
+		if (st->sensor[i].ts < thresh2)
+			st->sensor[i].ts = ts_algo->last_run_time -
+						elaps_time - JITTER_THRESH;
+	} else {
+		st->sensor[i].ts = ts_algo->last_run_time - elaps_time -
+							JITTER_THRESH;
+		st->sensor[i].previous_ts = st->sensor[i].ts;
+	}
+
+	if (st->sensor[i].ts > thresh1)
+		st->sensor[i].ts_adj = thresh1 - st->sensor[i].ts;
+	pr_debug("cali=%d\n", st->ts_algo.calib_counter);
+	pr_debug("adj= %lld\n", st->sensor[i].ts_adj);
+	pr_debug("dur= %d count= %d last= %lld\n", st->sensor[i].dur,
+				st->sensor[i].count, ts_algo->last_run_time);
+	if (st->sensor[i].ts_adj && (st->sensor[i].count > 1))
+		st->sensor[i].ts_adj = div_s64(st->sensor[i].ts_adj,
+							st->sensor[i].count);
+}
+/* inv_bound_timestamp (struct inv_mpu_state *st)
+	The purpose this function is to give a generic bound to each
+	sensor timestamp. The timestamp cannot exceed current time.
+	The timestamp cannot backwards one sample time either, otherwise, there
+	would be another sample in between. Using this principle, we can bound
+	the sensor samples */
+int inv_bound_timestamp(struct inv_mpu_state *st)
+{
+	int i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (st->sensor[i].count) {
+				process_sensor_bounding(st, i);
+			} else if (ts_algo->calib_counter <
+				   INV_TIME_CALIB_THRESHOLD_1) {
+				st->sensor[i].ts = ts_algo->reset_ts;
+				st->sensor[i].previous_ts = st->sensor[i].ts;
+			}
+		}
+	}
+
+	return 0;
+}
diff --git a/include/linux/iio/imu/mpu.h b/include/linux/iio/imu/mpu.h
new file mode 100644
index 000000000000..0e294aff8c50
--- /dev/null
+++ b/include/linux/iio/imu/mpu.h
@@ -0,0 +1,125 @@
+/*
+* Copyright (C) 2012-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef __MPU_H_
+#define __MPU_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#endif
+
+enum secondary_slave_type {
+	SECONDARY_SLAVE_TYPE_NONE,
+	SECONDARY_SLAVE_TYPE_ACCEL,
+	SECONDARY_SLAVE_TYPE_COMPASS,
+	SECONDARY_SLAVE_TYPE_PRESSURE,
+	SECONDARY_SLAVE_TYPE_ALS,
+
+	SECONDARY_SLAVE_TYPE_TYPES
+};
+
+enum ext_slave_id {
+	ID_INVALID = 0,
+	GYRO_ID_MPU3050,
+	GYRO_ID_MPU6050A2,
+	GYRO_ID_MPU6050B1,
+	GYRO_ID_MPU6050B1_NO_ACCEL,
+	GYRO_ID_ITG3500,
+
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303DLX,
+	ACCEL_ID_LIS3DH,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_BMA250,
+	ACCEL_ID_ADXL34X,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA845X,
+	ACCEL_ID_MPU6050,
+
+	COMPASS_ID_AK8963,
+	COMPASS_ID_AK8975,
+	COMPASS_ID_AK8972,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_AMI306,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_YAS530,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303DLH,
+	COMPASS_ID_LSM303DLM,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_HSCDTD002B,
+	COMPASS_ID_HSCDTD004A,
+	COMPASS_ID_MLX90399,
+	COMPASS_ID_AK09911,
+	COMPASS_ID_AK09912,
+	COMPASS_ID_AK09915,
+	COMPASS_ID_AK09916,
+
+	PRESSURE_ID_BMP085,
+	PRESSURE_ID_BMP280,
+
+	ALS_ID_APDS_9900,
+	ALS_ID_APDS_9930,
+	ALS_ID_TSL_2772,
+};
+
+#define INV_PROD_KEY(ver, rev) (ver * 100 + rev)
+/**
+ * struct mpu_platform_data - Platform data for the mpu driver
+ * @int_config:		Bits [7:3] of the int config register.
+ * @level_shifter:	0: VLogic, 1: VDD
+ * @orientation:	Orientation matrix of the gyroscope
+ * @sec_slave_type:     secondary slave device type, can be compass, accel, etc
+ * @sec_slave_id:       id of the secondary slave device
+ * @secondary_i2c_address: secondary device's i2c address
+ * @secondary_orientation: secondary device's orientation matrix
+ * @aux_slave_type: auxiliary slave. Another slave device type
+ * @aux_slave_id: auxiliary slave ID.
+ * @aux_i2c_addr: auxiliary device I2C address.
+ * @read_only_slave_type: read only slave type.
+ * @read_only_slave_id: read only slave device ID.
+ * @read_only_i2c_addr: read only slave device address.
+ *
+ * Contains platform specific information on how to configure the MPU3050 to
+ * work on this platform.  The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct mpu_platform_data {
+	__u8 int_config;
+	__u8 level_shifter;
+	__s8 orientation[9];
+	enum secondary_slave_type sec_slave_type;
+	enum ext_slave_id sec_slave_id;
+	__u16 secondary_i2c_addr;
+	__s8 secondary_orientation[9];
+	enum secondary_slave_type aux_slave_type;
+	enum ext_slave_id aux_slave_id;
+	__u16 aux_i2c_addr;
+	enum secondary_slave_type read_only_slave_type;
+	enum ext_slave_id read_only_slave_id;
+	__u16 read_only_i2c_addr;
+#ifdef CONFIG_OF
+	int (*power_on)(struct mpu_platform_data *);
+	int (*power_off)(struct mpu_platform_data *);
+	struct regulator *vdd_ana;
+	struct regulator *vdd_i2c;
+#endif
+};
+
+#endif	/* __MPU_H_ */
